#![allow(clippy::missing_safety_doc)]
                #![allow(clippy::identity_op)]
                #![allow(clippy::unnecessary_cast)]
                #![allow(clippy::erasing_op)]

# [doc = "Analog-to-digital converter"]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Adc { ptr : * mut u8 } unsafe impl Send for Adc { } unsafe impl Sync for Adc { } impl Adc { # [inline (always)]
pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)]
pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "status register"]
# [inline (always)]
pub const fn sr (self) -> crate :: common :: Reg < regs :: Sr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x0usize) as _) } } # [doc = "control register 1"]
# [inline (always)]
pub const fn cr1 (self) -> crate :: common :: Reg < regs :: Cr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x04usize) as _) } } # [doc = "control register 2"]
# [inline (always)]
pub const fn cr2 (self) -> crate :: common :: Reg < regs :: Cr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x08usize) as _) } } # [doc = "sample time register 1"]
# [inline (always)]
pub const fn smpr1 (self) -> crate :: common :: Reg < regs :: Smpr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x0cusize) as _) } } # [doc = "sample time register 2"]
# [inline (always)]
pub const fn smpr2 (self) -> crate :: common :: Reg < regs :: Smpr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x10usize) as _) } } # [doc = "injected channel data offset register x"]
# [inline (always)]
pub const fn jofr (self , n : usize) -> crate :: common :: Reg < regs :: Jofr , crate :: common :: RW > { assert ! (n < 4usize) ; unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x14usize + n * 4usize) as _) } } # [doc = "watchdog higher threshold register"]
# [inline (always)]
pub const fn htr (self) -> crate :: common :: Reg < regs :: Htr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x24usize) as _) } } # [doc = "watchdog lower threshold register"]
# [inline (always)]
pub const fn ltr (self) -> crate :: common :: Reg < regs :: Ltr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x28usize) as _) } } # [doc = "regular sequence register 1"]
# [inline (always)]
pub const fn sqr1 (self) -> crate :: common :: Reg < regs :: Sqr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x2cusize) as _) } } # [doc = "regular sequence register 2"]
# [inline (always)]
pub const fn sqr2 (self) -> crate :: common :: Reg < regs :: Sqr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x30usize) as _) } } # [doc = "regular sequence register 3"]
# [inline (always)]
pub const fn sqr3 (self) -> crate :: common :: Reg < regs :: Sqr3 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x34usize) as _) } } # [doc = "injected sequence register"]
# [inline (always)]
pub const fn jsqr (self) -> crate :: common :: Reg < regs :: Jsqr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x38usize) as _) } } # [doc = "injected data register x"]
# [inline (always)]
pub const fn jdr (self , n : usize) -> crate :: common :: Reg < regs :: Jdr , crate :: common :: R > { assert ! (n < 4usize) ; unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x3cusize + n * 4usize) as _) } } # [doc = "regular data register"]
# [inline (always)]
pub const fn dr (self) -> crate :: common :: Reg < regs :: Dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x4cusize) as _) } } } pub mod regs { # [doc = "control register 1"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Cr1 (pub u32) ; impl Cr1 { # [doc = "Analog watchdog channel select bits"]
# [inline (always)]
pub const fn awdch (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x1f ; val as u8 } # [doc = "Analog watchdog channel select bits"]
# [inline (always)]
pub fn set_awdch (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize) ; } # [doc = "Interrupt enable for EOC"]
# [inline (always)]
pub const fn eocie (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Interrupt enable for EOC"]
# [inline (always)]
pub fn set_eocie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Analog watchdog interrupt enable"]
# [inline (always)]
pub const fn awdie (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Analog watchdog interrupt enable"]
# [inline (always)]
pub fn set_awdie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Interrupt enable for injected channels"]
# [inline (always)]
pub const fn jeocie (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Interrupt enable for injected channels"]
# [inline (always)]
pub fn set_jeocie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Scan mode"]
# [inline (always)]
pub const fn scan (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Scan mode"]
# [inline (always)]
pub fn set_scan (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Enable the watchdog on a single channel in scan mode"]
# [inline (always)]
pub const fn awdsgl (& self) -> super :: vals :: Awdsgl { let val = (self . 0 >> 9usize) & 0x01 ; super :: vals :: Awdsgl :: from_bits (val as u8) } # [doc = "Enable the watchdog on a single channel in scan mode"]
# [inline (always)]
pub fn set_awdsgl (& mut self , val : super :: vals :: Awdsgl) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val . to_bits () as u32) & 0x01) << 9usize) ; } # [doc = "Automatic injected group conversion"]
# [inline (always)]
pub const fn jauto (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Automatic injected group conversion"]
# [inline (always)]
pub fn set_jauto (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Discontinuous mode on regular channels"]
# [inline (always)]
pub const fn discen (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Discontinuous mode on regular channels"]
# [inline (always)]
pub fn set_discen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Discontinuous mode on injected channels"]
# [inline (always)]
pub const fn jdiscen (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Discontinuous mode on injected channels"]
# [inline (always)]
pub fn set_jdiscen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Discontinuous mode channel count"]
# [inline (always)]
pub const fn discnum (& self) -> u8 { let val = (self . 0 >> 13usize) & 0x07 ; val as u8 } # [doc = "Discontinuous mode channel count"]
# [inline (always)]
pub fn set_discnum (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 13usize)) | (((val as u32) & 0x07) << 13usize) ; } # [doc = "Analog watchdog enable on injected channels"]
# [inline (always)]
pub const fn jawden (& self) -> bool { let val = (self . 0 >> 22usize) & 0x01 ; val != 0 } # [doc = "Analog watchdog enable on injected channels"]
# [inline (always)]
pub fn set_jawden (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize) ; } # [doc = "Analog watchdog enable on regular channels"]
# [inline (always)]
pub const fn awden (& self) -> bool { let val = (self . 0 >> 23usize) & 0x01 ; val != 0 } # [doc = "Analog watchdog enable on regular channels"]
# [inline (always)]
pub fn set_awden (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize) ; } # [doc = "Resolution"]
# [inline (always)]
pub const fn res (& self) -> super :: vals :: Res { let val = (self . 0 >> 24usize) & 0x03 ; super :: vals :: Res :: from_bits (val as u8) } # [doc = "Resolution"]
# [inline (always)]
pub fn set_res (& mut self , val : super :: vals :: Res) { self . 0 = (self . 0 & ! (0x03 << 24usize)) | (((val . to_bits () as u32) & 0x03) << 24usize) ; } # [doc = "Overrun interrupt enable"]
# [inline (always)]
pub const fn ovrie (& self) -> bool { let val = (self . 0 >> 26usize) & 0x01 ; val != 0 } # [doc = "Overrun interrupt enable"]
# [inline (always)]
pub fn set_ovrie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize) ; } } impl Default for Cr1 { # [inline (always)]
fn default () -> Cr1 { Cr1 (0) } } # [doc = "control register 2"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Cr2 (pub u32) ; impl Cr2 { # [doc = "A/D Converter ON / OFF"]
# [inline (always)]
pub const fn adon (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "A/D Converter ON / OFF"]
# [inline (always)]
pub fn set_adon (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Continuous conversion"]
# [inline (always)]
pub const fn cont (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Continuous conversion"]
# [inline (always)]
pub fn set_cont (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Direct memory access mode (for single ADC mode)"]
# [inline (always)]
pub const fn dma (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Direct memory access mode (for single ADC mode)"]
# [inline (always)]
pub fn set_dma (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "DMA disable selection (for single ADC mode)"]
# [inline (always)]
pub const fn dds (& self) -> super :: vals :: Dds { let val = (self . 0 >> 9usize) & 0x01 ; super :: vals :: Dds :: from_bits (val as u8) } # [doc = "DMA disable selection (for single ADC mode)"]
# [inline (always)]
pub fn set_dds (& mut self , val : super :: vals :: Dds) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val . to_bits () as u32) & 0x01) << 9usize) ; } # [doc = "End of conversion selection"]
# [inline (always)]
pub const fn eocs (& self) -> super :: vals :: Eocs { let val = (self . 0 >> 10usize) & 0x01 ; super :: vals :: Eocs :: from_bits (val as u8) } # [doc = "End of conversion selection"]
# [inline (always)]
pub fn set_eocs (& mut self , val : super :: vals :: Eocs) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val . to_bits () as u32) & 0x01) << 10usize) ; } # [doc = "Data alignment"]
# [inline (always)]
pub const fn align (& self) -> super :: vals :: Align { let val = (self . 0 >> 11usize) & 0x01 ; super :: vals :: Align :: from_bits (val as u8) } # [doc = "Data alignment"]
# [inline (always)]
pub fn set_align (& mut self , val : super :: vals :: Align) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val . to_bits () as u32) & 0x01) << 11usize) ; } # [doc = "External event select for injected group"]
# [inline (always)]
pub const fn jextsel (& self) -> u8 { let val = (self . 0 >> 16usize) & 0x0f ; val as u8 } # [doc = "External event select for injected group"]
# [inline (always)]
pub fn set_jextsel (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize) ; } # [doc = "External trigger enable for injected channels"]
# [inline (always)]
pub const fn jexten (& self) -> super :: vals :: Jexten { let val = (self . 0 >> 20usize) & 0x03 ; super :: vals :: Jexten :: from_bits (val as u8) } # [doc = "External trigger enable for injected channels"]
# [inline (always)]
pub fn set_jexten (& mut self , val : super :: vals :: Jexten) { self . 0 = (self . 0 & ! (0x03 << 20usize)) | (((val . to_bits () as u32) & 0x03) << 20usize) ; } # [doc = "Start conversion of injected channels"]
# [inline (always)]
pub const fn jswstart (& self) -> bool { let val = (self . 0 >> 22usize) & 0x01 ; val != 0 } # [doc = "Start conversion of injected channels"]
# [inline (always)]
pub fn set_jswstart (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize) ; } # [doc = "External event select for regular group"]
# [inline (always)]
pub const fn extsel (& self) -> u8 { let val = (self . 0 >> 24usize) & 0x0f ; val as u8 } # [doc = "External event select for regular group"]
# [inline (always)]
pub fn set_extsel (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize) ; } # [doc = "External trigger enable for regular channels"]
# [inline (always)]
pub const fn exten (& self) -> super :: vals :: Exten { let val = (self . 0 >> 28usize) & 0x03 ; super :: vals :: Exten :: from_bits (val as u8) } # [doc = "External trigger enable for regular channels"]
# [inline (always)]
pub fn set_exten (& mut self , val : super :: vals :: Exten) { self . 0 = (self . 0 & ! (0x03 << 28usize)) | (((val . to_bits () as u32) & 0x03) << 28usize) ; } # [doc = "Start conversion of regular channels"]
# [inline (always)]
pub const fn swstart (& self) -> bool { let val = (self . 0 >> 30usize) & 0x01 ; val != 0 } # [doc = "Start conversion of regular channels"]
# [inline (always)]
pub fn set_swstart (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize) ; } } impl Default for Cr2 { # [inline (always)]
fn default () -> Cr2 { Cr2 (0) } } # [doc = "regular data register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Dr (pub u32) ; impl Dr { # [doc = "Regular data"]
# [inline (always)]
pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Regular data"]
# [inline (always)]
pub fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Dr { # [inline (always)]
fn default () -> Dr { Dr (0) } } # [doc = "watchdog higher threshold register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Htr (pub u32) ; impl Htr { # [doc = "Analog watchdog higher threshold"]
# [inline (always)]
pub const fn ht (& self) -> u16 { let val = (self . 0 >> 0usize) & 0x0fff ; val as u16 } # [doc = "Analog watchdog higher threshold"]
# [inline (always)]
pub fn set_ht (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize) ; } } impl Default for Htr { # [inline (always)]
fn default () -> Htr { Htr (0) } } # [doc = "injected data register x"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Jdr (pub u32) ; impl Jdr { # [doc = "Injected data"]
# [inline (always)]
pub const fn jdata (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Injected data"]
# [inline (always)]
pub fn set_jdata (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Jdr { # [inline (always)]
fn default () -> Jdr { Jdr (0) } } # [doc = "injected channel data offset register x"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Jofr (pub u32) ; impl Jofr { # [doc = "Data offset for injected channel x"]
# [inline (always)]
pub const fn joffset (& self) -> u16 { let val = (self . 0 >> 0usize) & 0x0fff ; val as u16 } # [doc = "Data offset for injected channel x"]
# [inline (always)]
pub fn set_joffset (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize) ; } } impl Default for Jofr { # [inline (always)]
fn default () -> Jofr { Jofr (0) } } # [doc = "injected sequence register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Jsqr (pub u32) ; impl Jsqr { # [doc = "1st conversion in injected sequence"]
# [inline (always)]
pub const fn jsq (& self , n : usize) -> u8 { assert ! (n < 4usize) ; let offs = 0usize + n * 5usize ; let val = (self . 0 >> offs) & 0x1f ; val as u8 } # [doc = "1st conversion in injected sequence"]
# [inline (always)]
pub fn set_jsq (& mut self , n : usize , val : u8) { assert ! (n < 4usize) ; let offs = 0usize + n * 5usize ; self . 0 = (self . 0 & ! (0x1f << offs)) | (((val as u32) & 0x1f) << offs) ; } # [doc = "Injected sequence length"]
# [inline (always)]
pub const fn jl (& self) -> u8 { let val = (self . 0 >> 20usize) & 0x03 ; val as u8 } # [doc = "Injected sequence length"]
# [inline (always)]
pub fn set_jl (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 20usize)) | (((val as u32) & 0x03) << 20usize) ; } } impl Default for Jsqr { # [inline (always)]
fn default () -> Jsqr { Jsqr (0) } } # [doc = "watchdog lower threshold register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Ltr (pub u32) ; impl Ltr { # [doc = "Analog watchdog lower threshold"]
# [inline (always)]
pub const fn lt (& self) -> u16 { let val = (self . 0 >> 0usize) & 0x0fff ; val as u16 } # [doc = "Analog watchdog lower threshold"]
# [inline (always)]
pub fn set_lt (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize) ; } } impl Default for Ltr { # [inline (always)]
fn default () -> Ltr { Ltr (0) } } # [doc = "sample time register 1"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Smpr1 (pub u32) ; impl Smpr1 { # [doc = "Channel 10 sampling time selection"]
# [inline (always)]
pub const fn smp (& self , n : usize) -> super :: vals :: SampleTime { assert ! (n < 9usize) ; let offs = 0usize + n * 3usize ; let val = (self . 0 >> offs) & 0x07 ; super :: vals :: SampleTime :: from_bits (val as u8) } # [doc = "Channel 10 sampling time selection"]
# [inline (always)]
pub fn set_smp (& mut self , n : usize , val : super :: vals :: SampleTime) { assert ! (n < 9usize) ; let offs = 0usize + n * 3usize ; self . 0 = (self . 0 & ! (0x07 << offs)) | (((val . to_bits () as u32) & 0x07) << offs) ; } # [doc = "Sample time bits"]
# [inline (always)]
pub const fn smpx_x (& self) -> super :: vals :: SmprSmpxX { let val = (self . 0 >> 0usize) & 0xffff_ffff ; super :: vals :: SmprSmpxX :: from_bits (val as u32) } # [doc = "Sample time bits"]
# [inline (always)]
pub fn set_smpx_x (& mut self , val : super :: vals :: SmprSmpxX) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val . to_bits () as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Smpr1 { # [inline (always)]
fn default () -> Smpr1 { Smpr1 (0) } } # [doc = "sample time register 2"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Smpr2 (pub u32) ; impl Smpr2 { # [doc = "Channel 0 sampling time selection"]
# [inline (always)]
pub const fn smp (& self , n : usize) -> super :: vals :: SampleTime { assert ! (n < 10usize) ; let offs = 0usize + n * 3usize ; let val = (self . 0 >> offs) & 0x07 ; super :: vals :: SampleTime :: from_bits (val as u8) } # [doc = "Channel 0 sampling time selection"]
# [inline (always)]
pub fn set_smp (& mut self , n : usize , val : super :: vals :: SampleTime) { assert ! (n < 10usize) ; let offs = 0usize + n * 3usize ; self . 0 = (self . 0 & ! (0x07 << offs)) | (((val . to_bits () as u32) & 0x07) << offs) ; } # [doc = "Sample time bits"]
# [inline (always)]
pub const fn smpx_x (& self) -> super :: vals :: SmprSmpxX { let val = (self . 0 >> 0usize) & 0xffff_ffff ; super :: vals :: SmprSmpxX :: from_bits (val as u32) } # [doc = "Sample time bits"]
# [inline (always)]
pub fn set_smpx_x (& mut self , val : super :: vals :: SmprSmpxX) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val . to_bits () as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Smpr2 { # [inline (always)]
fn default () -> Smpr2 { Smpr2 (0) } } # [doc = "regular sequence register 1"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Sqr1 (pub u32) ; impl Sqr1 { # [doc = "13th conversion in regular sequence"]
# [inline (always)]
pub const fn sq (& self , n : usize) -> u8 { assert ! (n < 4usize) ; let offs = 0usize + n * 5usize ; let val = (self . 0 >> offs) & 0x1f ; val as u8 } # [doc = "13th conversion in regular sequence"]
# [inline (always)]
pub fn set_sq (& mut self , n : usize , val : u8) { assert ! (n < 4usize) ; let offs = 0usize + n * 5usize ; self . 0 = (self . 0 & ! (0x1f << offs)) | (((val as u32) & 0x1f) << offs) ; } # [doc = "Regular channel sequence length"]
# [inline (always)]
pub const fn l (& self) -> u8 { let val = (self . 0 >> 20usize) & 0x0f ; val as u8 } # [doc = "Regular channel sequence length"]
# [inline (always)]
pub fn set_l (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize) ; } } impl Default for Sqr1 { # [inline (always)]
fn default () -> Sqr1 { Sqr1 (0) } } # [doc = "regular sequence register 2"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Sqr2 (pub u32) ; impl Sqr2 { # [doc = "7th conversion in regular sequence"]
# [inline (always)]
pub const fn sq (& self , n : usize) -> u8 { assert ! (n < 6usize) ; let offs = 0usize + n * 5usize ; let val = (self . 0 >> offs) & 0x1f ; val as u8 } # [doc = "7th conversion in regular sequence"]
# [inline (always)]
pub fn set_sq (& mut self , n : usize , val : u8) { assert ! (n < 6usize) ; let offs = 0usize + n * 5usize ; self . 0 = (self . 0 & ! (0x1f << offs)) | (((val as u32) & 0x1f) << offs) ; } } impl Default for Sqr2 { # [inline (always)]
fn default () -> Sqr2 { Sqr2 (0) } } # [doc = "regular sequence register 3"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Sqr3 (pub u32) ; impl Sqr3 { # [doc = "1st conversion in regular sequence"]
# [inline (always)]
pub const fn sq (& self , n : usize) -> u8 { assert ! (n < 6usize) ; let offs = 0usize + n * 5usize ; let val = (self . 0 >> offs) & 0x1f ; val as u8 } # [doc = "1st conversion in regular sequence"]
# [inline (always)]
pub fn set_sq (& mut self , n : usize , val : u8) { assert ! (n < 6usize) ; let offs = 0usize + n * 5usize ; self . 0 = (self . 0 & ! (0x1f << offs)) | (((val as u32) & 0x1f) << offs) ; } } impl Default for Sqr3 { # [inline (always)]
fn default () -> Sqr3 { Sqr3 (0) } } # [doc = "status register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Sr (pub u32) ; impl Sr { # [doc = "Analog watchdog event occurred"]
# [inline (always)]
pub const fn awd (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Analog watchdog event occurred"]
# [inline (always)]
pub fn set_awd (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Regular channel end of conversion"]
# [inline (always)]
pub const fn eoc (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Regular channel end of conversion"]
# [inline (always)]
pub fn set_eoc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Injected channel end of conversion"]
# [inline (always)]
pub const fn jeoc (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Injected channel end of conversion"]
# [inline (always)]
pub fn set_jeoc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Injected channel conversion has started"]
# [inline (always)]
pub const fn jstrt (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Injected channel conversion has started"]
# [inline (always)]
pub fn set_jstrt (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Regular channel conversion has started"]
# [inline (always)]
pub const fn strt (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Regular channel conversion has started"]
# [inline (always)]
pub fn set_strt (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Overrun occurred"]
# [inline (always)]
pub const fn ovr (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Overrun occurred"]
# [inline (always)]
pub fn set_ovr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } } impl Default for Sr { # [inline (always)]
fn default () -> Sr { Sr (0) } } } pub mod vals { # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Align { # [doc = "Right alignment"]
RIGHT = 0x0 , # [doc = "Left alignment"]
LEFT = 0x01 , } impl Align { # [inline (always)]
pub const fn from_bits (val : u8) -> Align { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Align { # [inline (always)]
fn from (val : u8) -> Align { Align :: from_bits (val) } } impl From < Align > for u8 { # [inline (always)]
fn from (val : Align) -> u8 { Align :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Awdsgl { # [doc = "Analog watchdog enabled on all channels"]
ALLCHANNELS = 0x0 , # [doc = "Analog watchdog enabled on a single channel"]
SINGLECHANNEL = 0x01 , } impl Awdsgl { # [inline (always)]
pub const fn from_bits (val : u8) -> Awdsgl { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Awdsgl { # [inline (always)]
fn from (val : u8) -> Awdsgl { Awdsgl :: from_bits (val) } } impl From < Awdsgl > for u8 { # [inline (always)]
fn from (val : Awdsgl) -> u8 { Awdsgl :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Dds { # [doc = "No new DMA request is issued after the last transfer"]
SINGLE = 0x0 , # [doc = "DMA requests are issued as long as data are converted and DMA=1"]
CONTINUOUS = 0x01 , } impl Dds { # [inline (always)]
pub const fn from_bits (val : u8) -> Dds { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Dds { # [inline (always)]
fn from (val : u8) -> Dds { Dds :: from_bits (val) } } impl From < Dds > for u8 { # [inline (always)]
fn from (val : Dds) -> u8 { Dds :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Eocs { # [doc = "The EOC bit is set at the end of each sequence of regular conversions"]
EACHSEQUENCE = 0x0 , # [doc = "The EOC bit is set at the end of each regular conversion"]
EACHCONVERSION = 0x01 , } impl Eocs { # [inline (always)]
pub const fn from_bits (val : u8) -> Eocs { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Eocs { # [inline (always)]
fn from (val : u8) -> Eocs { Eocs :: from_bits (val) } } impl From < Eocs > for u8 { # [inline (always)]
fn from (val : Eocs) -> u8 { Eocs :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Exten { # [doc = "Trigger detection disabled"]
DISABLED = 0x0 , # [doc = "Trigger detection on the rising edge"]
RISINGEDGE = 0x01 , # [doc = "Trigger detection on the falling edge"]
FALLINGEDGE = 0x02 , # [doc = "Trigger detection on both the rising and falling edges"]
BOTHEDGES = 0x03 , } impl Exten { # [inline (always)]
pub const fn from_bits (val : u8) -> Exten { unsafe { core :: mem :: transmute (val & 0x03) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Exten { # [inline (always)]
fn from (val : u8) -> Exten { Exten :: from_bits (val) } } impl From < Exten > for u8 { # [inline (always)]
fn from (val : Exten) -> u8 { Exten :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Jexten { # [doc = "Trigger detection disabled"]
DISABLED = 0x0 , # [doc = "Trigger detection on the rising edge"]
RISINGEDGE = 0x01 , # [doc = "Trigger detection on the falling edge"]
FALLINGEDGE = 0x02 , # [doc = "Trigger detection on both the rising and falling edges"]
BOTHEDGES = 0x03 , } impl Jexten { # [inline (always)]
pub const fn from_bits (val : u8) -> Jexten { unsafe { core :: mem :: transmute (val & 0x03) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Jexten { # [inline (always)]
fn from (val : u8) -> Jexten { Jexten :: from_bits (val) } } impl From < Jexten > for u8 { # [inline (always)]
fn from (val : Jexten) -> u8 { Jexten :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Res { # [doc = "12-bit (15 ADCCLK cycles)"]
BITS12 = 0x0 , # [doc = "10-bit (13 ADCCLK cycles)"]
BITS10 = 0x01 , # [doc = "8-bit (11 ADCCLK cycles)"]
BITS8 = 0x02 , # [doc = "6-bit (9 ADCCLK cycles)"]
BITS6 = 0x03 , } impl Res { # [inline (always)]
pub const fn from_bits (val : u8) -> Res { unsafe { core :: mem :: transmute (val & 0x03) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Res { # [inline (always)]
fn from (val : u8) -> Res { Res :: from_bits (val) } } impl From < Res > for u8 { # [inline (always)]
fn from (val : Res) -> u8 { Res :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum SampleTime { # [doc = "3 cycles"]
CYCLES3 = 0x0 , # [doc = "15 cycles"]
CYCLES15 = 0x01 , # [doc = "28 cycles"]
CYCLES28 = 0x02 , # [doc = "56 cycles"]
CYCLES56 = 0x03 , # [doc = "84 cycles"]
CYCLES84 = 0x04 , # [doc = "112 cycles"]
CYCLES112 = 0x05 , # [doc = "144 cycles"]
CYCLES144 = 0x06 , # [doc = "480 cycles"]
CYCLES480 = 0x07 , } impl SampleTime { # [inline (always)]
pub const fn from_bits (val : u8) -> SampleTime { unsafe { core :: mem :: transmute (val & 0x07) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for SampleTime { # [inline (always)]
fn from (val : u8) -> SampleTime { SampleTime :: from_bits (val) } } impl From < SampleTime > for u8 { # [inline (always)]
fn from (val : SampleTime) -> u8 { SampleTime :: to_bits (val) } } # [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub struct SmprSmpxX (pub u32) ; impl SmprSmpxX { # [doc = "3 cycles"]
pub const CYCLES3 : Self = Self (0x0) ; # [doc = "15 cycles"]
pub const CYCLES15 : Self = Self (0x01) ; # [doc = "28 cycles"]
pub const CYCLES28 : Self = Self (0x02) ; # [doc = "56 cycles"]
pub const CYCLES56 : Self = Self (0x03) ; # [doc = "84 cycles"]
pub const CYCLES84 : Self = Self (0x04) ; # [doc = "112 cycles"]
pub const CYCLES112 : Self = Self (0x05) ; # [doc = "144 cycles"]
pub const CYCLES144 : Self = Self (0x06) ; # [doc = "480 cycles"]
pub const CYCLES480 : Self = Self (0x07) ; } impl SmprSmpxX { pub const fn from_bits (val : u32) -> SmprSmpxX { Self (val & 0xffff_ffff) } pub const fn to_bits (self) -> u32 { self . 0 } } impl From < u32 > for SmprSmpxX { # [inline (always)]
fn from (val : u32) -> SmprSmpxX { SmprSmpxX :: from_bits (val) } } impl From < SmprSmpxX > for u32 { # [inline (always)]
fn from (val : SmprSmpxX) -> u32 { SmprSmpxX :: to_bits (val) } } }