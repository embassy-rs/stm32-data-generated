#![allow(clippy::missing_safety_doc)]
                #![allow(clippy::identity_op)]
                #![allow(clippy::unnecessary_cast)]
                #![allow(clippy::erasing_op)]

# [doc = "ADC common registers"]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct AdcCommon { ptr : * mut u8 } unsafe impl Send for AdcCommon { } unsafe impl Sync for AdcCommon { } impl AdcCommon { # [inline (always)]
pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)]
pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "common control register"]
# [inline (always)]
pub const fn ccr (self) -> crate :: common :: Reg < regs :: Ccr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x08usize) as _) } } # [doc = "hardware configuration register"]
# [inline (always)]
pub const fn hwcfgr0 (self) -> crate :: common :: Reg < regs :: Hwcfgr0 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0xf0usize) as _) } } # [doc = "version register"]
# [inline (always)]
pub const fn verr (self) -> crate :: common :: Reg < regs :: Verr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0xf4usize) as _) } } # [doc = "identification register"]
# [inline (always)]
pub const fn ipdr (self) -> crate :: common :: Reg < u32 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0xf8usize) as _) } } # [doc = "size identification register"]
# [inline (always)]
pub const fn sidr (self) -> crate :: common :: Reg < u32 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0xfcusize) as _) } } } pub mod regs { # [doc = "common control register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Ccr (pub u32) ; impl Ccr { # [doc = "ADC clock mode These bits are set and cleared by software to define the ADC clock scheme (which is common to both master and slave ADCs): In all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion. Note: The software is allowed to write these bits only when the ADCs are disabled (ADCAL = 0, JADSTART = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0)."]
# [inline (always)]
pub const fn ckmode (& self) -> super :: vals :: Ckmode { let val = (self . 0 >> 16usize) & 0x03 ; super :: vals :: Ckmode :: from_bits (val as u8) } # [doc = "ADC clock mode These bits are set and cleared by software to define the ADC clock scheme (which is common to both master and slave ADCs): In all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion. Note: The software is allowed to write these bits only when the ADCs are disabled (ADCAL = 0, JADSTART = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0)."]
# [inline (always)]
pub fn set_ckmode (& mut self , val : super :: vals :: Ckmode) { self . 0 = (self . 0 & ! (0x03 << 16usize)) | (((val . to_bits () as u32) & 0x03) << 16usize) ; } # [doc = "ADC prescaler These bits are set and cleared by software to select the frequency of the clock to the ADC. The clock is common for all the ADCs. other: reserved Note: The software is allowed to write these bits only when the ADC is disabled (ADCAL = 0, JADSTART = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0). The ADC prescaler value is applied only when CKMODE\\[1:0\\]
= 0b00."]
# [inline (always)]
pub const fn presc (& self) -> super :: vals :: Presc { let val = (self . 0 >> 18usize) & 0x0f ; super :: vals :: Presc :: from_bits (val as u8) } # [doc = "ADC prescaler These bits are set and cleared by software to select the frequency of the clock to the ADC. The clock is common for all the ADCs. other: reserved Note: The software is allowed to write these bits only when the ADC is disabled (ADCAL = 0, JADSTART = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0). The ADC prescaler value is applied only when CKMODE\\[1:0\\]
= 0b00."]
# [inline (always)]
pub fn set_presc (& mut self , val : super :: vals :: Presc) { self . 0 = (self . 0 & ! (0x0f << 18usize)) | (((val . to_bits () as u32) & 0x0f) << 18usize) ; } # [doc = "VREFINT enable This bit is set and cleared by software to enable/disable the VREFINT channel"]
# [inline (always)]
pub const fn vrefen (& self) -> bool { let val = (self . 0 >> 22usize) & 0x01 ; val != 0 } # [doc = "VREFINT enable This bit is set and cleared by software to enable/disable the VREFINT channel"]
# [inline (always)]
pub fn set_vrefen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize) ; } # [doc = "VSENSE enable This bit is set and cleared by software to control VSENSE"]
# [inline (always)]
pub const fn tsen (& self) -> bool { let val = (self . 0 >> 23usize) & 0x01 ; val != 0 } # [doc = "VSENSE enable This bit is set and cleared by software to control VSENSE"]
# [inline (always)]
pub fn set_tsen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize) ; } # [doc = "VBAT enable This bit is set and cleared by software to control"]
# [inline (always)]
pub const fn vbaten (& self) -> bool { let val = (self . 0 >> 24usize) & 0x01 ; val != 0 } # [doc = "VBAT enable This bit is set and cleared by software to control"]
# [inline (always)]
pub fn set_vbaten (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize) ; } } impl Default for Ccr { # [inline (always)]
fn default () -> Ccr { Ccr (0) } } # [doc = "hardware configuration register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Hwcfgr0 (pub u32) ; impl Hwcfgr0 { # [doc = "Number of ADCs implemented"]
# [inline (always)]
pub const fn adcnum (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x0f ; val as u8 } # [doc = "Number of ADCs implemented"]
# [inline (always)]
pub fn set_adcnum (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize) ; } # [doc = "Number of pipeline stages"]
# [inline (always)]
pub const fn mulpipe (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Number of pipeline stages"]
# [inline (always)]
pub fn set_mulpipe (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "Number of option bits 0002: 2 option bits implemented in the ADC option register (ADC_OR) at address offset 0xC8."]
# [inline (always)]
pub const fn opbits (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x0f ; val as u8 } # [doc = "Number of option bits 0002: 2 option bits implemented in the ADC option register (ADC_OR) at address offset 0xC8."]
# [inline (always)]
pub fn set_opbits (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize) ; } # [doc = "Idle value for non-selected channels"]
# [inline (always)]
pub const fn idlevalue (& self) -> super :: vals :: Idlevalue { let val = (self . 0 >> 12usize) & 0x0f ; super :: vals :: Idlevalue :: from_bits (val as u8) } # [doc = "Idle value for non-selected channels"]
# [inline (always)]
pub fn set_idlevalue (& mut self , val : super :: vals :: Idlevalue) { self . 0 = (self . 0 & ! (0x0f << 12usize)) | (((val . to_bits () as u32) & 0x0f) << 12usize) ; } } impl Default for Hwcfgr0 { # [inline (always)]
fn default () -> Hwcfgr0 { Hwcfgr0 (0) } } # [doc = "version register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Verr (pub u32) ; impl Verr { # [doc = "Minor revision These bits returns the ADC IP minor revision 0002: Major revision = X.2."]
# [inline (always)]
pub const fn minrev (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x0f ; val as u8 } # [doc = "Minor revision These bits returns the ADC IP minor revision 0002: Major revision = X.2."]
# [inline (always)]
pub fn set_minrev (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize) ; } # [doc = "Major revision These bits returns the ADC IP major revision"]
# [inline (always)]
pub const fn majrev (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Major revision These bits returns the ADC IP major revision"]
# [inline (always)]
pub fn set_majrev (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } } impl Default for Verr { # [inline (always)]
fn default () -> Verr { Verr (0) } } } pub mod vals { # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Ckmode { # [doc = "Use Kernel Clock adc_ker_ck_input divided by PRESC. Asynchronous to AHB clock"]
ASYNCHRONOUS = 0x0 , # [doc = "Use AHB clock rcc_hclk3. In this case rcc_hclk must equal sys_d1cpre_ck"]
SYNCDIV1 = 0x01 , # [doc = "Use AHB clock rcc_hclk3 divided by 2"]
SYNCDIV2 = 0x02 , # [doc = "Use AHB clock rcc_hclk3 divided by 4"]
SYNCDIV4 = 0x03 , } impl Ckmode { # [inline (always)]
pub const fn from_bits (val : u8) -> Ckmode { unsafe { core :: mem :: transmute (val & 0x03) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Ckmode { # [inline (always)]
fn from (val : u8) -> Ckmode { Ckmode :: from_bits (val) } } impl From < Ckmode > for u8 { # [inline (always)]
fn from (val : Ckmode) -> u8 { Ckmode :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Idlevalue { # [doc = "Dummy channel selection is 0x13"]
H13 = 0x0 , # [doc = "Dummy channel selection is 0x1F"]
H1F = 0x01 , _RESERVED_2 = 0x02 , _RESERVED_3 = 0x03 , _RESERVED_4 = 0x04 , _RESERVED_5 = 0x05 , _RESERVED_6 = 0x06 , _RESERVED_7 = 0x07 , _RESERVED_8 = 0x08 , _RESERVED_9 = 0x09 , _RESERVED_a = 0x0a , _RESERVED_b = 0x0b , _RESERVED_c = 0x0c , _RESERVED_d = 0x0d , _RESERVED_e = 0x0e , _RESERVED_f = 0x0f , } impl Idlevalue { # [inline (always)]
pub const fn from_bits (val : u8) -> Idlevalue { unsafe { core :: mem :: transmute (val & 0x0f) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Idlevalue { # [inline (always)]
fn from (val : u8) -> Idlevalue { Idlevalue :: from_bits (val) } } impl From < Idlevalue > for u8 { # [inline (always)]
fn from (val : Idlevalue) -> u8 { Idlevalue :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Presc { # [doc = "adc_ker_ck_input not divided"]
DIV1 = 0x0 , # [doc = "adc_ker_ck_input divided by 2"]
DIV2 = 0x01 , # [doc = "adc_ker_ck_input divided by 4"]
DIV4 = 0x02 , # [doc = "adc_ker_ck_input divided by 6"]
DIV6 = 0x03 , # [doc = "adc_ker_ck_input divided by 8"]
DIV8 = 0x04 , # [doc = "adc_ker_ck_input divided by 10"]
DIV10 = 0x05 , # [doc = "adc_ker_ck_input divided by 12"]
DIV12 = 0x06 , # [doc = "adc_ker_ck_input divided by 16"]
DIV16 = 0x07 , # [doc = "adc_ker_ck_input divided by 32"]
DIV32 = 0x08 , # [doc = "adc_ker_ck_input divided by 64"]
DIV64 = 0x09 , # [doc = "adc_ker_ck_input divided by 128"]
DIV128 = 0x0a , # [doc = "adc_ker_ck_input divided by 256"]
DIV256 = 0x0b , _RESERVED_c = 0x0c , _RESERVED_d = 0x0d , _RESERVED_e = 0x0e , _RESERVED_f = 0x0f , } impl Presc { # [inline (always)]
pub const fn from_bits (val : u8) -> Presc { unsafe { core :: mem :: transmute (val & 0x0f) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Presc { # [inline (always)]
fn from (val : u8) -> Presc { Presc :: from_bits (val) } } impl From < Presc > for u8 { # [inline (always)]
fn from (val : Presc) -> u8 { Presc :: to_bits (val) } } }