#![allow(clippy::missing_safety_doc)]
#![allow(clippy::identity_op)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::erasing_op)]

#[doc = "Reset and clock control."]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rcc {
    ptr: *mut u8,
}
unsafe impl Send for Rcc {}
unsafe impl Sync for Rcc {}
impl Rcc {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "RCC control register."]
    #[inline(always)]
    pub const fn cr(self) -> crate::common::Reg<regs::Cr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "RCC status register."]
    #[inline(always)]
    pub const fn sr(self) -> crate::common::Reg<regs::Sr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
    }
    #[doc = "RCC Stop mode control register."]
    #[inline(always)]
    pub const fn stopcr(self) -> crate::common::Reg<regs::Stopcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "RCC configuration register 1."]
    #[inline(always)]
    pub const fn cfgr1(self) -> crate::common::Reg<regs::Cfgr1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "RCC configuration register 2."]
    #[inline(always)]
    pub const fn cfgr2(self) -> crate::common::Reg<regs::Cfgr2, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
    }
    #[doc = "RCC clock protection register."]
    #[inline(always)]
    pub const fn ckprotr(self) -> crate::common::Reg<regs::Ckprotr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
    #[doc = "RCC backup domain protection register."]
    #[inline(always)]
    pub const fn bdcr(self) -> crate::common::Reg<regs::Bdcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
    }
    #[doc = "RCC reset status register for hardware."]
    #[inline(always)]
    pub const fn hwrsr(self) -> crate::common::Reg<regs::Hwrsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
    }
    #[doc = "RCC reset register."]
    #[inline(always)]
    pub const fn rsr(self) -> crate::common::Reg<regs::Rsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
    }
    #[doc = "RCC LSE configuration register."]
    #[inline(always)]
    pub const fn lsecfgr(self) -> crate::common::Reg<regs::Lsecfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
    }
    #[doc = "RCC MSI configuration register."]
    #[inline(always)]
    pub const fn msicfgr(self) -> crate::common::Reg<regs::Msicfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
    }
    #[doc = "RCC HSI configuration register."]
    #[inline(always)]
    pub const fn hsicfgr(self) -> crate::common::Reg<regs::Hsicfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
    }
    #[doc = "RCC HSI monitor control register."]
    #[inline(always)]
    pub const fn hsimcr(self) -> crate::common::Reg<regs::Hsimcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
    }
    #[doc = "RCC HSI monitor status register."]
    #[inline(always)]
    pub const fn hsimsr(self) -> crate::common::Reg<regs::Hsimsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
    }
    #[doc = "RCC HSE configuration register."]
    #[inline(always)]
    pub const fn hsecfgr(self) -> crate::common::Reg<regs::Hsecfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
    }
    #[doc = "RCC PLL1 configuration register 1."]
    #[inline(always)]
    pub const fn pllcfgr1(self, n: usize) -> crate::common::Reg<regs::Pll1cfgr1, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 16usize) as _) }
    }
    #[doc = "RCC PLL1 configuration register 2."]
    #[inline(always)]
    pub const fn pllcfgr2(self, n: usize) -> crate::common::Reg<regs::Pll1cfgr2, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize + n * 16usize) as _) }
    }
    #[doc = "RCC PLL1 configuration register 3."]
    #[inline(always)]
    pub const fn pllcfgr3(self, n: usize) -> crate::common::Reg<regs::Pll1cfgr3, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize + n * 16usize) as _) }
    }
    #[doc = "RCC PLL2 configuration register 1."]
    #[inline(always)]
    pub const fn pll2cfgr1(self, n: usize) -> crate::common::Reg<regs::Pll2cfgr1, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize + n * 16usize) as _) }
    }
    #[doc = "RCC PLL2 configuration register 2."]
    #[inline(always)]
    pub const fn pll2cfgr2(self, n: usize) -> crate::common::Reg<regs::Pll2cfgr2, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize + n * 16usize) as _) }
    }
    #[doc = "RCC PLL2 configuration register 3."]
    #[inline(always)]
    pub const fn pll2cfgr3(self, n: usize) -> crate::common::Reg<regs::Pll2cfgr3, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize + n * 16usize) as _) }
    }
    #[doc = "RCC PLL3 configuration register 1."]
    #[inline(always)]
    pub const fn pll3cfgr1(self, n: usize) -> crate::common::Reg<regs::Pll3cfgr1, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize + n * 16usize) as _) }
    }
    #[doc = "RCC PLL3 configuration register 2."]
    #[inline(always)]
    pub const fn pll3cfgr2(self, n: usize) -> crate::common::Reg<regs::Pll3cfgr2, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize + n * 16usize) as _) }
    }
    #[doc = "RCC PLL3 configuration register 3."]
    #[inline(always)]
    pub const fn pll3cfgr3(self, n: usize) -> crate::common::Reg<regs::Pll3cfgr3, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa8usize + n * 16usize) as _) }
    }
    #[doc = "RCC PLL4 configuration register 1."]
    #[inline(always)]
    pub const fn pll4cfgr1(self, n: usize) -> crate::common::Reg<regs::Pll4cfgr1, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb0usize + n * 16usize) as _) }
    }
    #[doc = "RCC PLL4 configuration register 2."]
    #[inline(always)]
    pub const fn pll4cfgr2(self, n: usize) -> crate::common::Reg<regs::Pll4cfgr2, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb4usize + n * 16usize) as _) }
    }
    #[doc = "RCC PLL4 configuration register 3."]
    #[inline(always)]
    pub const fn pll4cfgr3(self, n: usize) -> crate::common::Reg<regs::Pll4cfgr3, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb8usize + n * 16usize) as _) }
    }
    #[doc = "RCC IC1 configuration register."]
    #[inline(always)]
    pub const fn ic1cfgr(self) -> crate::common::Reg<regs::Ic1cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc4usize) as _) }
    }
    #[doc = "RCC IC2 configuration register."]
    #[inline(always)]
    pub const fn ic2cfgr(self) -> crate::common::Reg<regs::Ic2cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc8usize) as _) }
    }
    #[doc = "RCC IC3 configuration register."]
    #[inline(always)]
    pub const fn ic3cfgr(self) -> crate::common::Reg<regs::Ic3cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xccusize) as _) }
    }
    #[doc = "RCC IC4 configuration register."]
    #[inline(always)]
    pub const fn ic4cfgr(self) -> crate::common::Reg<regs::Ic4cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd0usize) as _) }
    }
    #[doc = "RCC IC5 configuration register."]
    #[inline(always)]
    pub const fn ic5cfgr(self) -> crate::common::Reg<regs::Ic5cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd4usize) as _) }
    }
    #[doc = "RCC IC6 configuration register."]
    #[inline(always)]
    pub const fn ic6cfgr(self) -> crate::common::Reg<regs::Ic6cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd8usize) as _) }
    }
    #[doc = "RCC IC7 configuration register."]
    #[inline(always)]
    pub const fn ic7cfgr(self) -> crate::common::Reg<regs::Ic7cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xdcusize) as _) }
    }
    #[doc = "RCC IC8 configuration register."]
    #[inline(always)]
    pub const fn ic8cfgr(self) -> crate::common::Reg<regs::Ic8cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe0usize) as _) }
    }
    #[doc = "RCC IC9 configuration register."]
    #[inline(always)]
    pub const fn ic9cfgr(self) -> crate::common::Reg<regs::Ic9cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe4usize) as _) }
    }
    #[doc = "RCC IC10 configuration register."]
    #[inline(always)]
    pub const fn ic10cfgr(self) -> crate::common::Reg<regs::Ic10cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe8usize) as _) }
    }
    #[doc = "RCC IC11 configuration register."]
    #[inline(always)]
    pub const fn ic11cfgr(self) -> crate::common::Reg<regs::Ic11cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xecusize) as _) }
    }
    #[doc = "RCC IC12 configuration register."]
    #[inline(always)]
    pub const fn ic12cfgr(self) -> crate::common::Reg<regs::Ic12cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf0usize) as _) }
    }
    #[doc = "RCC IC13 configuration register."]
    #[inline(always)]
    pub const fn ic13cfgr(self) -> crate::common::Reg<regs::Ic13cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf4usize) as _) }
    }
    #[doc = "RCC IC14 configuration register."]
    #[inline(always)]
    pub const fn ic14cfgr(self) -> crate::common::Reg<regs::Ic14cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf8usize) as _) }
    }
    #[doc = "RCC IC15 configuration register."]
    #[inline(always)]
    pub const fn ic15cfgr(self) -> crate::common::Reg<regs::Ic15cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xfcusize) as _) }
    }
    #[doc = "RCC IC16 configuration register."]
    #[inline(always)]
    pub const fn ic16cfgr(self) -> crate::common::Reg<regs::Ic16cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
    }
    #[doc = "RCC IC17 configuration register."]
    #[inline(always)]
    pub const fn ic17cfgr(self) -> crate::common::Reg<regs::Ic17cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
    }
    #[doc = "RCC IC18 configuration register."]
    #[inline(always)]
    pub const fn ic18cfgr(self) -> crate::common::Reg<regs::Ic18cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
    }
    #[doc = "RCC IC19 configuration register."]
    #[inline(always)]
    pub const fn ic19cfgr(self) -> crate::common::Reg<regs::Ic19cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
    }
    #[doc = "RCC IC20 configuration register."]
    #[inline(always)]
    pub const fn ic20cfgr(self) -> crate::common::Reg<regs::Ic20cfgr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
    }
    #[doc = "RCC clock-source interrupt enable register."]
    #[inline(always)]
    pub const fn cier(self) -> crate::common::Reg<regs::Cier, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
    }
    #[doc = "RCC clock-source interrupt flag register."]
    #[inline(always)]
    pub const fn cifr(self) -> crate::common::Reg<regs::Cifr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0128usize) as _) }
    }
    #[doc = "RCC clock-source interrupt Clear register."]
    #[inline(always)]
    pub const fn cicr(self) -> crate::common::Reg<regs::Cicr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012cusize) as _) }
    }
    #[doc = "RCC clock configuration for independent peripheral register1."]
    #[inline(always)]
    pub const fn ccipr1(self) -> crate::common::Reg<regs::Ccipr1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0144usize) as _) }
    }
    #[doc = "RCC clock configuration for independent peripheral register 2."]
    #[inline(always)]
    pub const fn ccipr2(self) -> crate::common::Reg<regs::Ccipr2, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0148usize) as _) }
    }
    #[doc = "RCC clock configuration for independent peripheral register3."]
    #[inline(always)]
    pub const fn ccipr3(self) -> crate::common::Reg<regs::Ccipr3, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x014cusize) as _) }
    }
    #[doc = "RCC clock configuration for independent peripheral register4."]
    #[inline(always)]
    pub const fn ccipr4(self) -> crate::common::Reg<regs::Ccipr4, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0150usize) as _) }
    }
    #[doc = "RCC lock configuration for independent peripheral register5."]
    #[inline(always)]
    pub const fn ccipr5(self) -> crate::common::Reg<regs::Ccipr5, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0154usize) as _) }
    }
    #[doc = "RCC clock configuration for independent peripheral register6."]
    #[inline(always)]
    pub const fn ccipr6(self) -> crate::common::Reg<regs::Ccipr6, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0158usize) as _) }
    }
    #[doc = "RCC clock configuration for independent peripheral register7."]
    #[inline(always)]
    pub const fn ccipr7(self) -> crate::common::Reg<regs::Ccipr7, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x015cusize) as _) }
    }
    #[doc = "RCC clock configuration for independent peripheral register8."]
    #[inline(always)]
    pub const fn ccipr8(self) -> crate::common::Reg<regs::Ccipr8, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0160usize) as _) }
    }
    #[doc = "RCC clock configuration for independent peripheral register9."]
    #[inline(always)]
    pub const fn ccipr9(self) -> crate::common::Reg<regs::Ccipr9, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0164usize) as _) }
    }
    #[doc = "RCC clock configuration for independent peripheral register12."]
    #[inline(always)]
    pub const fn ccipr12(self) -> crate::common::Reg<regs::Ccipr12, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0170usize) as _) }
    }
    #[doc = "RCC clock configuration for independent peripheral register13."]
    #[inline(always)]
    pub const fn ccipr13(self) -> crate::common::Reg<regs::Ccipr13, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0174usize) as _) }
    }
    #[doc = "RCC clock configuration for independent peripheral register14."]
    #[inline(always)]
    pub const fn ccipr14(self) -> crate::common::Reg<regs::Ccipr14, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0178usize) as _) }
    }
    #[doc = "RCC SoC buses reset register."]
    #[inline(always)]
    pub const fn busrstr(self) -> crate::common::Reg<regs::Busrstr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0204usize) as _) }
    }
    #[doc = "RCC miscellaneous configurations reset register."]
    #[inline(always)]
    pub const fn miscrstr(self) -> crate::common::Reg<regs::Miscrstr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0208usize) as _) }
    }
    #[doc = "RCC memories reset register."]
    #[inline(always)]
    pub const fn memrstr(self) -> crate::common::Reg<regs::Memrstr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x020cusize) as _) }
    }
    #[doc = "RCC AHB1 Reset register."]
    #[inline(always)]
    pub const fn ahb1rstr(self) -> crate::common::Reg<regs::Ahb1rstr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0210usize) as _) }
    }
    #[doc = "RCC AHB2 reset register."]
    #[inline(always)]
    pub const fn ahb2rstr(self) -> crate::common::Reg<regs::Ahb2rstr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0214usize) as _) }
    }
    #[doc = "RCC AHB3 reset register."]
    #[inline(always)]
    pub const fn ahb3rstr(self) -> crate::common::Reg<regs::Ahb3rstr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0218usize) as _) }
    }
    #[doc = "RCC AHB4 reset register."]
    #[inline(always)]
    pub const fn ahb4rstr(self) -> crate::common::Reg<regs::Ahb4rstr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x021cusize) as _) }
    }
    #[doc = "RCC AHB5 reset register."]
    #[inline(always)]
    pub const fn ahb5rstr(self) -> crate::common::Reg<regs::Ahb5rstr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0220usize) as _) }
    }
    #[doc = "RCC APB1L reset register."]
    #[inline(always)]
    pub const fn apb1lrstr(self) -> crate::common::Reg<regs::Apb1lrstr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0224usize) as _) }
    }
    #[doc = "RCC APB1H reset register."]
    #[inline(always)]
    pub const fn apb1hrstr(self) -> crate::common::Reg<regs::Apb1hrstr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0228usize) as _) }
    }
    #[doc = "RCC APB2 reset register."]
    #[inline(always)]
    pub const fn apb2rstr(self) -> crate::common::Reg<regs::Apb2rstr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x022cusize) as _) }
    }
    #[doc = "RCC APB4L reset register."]
    #[inline(always)]
    pub const fn apb4lrstr(self) -> crate::common::Reg<regs::Apb4lrstr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0234usize) as _) }
    }
    #[doc = "RCC APB4H reset register."]
    #[inline(always)]
    pub const fn apb4hrstr(self) -> crate::common::Reg<regs::Apb4hrstr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0238usize) as _) }
    }
    #[doc = "RCC APB5 reset register."]
    #[inline(always)]
    pub const fn apb5rstr(self) -> crate::common::Reg<regs::Apb5rstr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x023cusize) as _) }
    }
    #[doc = "RCC IC dividers enable register."]
    #[inline(always)]
    pub const fn divenr(self) -> crate::common::Reg<regs::Divenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0240usize) as _) }
    }
    #[doc = "RCC SoC buses enable register."]
    #[inline(always)]
    pub const fn busenr(self) -> crate::common::Reg<regs::Busenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0244usize) as _) }
    }
    #[doc = "RCC miscellaneous configuration enable register."]
    #[inline(always)]
    pub const fn miscenr(self) -> crate::common::Reg<regs::Miscenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0248usize) as _) }
    }
    #[doc = "RCC memory enable register."]
    #[inline(always)]
    pub const fn memenr(self) -> crate::common::Reg<regs::Memenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x024cusize) as _) }
    }
    #[doc = "RCC AHB1 enable register."]
    #[inline(always)]
    pub const fn ahb1enr(self) -> crate::common::Reg<regs::Ahb1enr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0250usize) as _) }
    }
    #[doc = "RCC AHB2 enable register."]
    #[inline(always)]
    pub const fn ahb2enr(self) -> crate::common::Reg<regs::Ahb2enr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0254usize) as _) }
    }
    #[doc = "RCC AHB3 enable register."]
    #[inline(always)]
    pub const fn ahb3enr(self) -> crate::common::Reg<regs::Ahb3enr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0258usize) as _) }
    }
    #[doc = "RCC AHB4 enable register."]
    #[inline(always)]
    pub const fn ahb4enr(self) -> crate::common::Reg<regs::Ahb4enr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x025cusize) as _) }
    }
    #[doc = "RCC AHB5 enable register."]
    #[inline(always)]
    pub const fn ahb5enr(self) -> crate::common::Reg<regs::Ahb5enr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0260usize) as _) }
    }
    #[doc = "RCC APB1L enable register."]
    #[inline(always)]
    pub const fn apb1lenr(self) -> crate::common::Reg<regs::Apb1lenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0264usize) as _) }
    }
    #[doc = "RCC APB1H enable register."]
    #[inline(always)]
    pub const fn apb1henr(self) -> crate::common::Reg<regs::Apb1henr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0268usize) as _) }
    }
    #[doc = "RCC APB2 enable register."]
    #[inline(always)]
    pub const fn apb2enr(self) -> crate::common::Reg<regs::Apb2enr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x026cusize) as _) }
    }
    #[doc = "RCC APB3 enable register."]
    #[inline(always)]
    pub const fn apb3enr(self) -> crate::common::Reg<regs::Apb3enr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0270usize) as _) }
    }
    #[doc = "RCC APB4L enable register."]
    #[inline(always)]
    pub const fn apb4lenr(self) -> crate::common::Reg<regs::Apb4lenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0274usize) as _) }
    }
    #[doc = "RCC APB4H enable register."]
    #[inline(always)]
    pub const fn apb4henr(self) -> crate::common::Reg<regs::Apb4henr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0278usize) as _) }
    }
    #[doc = "RCC APB5 enable register."]
    #[inline(always)]
    pub const fn apb5enr(self) -> crate::common::Reg<regs::Apb5enr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x027cusize) as _) }
    }
    #[doc = "RCC dividers Sleep enable register."]
    #[inline(always)]
    pub const fn divlpenr(self) -> crate::common::Reg<regs::Divlpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0280usize) as _) }
    }
    #[doc = "RCC SoC buses Sleep enable register."]
    #[inline(always)]
    pub const fn buslpenr(self) -> crate::common::Reg<regs::Buslpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0284usize) as _) }
    }
    #[doc = "RCC miscellaneous configurations Sleep enable register."]
    #[inline(always)]
    pub const fn misclpenr(self) -> crate::common::Reg<regs::Misclpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0288usize) as _) }
    }
    #[doc = "RCC memory Sleep enable register."]
    #[inline(always)]
    pub const fn memlpenr(self) -> crate::common::Reg<regs::Memlpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x028cusize) as _) }
    }
    #[doc = "RCC AHB1 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb1lpenr(self) -> crate::common::Reg<regs::Ahb1lpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0290usize) as _) }
    }
    #[doc = "RCC AHB2 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb2lpenr(self) -> crate::common::Reg<regs::Ahb2lpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0294usize) as _) }
    }
    #[doc = "RCC AHB3 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb3lpenr(self) -> crate::common::Reg<regs::Ahb3lpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0298usize) as _) }
    }
    #[doc = "RCC AHB4 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb4lpenr(self) -> crate::common::Reg<regs::Ahb4lpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x029cusize) as _) }
    }
    #[doc = "RCC AHB5 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb5lpenr(self) -> crate::common::Reg<regs::Ahb5lpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02a0usize) as _) }
    }
    #[doc = "RCC APB1L Sleep enable register."]
    #[inline(always)]
    pub const fn apb1llpenr(self) -> crate::common::Reg<regs::Apb1llpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02a4usize) as _) }
    }
    #[doc = "RCC APB1H Sleep enable register."]
    #[inline(always)]
    pub const fn apb1hlpenr(self) -> crate::common::Reg<regs::Apb1hlpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02a8usize) as _) }
    }
    #[doc = "RCC APB2 Sleep enable register."]
    #[inline(always)]
    pub const fn apb2lpenr(self) -> crate::common::Reg<regs::Apb2lpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02acusize) as _) }
    }
    #[doc = "RCC APB3 Sleep enable register."]
    #[inline(always)]
    pub const fn apb3lpenr(self) -> crate::common::Reg<regs::Apb3lpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02b0usize) as _) }
    }
    #[doc = "RCC APB4L Sleep enable register."]
    #[inline(always)]
    pub const fn apb4llpenr(self) -> crate::common::Reg<regs::Apb4llpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02b4usize) as _) }
    }
    #[doc = "RCC APB4H Sleep enable register."]
    #[inline(always)]
    pub const fn apb4hlpenr(self) -> crate::common::Reg<regs::Apb4hlpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02b8usize) as _) }
    }
    #[doc = "RCC APB5 Sleep enable register."]
    #[inline(always)]
    pub const fn apb5lpenr(self) -> crate::common::Reg<regs::Apb5lpenr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02bcusize) as _) }
    }
    #[doc = "RCC APB5 Sleep enable register."]
    #[inline(always)]
    pub const fn rdcr(self) -> crate::common::Reg<regs::Rdcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x044cusize) as _) }
    }
    #[doc = "RCC oscillator secure configuration register0."]
    #[inline(always)]
    pub const fn seccfgr0(self) -> crate::common::Reg<regs::Seccfgr0, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0780usize) as _) }
    }
    #[doc = "RCC oscillator privilege configuration register0."]
    #[inline(always)]
    pub const fn privcfgr0(self) -> crate::common::Reg<regs::Privcfgr0, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0784usize) as _) }
    }
    #[doc = "RCC oscillator lock configuration register0."]
    #[inline(always)]
    pub const fn lockcfgr0(self) -> crate::common::Reg<regs::Lockcfgr0, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0788usize) as _) }
    }
    #[doc = "RCC oscillator public configuration register0."]
    #[inline(always)]
    pub const fn pubcfgr0(self) -> crate::common::Reg<regs::Pubcfgr0, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x078cusize) as _) }
    }
    #[doc = "RCC PLL secure configuration register1."]
    #[inline(always)]
    pub const fn seccfgr1(self) -> crate::common::Reg<regs::Seccfgr1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0790usize) as _) }
    }
    #[doc = "RCC PLL privilege configuration register1."]
    #[inline(always)]
    pub const fn privcfgr1(self) -> crate::common::Reg<regs::Privcfgr1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0794usize) as _) }
    }
    #[doc = "RCC PLL lock configuration register1."]
    #[inline(always)]
    pub const fn lockcfgr1(self) -> crate::common::Reg<regs::Lockcfgr1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0798usize) as _) }
    }
    #[doc = "RCC PLL public configuration register1."]
    #[inline(always)]
    pub const fn pubcfgr1(self) -> crate::common::Reg<regs::Pubcfgr1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x079cusize) as _) }
    }
    #[doc = "RCC divider secure configuration register2."]
    #[inline(always)]
    pub const fn seccfgr2(self) -> crate::common::Reg<regs::Seccfgr2, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07a0usize) as _) }
    }
    #[doc = "RCC divider privilege configuration register2."]
    #[inline(always)]
    pub const fn privcfgr2(self) -> crate::common::Reg<regs::Privcfgr2, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07a4usize) as _) }
    }
    #[doc = "RCC divider lock configuration register2."]
    #[inline(always)]
    pub const fn lockcfgr2(self) -> crate::common::Reg<regs::Lockcfgr2, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07a8usize) as _) }
    }
    #[doc = "RCC divider public configuration register2."]
    #[inline(always)]
    pub const fn pubcfgr2(self) -> crate::common::Reg<regs::Pubcfgr2, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07acusize) as _) }
    }
    #[doc = "RCC system secure configuration register3."]
    #[inline(always)]
    pub const fn seccfgr3(self) -> crate::common::Reg<regs::Seccfgr3, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07b0usize) as _) }
    }
    #[doc = "RCC system privilege configuration register3."]
    #[inline(always)]
    pub const fn privcfgr3(self) -> crate::common::Reg<regs::Privcfgr3, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07b4usize) as _) }
    }
    #[doc = "RCC system lock configuration register3."]
    #[inline(always)]
    pub const fn lockcfgr3(self) -> crate::common::Reg<regs::Lockcfgr3, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07b8usize) as _) }
    }
    #[doc = "RCC system public configuration register3."]
    #[inline(always)]
    pub const fn pubcfgr3(self) -> crate::common::Reg<regs::Pubcfgr3, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07bcusize) as _) }
    }
    #[doc = "RCC bus secure configuration register4."]
    #[inline(always)]
    pub const fn seccfgr4(self) -> crate::common::Reg<regs::Seccfgr4, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07c0usize) as _) }
    }
    #[doc = "RCC bus privilege configuration register4."]
    #[inline(always)]
    pub const fn privcfgr4(self) -> crate::common::Reg<regs::Privcfgr4, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07c4usize) as _) }
    }
    #[doc = "RCC bus lock configuration register4."]
    #[inline(always)]
    pub const fn lockcfgr4(self) -> crate::common::Reg<regs::Lockcfgr4, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07c8usize) as _) }
    }
    #[doc = "RCC bus public configuration register4."]
    #[inline(always)]
    pub const fn pubcfgr4(self) -> crate::common::Reg<regs::Pubcfgr4, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07ccusize) as _) }
    }
    #[doc = "RCC bus public configuration register4."]
    #[inline(always)]
    pub const fn pubcfgr5(self) -> crate::common::Reg<regs::Pubcfgr5, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07d0usize) as _) }
    }
    #[doc = "RCC control set register."]
    #[inline(always)]
    pub const fn csr(self) -> crate::common::Reg<regs::Csr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0800usize) as _) }
    }
    #[doc = "RCC Stop configuration register."]
    #[inline(always)]
    pub const fn stopcsr(self) -> crate::common::Reg<regs::Stopcsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0808usize) as _) }
    }
    #[doc = "RCC bus reset set register."]
    #[inline(always)]
    pub const fn busrstsr(self) -> crate::common::Reg<regs::Busrstsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a04usize) as _) }
    }
    #[doc = "RCC miscellaneous reset register."]
    #[inline(always)]
    pub const fn miscrstsr(self) -> crate::common::Reg<regs::Miscrstsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a08usize) as _) }
    }
    #[doc = "RCC memory reset register."]
    #[inline(always)]
    pub const fn memrstsr(self) -> crate::common::Reg<regs::Memrstsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a0cusize) as _) }
    }
    #[doc = "RCC AHB1 reset register."]
    #[inline(always)]
    pub const fn ahb1rstsr(self) -> crate::common::Reg<regs::Ahb1rstsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a10usize) as _) }
    }
    #[doc = "RCC AHB2 reset register."]
    #[inline(always)]
    pub const fn ahb2rstsr(self) -> crate::common::Reg<regs::Ahb2rstsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a14usize) as _) }
    }
    #[doc = "RCC AHB3 reset register."]
    #[inline(always)]
    pub const fn ahb3rstsr(self) -> crate::common::Reg<regs::Ahb3rstsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a18usize) as _) }
    }
    #[doc = "RCC AHB4 reset register."]
    #[inline(always)]
    pub const fn ahb4rstsr(self) -> crate::common::Reg<regs::Ahb4rstsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a1cusize) as _) }
    }
    #[doc = "RCC AHB5 reset register."]
    #[inline(always)]
    pub const fn ahb5rstsr(self) -> crate::common::Reg<regs::Ahb5rstsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a20usize) as _) }
    }
    #[doc = "RCC APB1L reset register."]
    #[inline(always)]
    pub const fn apb1lrstsr(self) -> crate::common::Reg<regs::Apb1lrstsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a24usize) as _) }
    }
    #[doc = "RCC APB1H reset register."]
    #[inline(always)]
    pub const fn apb1hrstsr(self) -> crate::common::Reg<regs::Apb1hrstsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a28usize) as _) }
    }
    #[doc = "RCC APB2 reset register."]
    #[inline(always)]
    pub const fn apb2rstsr(self) -> crate::common::Reg<regs::Apb2rstsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a2cusize) as _) }
    }
    #[doc = "RCC APB4L reset register."]
    #[inline(always)]
    pub const fn apb4lrstsr(self) -> crate::common::Reg<regs::Apb4lrstsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a34usize) as _) }
    }
    #[doc = "RCC APB4H reset register."]
    #[inline(always)]
    pub const fn apb4hrstsr(self) -> crate::common::Reg<regs::Apb4hrstsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a38usize) as _) }
    }
    #[doc = "RCC APB5 reset register."]
    #[inline(always)]
    pub const fn apb5rstsr(self) -> crate::common::Reg<regs::Apb5rstsr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a3cusize) as _) }
    }
    #[doc = "RCC Divider enable register."]
    #[inline(always)]
    pub const fn divensr(self) -> crate::common::Reg<regs::Divensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a40usize) as _) }
    }
    #[doc = "RCC bus enable register."]
    #[inline(always)]
    pub const fn busensr(self) -> crate::common::Reg<regs::Busensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a44usize) as _) }
    }
    #[doc = "RCC miscellaneous enable register."]
    #[inline(always)]
    pub const fn miscensr(self) -> crate::common::Reg<regs::Miscensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a48usize) as _) }
    }
    #[doc = "RCC memory enable register."]
    #[inline(always)]
    pub const fn memensr(self) -> crate::common::Reg<regs::Memensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a4cusize) as _) }
    }
    #[doc = "RCC AHB1 enable register."]
    #[inline(always)]
    pub const fn ahb1ensr(self) -> crate::common::Reg<regs::Ahb1ensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a50usize) as _) }
    }
    #[doc = "RCC AHB2 enable register."]
    #[inline(always)]
    pub const fn ahb2ensr(self) -> crate::common::Reg<regs::Ahb2ensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a54usize) as _) }
    }
    #[doc = "RCC AHB3 enable register."]
    #[inline(always)]
    pub const fn ahb3ensr(self) -> crate::common::Reg<regs::Ahb3ensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a58usize) as _) }
    }
    #[doc = "RCC AHB4 enable register."]
    #[inline(always)]
    pub const fn ahb4ensr(self) -> crate::common::Reg<regs::Ahb4ensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a5cusize) as _) }
    }
    #[doc = "RCC AHB5 enable register."]
    #[inline(always)]
    pub const fn ahb5ensr(self) -> crate::common::Reg<regs::Ahb5ensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a60usize) as _) }
    }
    #[doc = "RCC APB1L enable register."]
    #[inline(always)]
    pub const fn apb1lensr(self) -> crate::common::Reg<regs::Apb1lensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a64usize) as _) }
    }
    #[doc = "RCC APB1H enable register."]
    #[inline(always)]
    pub const fn apb1hensr(self) -> crate::common::Reg<regs::Apb1hensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a68usize) as _) }
    }
    #[doc = "RCC APB2 enable register."]
    #[inline(always)]
    pub const fn apb2ensr(self) -> crate::common::Reg<regs::Apb2ensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a6cusize) as _) }
    }
    #[doc = "RCC APB3 enable register."]
    #[inline(always)]
    pub const fn apb3ensr(self) -> crate::common::Reg<regs::Apb3ensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a70usize) as _) }
    }
    #[doc = "RCC APB4L enable register."]
    #[inline(always)]
    pub const fn apb4lensr(self) -> crate::common::Reg<regs::Apb4lensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a74usize) as _) }
    }
    #[doc = "RCC APB4H enable register."]
    #[inline(always)]
    pub const fn apb4hensr(self) -> crate::common::Reg<regs::Apb4hensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a78usize) as _) }
    }
    #[doc = "RCC APB5 enable register."]
    #[inline(always)]
    pub const fn apb5ensr(self) -> crate::common::Reg<regs::Apb5ensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a7cusize) as _) }
    }
    #[doc = "RCC divider Sleep enable register."]
    #[inline(always)]
    pub const fn divlpensr(self) -> crate::common::Reg<regs::Divlpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a80usize) as _) }
    }
    #[doc = "RCC bus Sleep enable register."]
    #[inline(always)]
    pub const fn buslpensr(self) -> crate::common::Reg<regs::Buslpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a84usize) as _) }
    }
    #[doc = "RCC miscellaneous Sleep enable register."]
    #[inline(always)]
    pub const fn misclpensr(self) -> crate::common::Reg<regs::Misclpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a88usize) as _) }
    }
    #[doc = "RCC memory sleep enable register."]
    #[inline(always)]
    pub const fn memlpensr(self) -> crate::common::Reg<regs::Memlpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a8cusize) as _) }
    }
    #[doc = "RCC AHB1 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb1lpensr(self) -> crate::common::Reg<regs::Ahb1lpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a90usize) as _) }
    }
    #[doc = "RCC AHB2 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb2lpensr(self) -> crate::common::Reg<regs::Ahb2lpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a94usize) as _) }
    }
    #[doc = "RCC AHB3 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb3lpensr(self) -> crate::common::Reg<regs::Ahb3lpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a98usize) as _) }
    }
    #[doc = "RCC AHB4 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb4lpensr(self) -> crate::common::Reg<regs::Ahb4lpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0a9cusize) as _) }
    }
    #[doc = "RCC AHB5 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb5lpensr(self) -> crate::common::Reg<regs::Ahb5lpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0aa0usize) as _) }
    }
    #[doc = "RCC APB1L Sleep enable register."]
    #[inline(always)]
    pub const fn apb1llpensr(self) -> crate::common::Reg<regs::Apb1llpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0aa4usize) as _) }
    }
    #[doc = "RCC APB1H Sleep enable register."]
    #[inline(always)]
    pub const fn apb1hlpensr(self) -> crate::common::Reg<regs::Apb1hlpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0aa8usize) as _) }
    }
    #[doc = "RCC APB2 Sleep enable register."]
    #[inline(always)]
    pub const fn apb2lpensr(self) -> crate::common::Reg<regs::Apb2lpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0aacusize) as _) }
    }
    #[doc = "RCC APB3 Sleep enable register."]
    #[inline(always)]
    pub const fn apb3lpensr(self) -> crate::common::Reg<regs::Apb3lpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ab0usize) as _) }
    }
    #[doc = "RCC APB4L Sleep enable register."]
    #[inline(always)]
    pub const fn apb4llpensr(self) -> crate::common::Reg<regs::Apb4llpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ab4usize) as _) }
    }
    #[doc = "RCC APB4H Sleep enable register."]
    #[inline(always)]
    pub const fn apb4hlpensr(self) -> crate::common::Reg<regs::Apb4hlpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ab8usize) as _) }
    }
    #[doc = "RCC APB5 Sleep enable register."]
    #[inline(always)]
    pub const fn apb5lpensr(self) -> crate::common::Reg<regs::Apb5lpensr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0abcusize) as _) }
    }
    #[doc = "RCC oscillator privilege configuration register0."]
    #[inline(always)]
    pub const fn privcfgsr0(self) -> crate::common::Reg<regs::Privcfgsr0, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0f84usize) as _) }
    }
    #[doc = "RCC oscillator public configuration register0."]
    #[inline(always)]
    pub const fn pubcfgsr0(self) -> crate::common::Reg<regs::Pubcfgsr0, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0f8cusize) as _) }
    }
    #[doc = "RCC PLL privilege configuration register1."]
    #[inline(always)]
    pub const fn privcfgsr1(self) -> crate::common::Reg<regs::Privcfgsr1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0f94usize) as _) }
    }
    #[doc = "RCC PLL public configuration register1."]
    #[inline(always)]
    pub const fn pubcfgsr1(self) -> crate::common::Reg<regs::Pubcfgsr1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0f9cusize) as _) }
    }
    #[doc = "RCC divider privilege configuration register2."]
    #[inline(always)]
    pub const fn privcfgsr2(self) -> crate::common::Reg<regs::Privcfgsr2, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fa4usize) as _) }
    }
    #[doc = "RCC divider public configuration register2."]
    #[inline(always)]
    pub const fn pubcfgsr2(self) -> crate::common::Reg<regs::Pubcfgsr2, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0facusize) as _) }
    }
    #[doc = "RCC system secure configuration register3."]
    #[inline(always)]
    pub const fn seccfgsr3(self) -> crate::common::Reg<regs::Seccfgsr3, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fb0usize) as _) }
    }
    #[doc = "RCC system privilege configuration register3."]
    #[inline(always)]
    pub const fn privcfgsr3(self) -> crate::common::Reg<regs::Privcfgsr3, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fb4usize) as _) }
    }
    #[doc = "RCC system lock configuration register3."]
    #[inline(always)]
    pub const fn lockcfgsr3(self) -> crate::common::Reg<regs::Lockcfgsr3, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fb8usize) as _) }
    }
    #[doc = "RCC system public configuration register3."]
    #[inline(always)]
    pub const fn pubcfgsr3(self) -> crate::common::Reg<regs::Pubcfgsr3, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fbcusize) as _) }
    }
    #[doc = "RCC privilege configuration register4."]
    #[inline(always)]
    pub const fn privcfgsr4(self) -> crate::common::Reg<regs::Privcfgsr4, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fc4usize) as _) }
    }
    #[doc = "RCC public configuration register4."]
    #[inline(always)]
    pub const fn pubcfgsr4(self) -> crate::common::Reg<regs::Pubcfgsr4, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fccusize) as _) }
    }
    #[doc = "RCC public configuration register4."]
    #[inline(always)]
    pub const fn pubcfgsr5(self) -> crate::common::Reg<regs::Pubcfgsr5, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fd0usize) as _) }
    }
    #[doc = "RCC control Clear register."]
    #[inline(always)]
    pub const fn ccr(self) -> crate::common::Reg<regs::Ccr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1000usize) as _) }
    }
    #[doc = "RCC StopCCR configuration register."]
    #[inline(always)]
    pub const fn stopccr(self) -> crate::common::Reg<regs::Stopccr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1008usize) as _) }
    }
    #[doc = "RCC bus reset register."]
    #[inline(always)]
    pub const fn busrstcr(self) -> crate::common::Reg<regs::Busrstcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1204usize) as _) }
    }
    #[doc = "RCC miscellaneous reset register."]
    #[inline(always)]
    pub const fn miscrstcr(self) -> crate::common::Reg<regs::Miscrstcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1208usize) as _) }
    }
    #[doc = "RCC memory reset register."]
    #[inline(always)]
    pub const fn memrstcr(self) -> crate::common::Reg<regs::Memrstcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x120cusize) as _) }
    }
    #[doc = "RCC AHB1 reset register."]
    #[inline(always)]
    pub const fn ahb1rstcr(self) -> crate::common::Reg<regs::Ahb1rstcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1210usize) as _) }
    }
    #[doc = "RCC AHB2 Reset register."]
    #[inline(always)]
    pub const fn ahb2rstcr(self) -> crate::common::Reg<regs::Ahb2rstcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1214usize) as _) }
    }
    #[doc = "RCC AHB3 reset register."]
    #[inline(always)]
    pub const fn ahb3rstcr(self) -> crate::common::Reg<regs::Ahb3rstcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1218usize) as _) }
    }
    #[doc = "RCC AHB4 reset register."]
    #[inline(always)]
    pub const fn ahb4rstcr(self) -> crate::common::Reg<regs::Ahb4rstcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x121cusize) as _) }
    }
    #[doc = "RCC AHB5 reset register."]
    #[inline(always)]
    pub const fn ahb5rstcr(self) -> crate::common::Reg<regs::Ahb5rstcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1220usize) as _) }
    }
    #[doc = "RCC APB1L reset register."]
    #[inline(always)]
    pub const fn apb1lrstcr(self) -> crate::common::Reg<regs::Apb1lrstcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1224usize) as _) }
    }
    #[doc = "RCC APB1H reset register."]
    #[inline(always)]
    pub const fn apb1hrstcr(self) -> crate::common::Reg<regs::Apb1hrstcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1228usize) as _) }
    }
    #[doc = "RCC APB2 reset register."]
    #[inline(always)]
    pub const fn apb2rstcr(self) -> crate::common::Reg<regs::Apb2rstcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x122cusize) as _) }
    }
    #[doc = "RCC APB4L reset register."]
    #[inline(always)]
    pub const fn apb4lrstcr(self) -> crate::common::Reg<regs::Apb4lrstcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1234usize) as _) }
    }
    #[doc = "RCC APB4H reset register."]
    #[inline(always)]
    pub const fn apb4hrstcr(self) -> crate::common::Reg<regs::Apb4hrstcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1238usize) as _) }
    }
    #[doc = "RCC APB5 reset register."]
    #[inline(always)]
    pub const fn apb5rstcr(self) -> crate::common::Reg<regs::Apb5rstcr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x123cusize) as _) }
    }
    #[doc = "RCC divider enable register."]
    #[inline(always)]
    pub const fn divencr(self) -> crate::common::Reg<regs::Divencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1240usize) as _) }
    }
    #[doc = "RCC bus enable register."]
    #[inline(always)]
    pub const fn busencr(self) -> crate::common::Reg<regs::Busencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1244usize) as _) }
    }
    #[doc = "RCC miscellaneous enable register."]
    #[inline(always)]
    pub const fn miscencr(self) -> crate::common::Reg<regs::Miscencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1248usize) as _) }
    }
    #[doc = "RCC memory enable register."]
    #[inline(always)]
    pub const fn memencr(self) -> crate::common::Reg<regs::Memencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x124cusize) as _) }
    }
    #[doc = "RCC AHB1 enable register."]
    #[inline(always)]
    pub const fn ahb1encr(self) -> crate::common::Reg<regs::Ahb1encr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1250usize) as _) }
    }
    #[doc = "RCC AHB2 enable register."]
    #[inline(always)]
    pub const fn ahb2encr(self) -> crate::common::Reg<regs::Ahb2encr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1254usize) as _) }
    }
    #[doc = "RCC AHB3 enable register."]
    #[inline(always)]
    pub const fn ahb3encr(self) -> crate::common::Reg<regs::Ahb3encr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1258usize) as _) }
    }
    #[doc = "RCC AHB4 enable register."]
    #[inline(always)]
    pub const fn ahb4encr(self) -> crate::common::Reg<regs::Ahb4encr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x125cusize) as _) }
    }
    #[doc = "RCC AHB5 enable register."]
    #[inline(always)]
    pub const fn ahb5encr(self) -> crate::common::Reg<regs::Ahb5encr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1260usize) as _) }
    }
    #[doc = "RCC APB1L enable register."]
    #[inline(always)]
    pub const fn apb1lencr(self) -> crate::common::Reg<regs::Apb1lencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1264usize) as _) }
    }
    #[doc = "RCC APB1H enable register."]
    #[inline(always)]
    pub const fn apb1hencr(self) -> crate::common::Reg<regs::Apb1hencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1268usize) as _) }
    }
    #[doc = "RCC APB2 enable register."]
    #[inline(always)]
    pub const fn apb2encr(self) -> crate::common::Reg<regs::Apb2encr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x126cusize) as _) }
    }
    #[doc = "RCC APB3 enable register."]
    #[inline(always)]
    pub const fn apb3encr(self) -> crate::common::Reg<regs::Apb3encr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1270usize) as _) }
    }
    #[doc = "RCC APB4L enable register."]
    #[inline(always)]
    pub const fn apb4lencr(self) -> crate::common::Reg<regs::Apb4lencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1274usize) as _) }
    }
    #[doc = "RCC APB4H enable register."]
    #[inline(always)]
    pub const fn apb4hencr(self) -> crate::common::Reg<regs::Apb4hencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1278usize) as _) }
    }
    #[doc = "RCC APB5 enable register."]
    #[inline(always)]
    pub const fn apb5encr(self) -> crate::common::Reg<regs::Apb5encr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x127cusize) as _) }
    }
    #[doc = "RCC divider Sleep enable register."]
    #[inline(always)]
    pub const fn divlpencr(self) -> crate::common::Reg<regs::Divlpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1280usize) as _) }
    }
    #[doc = "RCC bus Sleep enable register."]
    #[inline(always)]
    pub const fn buslpencr(self) -> crate::common::Reg<regs::Buslpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1284usize) as _) }
    }
    #[doc = "RCC miscellaneous Sleep enable register."]
    #[inline(always)]
    pub const fn misclpencr(self) -> crate::common::Reg<regs::Misclpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1288usize) as _) }
    }
    #[doc = "RCC memory Sleep enable register."]
    #[inline(always)]
    pub const fn memlpencr(self) -> crate::common::Reg<regs::Memlpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x128cusize) as _) }
    }
    #[doc = "RCC AHB1 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb1lpencr(self) -> crate::common::Reg<regs::Ahb1lpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1290usize) as _) }
    }
    #[doc = "RCC AHB2 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb2lpencr(self) -> crate::common::Reg<regs::Ahb2lpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1294usize) as _) }
    }
    #[doc = "RCC AHB3 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb3lpencr(self) -> crate::common::Reg<regs::Ahb3lpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1298usize) as _) }
    }
    #[doc = "RCC AHB4 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb4lpencr(self) -> crate::common::Reg<regs::Ahb4lpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x129cusize) as _) }
    }
    #[doc = "RCC AHB5 Sleep enable register."]
    #[inline(always)]
    pub const fn ahb5lpencr(self) -> crate::common::Reg<regs::Ahb5lpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12a0usize) as _) }
    }
    #[doc = "RCC APB1L Sleep enable register."]
    #[inline(always)]
    pub const fn apb1llpencr(self) -> crate::common::Reg<regs::Apb1llpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12a4usize) as _) }
    }
    #[doc = "RCC APB1H Sleep enable register."]
    #[inline(always)]
    pub const fn apb1hlpencr(self) -> crate::common::Reg<regs::Apb1hlpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12a8usize) as _) }
    }
    #[doc = "RCC APB2 Sleep enable register."]
    #[inline(always)]
    pub const fn apb2lpencr(self) -> crate::common::Reg<regs::Apb2lpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12acusize) as _) }
    }
    #[doc = "RCC APB3 Sleep enable register."]
    #[inline(always)]
    pub const fn apb3lpencr(self) -> crate::common::Reg<regs::Apb3lpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12b0usize) as _) }
    }
    #[doc = "RCC APB4L Sleep enable register."]
    #[inline(always)]
    pub const fn apb4llpencr(self) -> crate::common::Reg<regs::Apb4llpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12b4usize) as _) }
    }
    #[doc = "RCC APB4H Sleep enable register."]
    #[inline(always)]
    pub const fn apb4hlpencr(self) -> crate::common::Reg<regs::Apb4hlpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12b8usize) as _) }
    }
    #[doc = "RCC APB5 Sleep enable register."]
    #[inline(always)]
    pub const fn apb5lpencr(self) -> crate::common::Reg<regs::Apb5lpencr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12bcusize) as _) }
    }
    #[doc = "RCC oscillator privilege configuration register0."]
    #[inline(always)]
    pub const fn privcfgcr0(self) -> crate::common::Reg<regs::Privcfgcr0, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1784usize) as _) }
    }
    #[doc = "RCC oscillator public configuration register0."]
    #[inline(always)]
    pub const fn pubcfgcr0(self) -> crate::common::Reg<regs::Pubcfgcr0, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x178cusize) as _) }
    }
    #[doc = "RCC PLL privilege configuration register1."]
    #[inline(always)]
    pub const fn privcfgcr1(self) -> crate::common::Reg<regs::Privcfgcr1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1794usize) as _) }
    }
    #[doc = "RCC PLL public configuration register1."]
    #[inline(always)]
    pub const fn pubcfgcr1(self) -> crate::common::Reg<regs::Pubcfgcr1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x179cusize) as _) }
    }
    #[doc = "RCC divider privilege configuration register2."]
    #[inline(always)]
    pub const fn privcfgcr2(self) -> crate::common::Reg<regs::Privcfgcr2, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x17a4usize) as _) }
    }
    #[doc = "RCC divider public configuration register2."]
    #[inline(always)]
    pub const fn pubcfgcr2(self) -> crate::common::Reg<regs::Pubcfgcr2, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x17acusize) as _) }
    }
    #[doc = "RCC system privilege configuration register3."]
    #[inline(always)]
    pub const fn privcfgcr3(self) -> crate::common::Reg<regs::Privcfgcr3, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x17b4usize) as _) }
    }
    #[doc = "RCC system public configuration register3."]
    #[inline(always)]
    pub const fn pubcfgcr3(self) -> crate::common::Reg<regs::Pubcfgcr3, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x17bcusize) as _) }
    }
    #[doc = "RCC privilege configuration register4."]
    #[inline(always)]
    pub const fn privcfgcr4(self) -> crate::common::Reg<regs::Privcfgcr4, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x17c4usize) as _) }
    }
    #[doc = "RCC public configuration register4."]
    #[inline(always)]
    pub const fn pubcfgcr4(self) -> crate::common::Reg<regs::Pubcfgcr4, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x17ccusize) as _) }
    }
    #[doc = "RCC public configuration register4."]
    #[inline(always)]
    pub const fn pubcfgcr5(self) -> crate::common::Reg<regs::Pubcfgcr5, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x17d0usize) as _) }
    }
}
pub mod regs {
    #[doc = "RCC AHB1 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb1encr(pub u32);
    impl Ahb1encr {
        #[doc = "GPDMA1 enable."]
        #[inline(always)]
        pub const fn gpdma1enc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPDMA1 enable."]
        #[inline(always)]
        pub fn set_gpdma1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "ADC12 enable."]
        #[inline(always)]
        pub const fn adc12enc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "ADC12 enable."]
        #[inline(always)]
        pub fn set_adc12enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
    }
    impl Default for Ahb1encr {
        #[inline(always)]
        fn default() -> Ahb1encr {
            Ahb1encr(0)
        }
    }
    impl core::fmt::Debug for Ahb1encr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb1encr")
                .field("gpdma1enc", &self.gpdma1enc())
                .field("adc12enc", &self.adc12enc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb1encr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb1encr {{ gpdma1enc: {=bool:?}, adc12enc: {=bool:?} }}",
                self.gpdma1enc(),
                self.adc12enc()
            )
        }
    }
    #[doc = "RCC AHB1 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb1enr(pub u32);
    impl Ahb1enr {
        #[doc = "GPDMA1 enable."]
        #[inline(always)]
        pub const fn gpdma1en(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPDMA1 enable."]
        #[inline(always)]
        pub fn set_gpdma1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "ADC12 enable."]
        #[inline(always)]
        pub const fn adc12en(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "ADC12 enable."]
        #[inline(always)]
        pub fn set_adc12en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
    }
    impl Default for Ahb1enr {
        #[inline(always)]
        fn default() -> Ahb1enr {
            Ahb1enr(0)
        }
    }
    impl core::fmt::Debug for Ahb1enr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb1enr")
                .field("gpdma1en", &self.gpdma1en())
                .field("adc12en", &self.adc12en())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb1enr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb1enr {{ gpdma1en: {=bool:?}, adc12en: {=bool:?} }}",
                self.gpdma1en(),
                self.adc12en()
            )
        }
    }
    #[doc = "RCC AHB1 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb1ensr(pub u32);
    impl Ahb1ensr {
        #[doc = "GPDMA1 enable."]
        #[inline(always)]
        pub const fn gpdma1ens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPDMA1 enable."]
        #[inline(always)]
        pub fn set_gpdma1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "ADC12 enable."]
        #[inline(always)]
        pub const fn adc12ens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "ADC12 enable."]
        #[inline(always)]
        pub fn set_adc12ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
    }
    impl Default for Ahb1ensr {
        #[inline(always)]
        fn default() -> Ahb1ensr {
            Ahb1ensr(0)
        }
    }
    impl core::fmt::Debug for Ahb1ensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb1ensr")
                .field("gpdma1ens", &self.gpdma1ens())
                .field("adc12ens", &self.adc12ens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb1ensr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb1ensr {{ gpdma1ens: {=bool:?}, adc12ens: {=bool:?} }}",
                self.gpdma1ens(),
                self.adc12ens()
            )
        }
    }
    #[doc = "RCC AHB1 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb1lpencr(pub u32);
    impl Ahb1lpencr {
        #[doc = "GPDMA1 sleep enable."]
        #[inline(always)]
        pub const fn gpdma1lpenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPDMA1 sleep enable."]
        #[inline(always)]
        pub fn set_gpdma1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "ADC12 sleep enable."]
        #[inline(always)]
        pub const fn adc12lpenc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "ADC12 sleep enable."]
        #[inline(always)]
        pub fn set_adc12lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
    }
    impl Default for Ahb1lpencr {
        #[inline(always)]
        fn default() -> Ahb1lpencr {
            Ahb1lpencr(0)
        }
    }
    impl core::fmt::Debug for Ahb1lpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb1lpencr")
                .field("gpdma1lpenc", &self.gpdma1lpenc())
                .field("adc12lpenc", &self.adc12lpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb1lpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb1lpencr {{ gpdma1lpenc: {=bool:?}, adc12lpenc: {=bool:?} }}",
                self.gpdma1lpenc(),
                self.adc12lpenc()
            )
        }
    }
    #[doc = "RCC AHB1 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb1lpenr(pub u32);
    impl Ahb1lpenr {
        #[doc = "GPDMA1 sleep enable."]
        #[inline(always)]
        pub const fn gpdma1lpen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPDMA1 sleep enable."]
        #[inline(always)]
        pub fn set_gpdma1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "ADC12 sleep enable."]
        #[inline(always)]
        pub const fn adc12lpen(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "ADC12 sleep enable."]
        #[inline(always)]
        pub fn set_adc12lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
    }
    impl Default for Ahb1lpenr {
        #[inline(always)]
        fn default() -> Ahb1lpenr {
            Ahb1lpenr(0)
        }
    }
    impl core::fmt::Debug for Ahb1lpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb1lpenr")
                .field("gpdma1lpen", &self.gpdma1lpen())
                .field("adc12lpen", &self.adc12lpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb1lpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb1lpenr {{ gpdma1lpen: {=bool:?}, adc12lpen: {=bool:?} }}",
                self.gpdma1lpen(),
                self.adc12lpen()
            )
        }
    }
    #[doc = "RCC AHB1 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb1lpensr(pub u32);
    impl Ahb1lpensr {
        #[doc = "GPDMA1 sleep enable."]
        #[inline(always)]
        pub const fn gpdma1lpens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPDMA1 sleep enable."]
        #[inline(always)]
        pub fn set_gpdma1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "ADC12 sleep enable."]
        #[inline(always)]
        pub const fn adc12lpens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "ADC12 sleep enable."]
        #[inline(always)]
        pub fn set_adc12lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
    }
    impl Default for Ahb1lpensr {
        #[inline(always)]
        fn default() -> Ahb1lpensr {
            Ahb1lpensr(0)
        }
    }
    impl core::fmt::Debug for Ahb1lpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb1lpensr")
                .field("gpdma1lpens", &self.gpdma1lpens())
                .field("adc12lpens", &self.adc12lpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb1lpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb1lpensr {{ gpdma1lpens: {=bool:?}, adc12lpens: {=bool:?} }}",
                self.gpdma1lpens(),
                self.adc12lpens()
            )
        }
    }
    #[doc = "RCC AHB1 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb1rstcr(pub u32);
    impl Ahb1rstcr {
        #[doc = "GPDMA1 reset."]
        #[inline(always)]
        pub const fn gpdma1rstc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPDMA1 reset."]
        #[inline(always)]
        pub fn set_gpdma1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "ADC12 reset."]
        #[inline(always)]
        pub const fn adc12rstc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "ADC12 reset."]
        #[inline(always)]
        pub fn set_adc12rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
    }
    impl Default for Ahb1rstcr {
        #[inline(always)]
        fn default() -> Ahb1rstcr {
            Ahb1rstcr(0)
        }
    }
    impl core::fmt::Debug for Ahb1rstcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb1rstcr")
                .field("gpdma1rstc", &self.gpdma1rstc())
                .field("adc12rstc", &self.adc12rstc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb1rstcr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb1rstcr {{ gpdma1rstc: {=bool:?}, adc12rstc: {=bool:?} }}",
                self.gpdma1rstc(),
                self.adc12rstc()
            )
        }
    }
    #[doc = "RCC AHB1 Reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb1rstr(pub u32);
    impl Ahb1rstr {
        #[doc = "GPDMA1 reset."]
        #[inline(always)]
        pub const fn gpdma1rst(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPDMA1 reset."]
        #[inline(always)]
        pub fn set_gpdma1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "ADC12 reset."]
        #[inline(always)]
        pub const fn adc12rst(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "ADC12 reset."]
        #[inline(always)]
        pub fn set_adc12rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
    }
    impl Default for Ahb1rstr {
        #[inline(always)]
        fn default() -> Ahb1rstr {
            Ahb1rstr(0)
        }
    }
    impl core::fmt::Debug for Ahb1rstr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb1rstr")
                .field("gpdma1rst", &self.gpdma1rst())
                .field("adc12rst", &self.adc12rst())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb1rstr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb1rstr {{ gpdma1rst: {=bool:?}, adc12rst: {=bool:?} }}",
                self.gpdma1rst(),
                self.adc12rst()
            )
        }
    }
    #[doc = "RCC AHB1 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb1rstsr(pub u32);
    impl Ahb1rstsr {
        #[doc = "GPDMA1 reset."]
        #[inline(always)]
        pub const fn gpdma1rsts(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPDMA1 reset."]
        #[inline(always)]
        pub fn set_gpdma1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "ADC12 reset."]
        #[inline(always)]
        pub const fn adc12rsts(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "ADC12 reset."]
        #[inline(always)]
        pub fn set_adc12rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
    }
    impl Default for Ahb1rstsr {
        #[inline(always)]
        fn default() -> Ahb1rstsr {
            Ahb1rstsr(0)
        }
    }
    impl core::fmt::Debug for Ahb1rstsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb1rstsr")
                .field("gpdma1rsts", &self.gpdma1rsts())
                .field("adc12rsts", &self.adc12rsts())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb1rstsr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb1rstsr {{ gpdma1rsts: {=bool:?}, adc12rsts: {=bool:?} }}",
                self.gpdma1rsts(),
                self.adc12rsts()
            )
        }
    }
    #[doc = "RCC AHB2 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb2encr(pub u32);
    impl Ahb2encr {
        #[doc = "RAMCFG enable."]
        #[inline(always)]
        pub const fn ramcfgenc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "RAMCFG enable."]
        #[inline(always)]
        pub fn set_ramcfgenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "MDF1 enable."]
        #[inline(always)]
        pub const fn mdf1enc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MDF1 enable."]
        #[inline(always)]
        pub fn set_mdf1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "ADF1 enable."]
        #[inline(always)]
        pub const fn adf1enc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "ADF1 enable."]
        #[inline(always)]
        pub fn set_adf1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for Ahb2encr {
        #[inline(always)]
        fn default() -> Ahb2encr {
            Ahb2encr(0)
        }
    }
    impl core::fmt::Debug for Ahb2encr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb2encr")
                .field("ramcfgenc", &self.ramcfgenc())
                .field("mdf1enc", &self.mdf1enc())
                .field("adf1enc", &self.adf1enc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb2encr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb2encr {{ ramcfgenc: {=bool:?}, mdf1enc: {=bool:?}, adf1enc: {=bool:?} }}",
                self.ramcfgenc(),
                self.mdf1enc(),
                self.adf1enc()
            )
        }
    }
    #[doc = "RCC AHB2 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb2enr(pub u32);
    impl Ahb2enr {
        #[doc = "RAMCFG enable."]
        #[inline(always)]
        pub const fn ramcfgen(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "RAMCFG enable."]
        #[inline(always)]
        pub fn set_ramcfgen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "MDF1 enable."]
        #[inline(always)]
        pub const fn mdf1en(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MDF1 enable."]
        #[inline(always)]
        pub fn set_mdf1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "ADF enable."]
        #[inline(always)]
        pub const fn adf1en(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "ADF enable."]
        #[inline(always)]
        pub fn set_adf1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for Ahb2enr {
        #[inline(always)]
        fn default() -> Ahb2enr {
            Ahb2enr(0)
        }
    }
    impl core::fmt::Debug for Ahb2enr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb2enr")
                .field("ramcfgen", &self.ramcfgen())
                .field("mdf1en", &self.mdf1en())
                .field("adf1en", &self.adf1en())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb2enr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb2enr {{ ramcfgen: {=bool:?}, mdf1en: {=bool:?}, adf1en: {=bool:?} }}",
                self.ramcfgen(),
                self.mdf1en(),
                self.adf1en()
            )
        }
    }
    #[doc = "RCC AHB2 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb2ensr(pub u32);
    impl Ahb2ensr {
        #[doc = "RAMCFG enable."]
        #[inline(always)]
        pub const fn ramcfgens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "RAMCFG enable."]
        #[inline(always)]
        pub fn set_ramcfgens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "MDF1 enable."]
        #[inline(always)]
        pub const fn mdf1ens(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MDF1 enable."]
        #[inline(always)]
        pub fn set_mdf1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "ADF1 enable."]
        #[inline(always)]
        pub const fn adf1ens(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "ADF1 enable."]
        #[inline(always)]
        pub fn set_adf1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for Ahb2ensr {
        #[inline(always)]
        fn default() -> Ahb2ensr {
            Ahb2ensr(0)
        }
    }
    impl core::fmt::Debug for Ahb2ensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb2ensr")
                .field("ramcfgens", &self.ramcfgens())
                .field("mdf1ens", &self.mdf1ens())
                .field("adf1ens", &self.adf1ens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb2ensr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb2ensr {{ ramcfgens: {=bool:?}, mdf1ens: {=bool:?}, adf1ens: {=bool:?} }}",
                self.ramcfgens(),
                self.mdf1ens(),
                self.adf1ens()
            )
        }
    }
    #[doc = "RCC AHB2 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb2lpencr(pub u32);
    impl Ahb2lpencr {
        #[doc = "RAMCFG sleep enable."]
        #[inline(always)]
        pub const fn ramcfglpenc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "RAMCFG sleep enable."]
        #[inline(always)]
        pub fn set_ramcfglpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "MDF1 sleep enable."]
        #[inline(always)]
        pub const fn mdf1lpenc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MDF1 sleep enable."]
        #[inline(always)]
        pub fn set_mdf1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "ADF1 sleep enable."]
        #[inline(always)]
        pub const fn adf1lpenc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "ADF1 sleep enable."]
        #[inline(always)]
        pub fn set_adf1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for Ahb2lpencr {
        #[inline(always)]
        fn default() -> Ahb2lpencr {
            Ahb2lpencr(0)
        }
    }
    impl core::fmt::Debug for Ahb2lpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb2lpencr")
                .field("ramcfglpenc", &self.ramcfglpenc())
                .field("mdf1lpenc", &self.mdf1lpenc())
                .field("adf1lpenc", &self.adf1lpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb2lpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb2lpencr {{ ramcfglpenc: {=bool:?}, mdf1lpenc: {=bool:?}, adf1lpenc: {=bool:?} }}",
                self.ramcfglpenc(),
                self.mdf1lpenc(),
                self.adf1lpenc()
            )
        }
    }
    #[doc = "RCC AHB2 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb2lpenr(pub u32);
    impl Ahb2lpenr {
        #[doc = "RAMCFG sleep enable."]
        #[inline(always)]
        pub const fn ramcfglpen(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "RAMCFG sleep enable."]
        #[inline(always)]
        pub fn set_ramcfglpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "MDF1 sleep enable."]
        #[inline(always)]
        pub const fn mdf1lpen(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MDF1 sleep enable."]
        #[inline(always)]
        pub fn set_mdf1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "ADF1 sleep enable."]
        #[inline(always)]
        pub const fn adf1lpen(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "ADF1 sleep enable."]
        #[inline(always)]
        pub fn set_adf1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for Ahb2lpenr {
        #[inline(always)]
        fn default() -> Ahb2lpenr {
            Ahb2lpenr(0)
        }
    }
    impl core::fmt::Debug for Ahb2lpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb2lpenr")
                .field("ramcfglpen", &self.ramcfglpen())
                .field("mdf1lpen", &self.mdf1lpen())
                .field("adf1lpen", &self.adf1lpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb2lpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb2lpenr {{ ramcfglpen: {=bool:?}, mdf1lpen: {=bool:?}, adf1lpen: {=bool:?} }}",
                self.ramcfglpen(),
                self.mdf1lpen(),
                self.adf1lpen()
            )
        }
    }
    #[doc = "RCC AHB2 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb2lpensr(pub u32);
    impl Ahb2lpensr {
        #[doc = "RAMCFG sleep enable."]
        #[inline(always)]
        pub const fn ramcfglpens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "RAMCFG sleep enable."]
        #[inline(always)]
        pub fn set_ramcfglpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "MDF1 sleep enable."]
        #[inline(always)]
        pub const fn mdf1lpens(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MDF1 sleep enable."]
        #[inline(always)]
        pub fn set_mdf1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "ADF1 sleep enable."]
        #[inline(always)]
        pub const fn adf1lpens(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "ADF1 sleep enable."]
        #[inline(always)]
        pub fn set_adf1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for Ahb2lpensr {
        #[inline(always)]
        fn default() -> Ahb2lpensr {
            Ahb2lpensr(0)
        }
    }
    impl core::fmt::Debug for Ahb2lpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb2lpensr")
                .field("ramcfglpens", &self.ramcfglpens())
                .field("mdf1lpens", &self.mdf1lpens())
                .field("adf1lpens", &self.adf1lpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb2lpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb2lpensr {{ ramcfglpens: {=bool:?}, mdf1lpens: {=bool:?}, adf1lpens: {=bool:?} }}",
                self.ramcfglpens(),
                self.mdf1lpens(),
                self.adf1lpens()
            )
        }
    }
    #[doc = "RCC AHB2 Reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb2rstcr(pub u32);
    impl Ahb2rstcr {
        #[doc = "RAMCFG reset."]
        #[inline(always)]
        pub const fn ramcfgrstc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "RAMCFG reset."]
        #[inline(always)]
        pub fn set_ramcfgrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "MDF1 reset."]
        #[inline(always)]
        pub const fn mdf1rstc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MDF1 reset."]
        #[inline(always)]
        pub fn set_mdf1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "ADF1 reset."]
        #[inline(always)]
        pub const fn adf1rstc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "ADF1 reset."]
        #[inline(always)]
        pub fn set_adf1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for Ahb2rstcr {
        #[inline(always)]
        fn default() -> Ahb2rstcr {
            Ahb2rstcr(0)
        }
    }
    impl core::fmt::Debug for Ahb2rstcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb2rstcr")
                .field("ramcfgrstc", &self.ramcfgrstc())
                .field("mdf1rstc", &self.mdf1rstc())
                .field("adf1rstc", &self.adf1rstc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb2rstcr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb2rstcr {{ ramcfgrstc: {=bool:?}, mdf1rstc: {=bool:?}, adf1rstc: {=bool:?} }}",
                self.ramcfgrstc(),
                self.mdf1rstc(),
                self.adf1rstc()
            )
        }
    }
    #[doc = "RCC AHB2 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb2rstr(pub u32);
    impl Ahb2rstr {
        #[doc = "RAMCFG reset."]
        #[inline(always)]
        pub const fn ramcfgrst(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "RAMCFG reset."]
        #[inline(always)]
        pub fn set_ramcfgrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "MDF1 reset."]
        #[inline(always)]
        pub const fn mdf1rst(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MDF1 reset."]
        #[inline(always)]
        pub fn set_mdf1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "ADF1 reset."]
        #[inline(always)]
        pub const fn adf1rst(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "ADF1 reset."]
        #[inline(always)]
        pub fn set_adf1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for Ahb2rstr {
        #[inline(always)]
        fn default() -> Ahb2rstr {
            Ahb2rstr(0)
        }
    }
    impl core::fmt::Debug for Ahb2rstr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb2rstr")
                .field("ramcfgrst", &self.ramcfgrst())
                .field("mdf1rst", &self.mdf1rst())
                .field("adf1rst", &self.adf1rst())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb2rstr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb2rstr {{ ramcfgrst: {=bool:?}, mdf1rst: {=bool:?}, adf1rst: {=bool:?} }}",
                self.ramcfgrst(),
                self.mdf1rst(),
                self.adf1rst()
            )
        }
    }
    #[doc = "RCC AHB2 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb2rstsr(pub u32);
    impl Ahb2rstsr {
        #[doc = "RAMCFG reset."]
        #[inline(always)]
        pub const fn ramcfgrsts(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "RAMCFG reset."]
        #[inline(always)]
        pub fn set_ramcfgrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "MDF1 reset."]
        #[inline(always)]
        pub const fn mdf1rsts(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MDF1 reset."]
        #[inline(always)]
        pub fn set_mdf1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "ADF1 reset."]
        #[inline(always)]
        pub const fn adf1rsts(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "ADF1 reset."]
        #[inline(always)]
        pub fn set_adf1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for Ahb2rstsr {
        #[inline(always)]
        fn default() -> Ahb2rstsr {
            Ahb2rstsr(0)
        }
    }
    impl core::fmt::Debug for Ahb2rstsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb2rstsr")
                .field("ramcfgrsts", &self.ramcfgrsts())
                .field("mdf1rsts", &self.mdf1rsts())
                .field("adf1rsts", &self.adf1rsts())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb2rstsr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ahb2rstsr {{ ramcfgrsts: {=bool:?}, mdf1rsts: {=bool:?}, adf1rsts: {=bool:?} }}",
                self.ramcfgrsts(),
                self.mdf1rsts(),
                self.adf1rsts()
            )
        }
    }
    #[doc = "RCC AHB3 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb3encr(pub u32);
    impl Ahb3encr {
        #[doc = "RNG enable."]
        #[inline(always)]
        pub const fn rngenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "RNG enable."]
        #[inline(always)]
        pub fn set_rngenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "HASH enable."]
        #[inline(always)]
        pub const fn hashenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "HASH enable."]
        #[inline(always)]
        pub fn set_hashenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "CRYP enable."]
        #[inline(always)]
        pub const fn crypenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "CRYP enable."]
        #[inline(always)]
        pub fn set_crypenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "SAES enable."]
        #[inline(always)]
        pub const fn saesenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "SAES enable."]
        #[inline(always)]
        pub fn set_saesenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "PKA enable."]
        #[inline(always)]
        pub const fn pkaenc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "PKA enable."]
        #[inline(always)]
        pub fn set_pkaenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "RIFSC enable."]
        #[inline(always)]
        pub const fn rifscenc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "RIFSC enable."]
        #[inline(always)]
        pub fn set_rifscenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "IAC enable."]
        #[inline(always)]
        pub const fn iacenc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IAC enable."]
        #[inline(always)]
        pub fn set_iacenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "RISAF enable."]
        #[inline(always)]
        pub const fn risafenc(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "RISAF enable."]
        #[inline(always)]
        pub fn set_risafenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
    }
    impl Default for Ahb3encr {
        #[inline(always)]
        fn default() -> Ahb3encr {
            Ahb3encr(0)
        }
    }
    impl core::fmt::Debug for Ahb3encr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb3encr")
                .field("rngenc", &self.rngenc())
                .field("hashenc", &self.hashenc())
                .field("crypenc", &self.crypenc())
                .field("saesenc", &self.saesenc())
                .field("pkaenc", &self.pkaenc())
                .field("rifscenc", &self.rifscenc())
                .field("iacenc", &self.iacenc())
                .field("risafenc", &self.risafenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb3encr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb3encr {{ rngenc: {=bool:?}, hashenc: {=bool:?}, crypenc: {=bool:?}, saesenc: {=bool:?}, pkaenc: {=bool:?}, rifscenc: {=bool:?}, iacenc: {=bool:?}, risafenc: {=bool:?} }}" , self . rngenc () , self . hashenc () , self . crypenc () , self . saesenc () , self . pkaenc () , self . rifscenc () , self . iacenc () , self . risafenc ())
        }
    }
    #[doc = "RCC AHB3 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb3enr(pub u32);
    impl Ahb3enr {
        #[doc = "RNG enable."]
        #[inline(always)]
        pub const fn rngen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "RNG enable."]
        #[inline(always)]
        pub fn set_rngen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "HASH enable."]
        #[inline(always)]
        pub const fn hashen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "HASH enable."]
        #[inline(always)]
        pub fn set_hashen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "CRYP enable."]
        #[inline(always)]
        pub const fn crypen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "CRYP enable."]
        #[inline(always)]
        pub fn set_crypen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "SAES enable."]
        #[inline(always)]
        pub const fn saesen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "SAES enable."]
        #[inline(always)]
        pub fn set_saesen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "PKA enable."]
        #[inline(always)]
        pub const fn pkaen(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "PKA enable."]
        #[inline(always)]
        pub fn set_pkaen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "RIFSC enable."]
        #[inline(always)]
        pub const fn rifscen(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "RIFSC enable."]
        #[inline(always)]
        pub fn set_rifscen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "IAC enable."]
        #[inline(always)]
        pub const fn iacen(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IAC enable."]
        #[inline(always)]
        pub fn set_iacen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "RISAF enable."]
        #[inline(always)]
        pub const fn risafen(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "RISAF enable."]
        #[inline(always)]
        pub fn set_risafen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
    }
    impl Default for Ahb3enr {
        #[inline(always)]
        fn default() -> Ahb3enr {
            Ahb3enr(0)
        }
    }
    impl core::fmt::Debug for Ahb3enr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb3enr")
                .field("rngen", &self.rngen())
                .field("hashen", &self.hashen())
                .field("crypen", &self.crypen())
                .field("saesen", &self.saesen())
                .field("pkaen", &self.pkaen())
                .field("rifscen", &self.rifscen())
                .field("iacen", &self.iacen())
                .field("risafen", &self.risafen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb3enr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb3enr {{ rngen: {=bool:?}, hashen: {=bool:?}, crypen: {=bool:?}, saesen: {=bool:?}, pkaen: {=bool:?}, rifscen: {=bool:?}, iacen: {=bool:?}, risafen: {=bool:?} }}" , self . rngen () , self . hashen () , self . crypen () , self . saesen () , self . pkaen () , self . rifscen () , self . iacen () , self . risafen ())
        }
    }
    #[doc = "RCC AHB3 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb3ensr(pub u32);
    impl Ahb3ensr {
        #[doc = "RNG enable."]
        #[inline(always)]
        pub const fn rngens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "RNG enable."]
        #[inline(always)]
        pub fn set_rngens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "HASH enable."]
        #[inline(always)]
        pub const fn hashens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "HASH enable."]
        #[inline(always)]
        pub fn set_hashens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "CRYP enable."]
        #[inline(always)]
        pub const fn crypens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "CRYP enable."]
        #[inline(always)]
        pub fn set_crypens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "SAES enable."]
        #[inline(always)]
        pub const fn saesens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "SAES enable."]
        #[inline(always)]
        pub fn set_saesens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "PKA enable."]
        #[inline(always)]
        pub const fn pkaens(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "PKA enable."]
        #[inline(always)]
        pub fn set_pkaens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "RIFSC enable."]
        #[inline(always)]
        pub const fn rifscens(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "RIFSC enable."]
        #[inline(always)]
        pub fn set_rifscens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "IAC enable."]
        #[inline(always)]
        pub const fn iacens(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IAC enable."]
        #[inline(always)]
        pub fn set_iacens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "RISAF enable."]
        #[inline(always)]
        pub const fn risafens(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "RISAF enable."]
        #[inline(always)]
        pub fn set_risafens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
    }
    impl Default for Ahb3ensr {
        #[inline(always)]
        fn default() -> Ahb3ensr {
            Ahb3ensr(0)
        }
    }
    impl core::fmt::Debug for Ahb3ensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb3ensr")
                .field("rngens", &self.rngens())
                .field("hashens", &self.hashens())
                .field("crypens", &self.crypens())
                .field("saesens", &self.saesens())
                .field("pkaens", &self.pkaens())
                .field("rifscens", &self.rifscens())
                .field("iacens", &self.iacens())
                .field("risafens", &self.risafens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb3ensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb3ensr {{ rngens: {=bool:?}, hashens: {=bool:?}, crypens: {=bool:?}, saesens: {=bool:?}, pkaens: {=bool:?}, rifscens: {=bool:?}, iacens: {=bool:?}, risafens: {=bool:?} }}" , self . rngens () , self . hashens () , self . crypens () , self . saesens () , self . pkaens () , self . rifscens () , self . iacens () , self . risafens ())
        }
    }
    #[doc = "RCC AHB3 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb3lpencr(pub u32);
    impl Ahb3lpencr {
        #[doc = "RNG sleep enable."]
        #[inline(always)]
        pub const fn rnglpenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "RNG sleep enable."]
        #[inline(always)]
        pub fn set_rnglpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "HASH sleep enable."]
        #[inline(always)]
        pub const fn hashlpenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "HASH sleep enable."]
        #[inline(always)]
        pub fn set_hashlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "CRYP sleep enable."]
        #[inline(always)]
        pub const fn cryplpenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "CRYP sleep enable."]
        #[inline(always)]
        pub fn set_cryplpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "SAES sleep enable."]
        #[inline(always)]
        pub const fn saeslpenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "SAES sleep enable."]
        #[inline(always)]
        pub fn set_saeslpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "PKA sleep enable."]
        #[inline(always)]
        pub const fn pkalpenc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "PKA sleep enable."]
        #[inline(always)]
        pub fn set_pkalpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "RIFSC sleep enable."]
        #[inline(always)]
        pub const fn rifsclpenc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "RIFSC sleep enable."]
        #[inline(always)]
        pub fn set_rifsclpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "IAC sleep enable."]
        #[inline(always)]
        pub const fn iaclpenc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IAC sleep enable."]
        #[inline(always)]
        pub fn set_iaclpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "RISAF sleep enable."]
        #[inline(always)]
        pub const fn risaflpenc(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "RISAF sleep enable."]
        #[inline(always)]
        pub fn set_risaflpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
    }
    impl Default for Ahb3lpencr {
        #[inline(always)]
        fn default() -> Ahb3lpencr {
            Ahb3lpencr(0)
        }
    }
    impl core::fmt::Debug for Ahb3lpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb3lpencr")
                .field("rnglpenc", &self.rnglpenc())
                .field("hashlpenc", &self.hashlpenc())
                .field("cryplpenc", &self.cryplpenc())
                .field("saeslpenc", &self.saeslpenc())
                .field("pkalpenc", &self.pkalpenc())
                .field("rifsclpenc", &self.rifsclpenc())
                .field("iaclpenc", &self.iaclpenc())
                .field("risaflpenc", &self.risaflpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb3lpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb3lpencr {{ rnglpenc: {=bool:?}, hashlpenc: {=bool:?}, cryplpenc: {=bool:?}, saeslpenc: {=bool:?}, pkalpenc: {=bool:?}, rifsclpenc: {=bool:?}, iaclpenc: {=bool:?}, risaflpenc: {=bool:?} }}" , self . rnglpenc () , self . hashlpenc () , self . cryplpenc () , self . saeslpenc () , self . pkalpenc () , self . rifsclpenc () , self . iaclpenc () , self . risaflpenc ())
        }
    }
    #[doc = "RCC AHB3 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb3lpenr(pub u32);
    impl Ahb3lpenr {
        #[doc = "RNG sleep enable."]
        #[inline(always)]
        pub const fn rnglpen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "RNG sleep enable."]
        #[inline(always)]
        pub fn set_rnglpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "HASH sleep enable."]
        #[inline(always)]
        pub const fn hashlpen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "HASH sleep enable."]
        #[inline(always)]
        pub fn set_hashlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "CRYP sleep enable."]
        #[inline(always)]
        pub const fn cryplpen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "CRYP sleep enable."]
        #[inline(always)]
        pub fn set_cryplpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "SAES sleep enable."]
        #[inline(always)]
        pub const fn saeslpen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "SAES sleep enable."]
        #[inline(always)]
        pub fn set_saeslpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "PKA sleep enable."]
        #[inline(always)]
        pub const fn pkalpen(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "PKA sleep enable."]
        #[inline(always)]
        pub fn set_pkalpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "RIFSC sleep enable."]
        #[inline(always)]
        pub const fn rifsclpen(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "RIFSC sleep enable."]
        #[inline(always)]
        pub fn set_rifsclpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "IAC sleep enable."]
        #[inline(always)]
        pub const fn iaclpen(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IAC sleep enable."]
        #[inline(always)]
        pub fn set_iaclpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "RISAF sleep enable."]
        #[inline(always)]
        pub const fn risaflpen(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "RISAF sleep enable."]
        #[inline(always)]
        pub fn set_risaflpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
    }
    impl Default for Ahb3lpenr {
        #[inline(always)]
        fn default() -> Ahb3lpenr {
            Ahb3lpenr(0)
        }
    }
    impl core::fmt::Debug for Ahb3lpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb3lpenr")
                .field("rnglpen", &self.rnglpen())
                .field("hashlpen", &self.hashlpen())
                .field("cryplpen", &self.cryplpen())
                .field("saeslpen", &self.saeslpen())
                .field("pkalpen", &self.pkalpen())
                .field("rifsclpen", &self.rifsclpen())
                .field("iaclpen", &self.iaclpen())
                .field("risaflpen", &self.risaflpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb3lpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb3lpenr {{ rnglpen: {=bool:?}, hashlpen: {=bool:?}, cryplpen: {=bool:?}, saeslpen: {=bool:?}, pkalpen: {=bool:?}, rifsclpen: {=bool:?}, iaclpen: {=bool:?}, risaflpen: {=bool:?} }}" , self . rnglpen () , self . hashlpen () , self . cryplpen () , self . saeslpen () , self . pkalpen () , self . rifsclpen () , self . iaclpen () , self . risaflpen ())
        }
    }
    #[doc = "RCC AHB3 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb3lpensr(pub u32);
    impl Ahb3lpensr {
        #[doc = "RNG sleep enable."]
        #[inline(always)]
        pub const fn rnglpens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "RNG sleep enable."]
        #[inline(always)]
        pub fn set_rnglpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "HASH sleep enable."]
        #[inline(always)]
        pub const fn hashlpens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "HASH sleep enable."]
        #[inline(always)]
        pub fn set_hashlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "CRYP sleep enable."]
        #[inline(always)]
        pub const fn cryplpens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "CRYP sleep enable."]
        #[inline(always)]
        pub fn set_cryplpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "SAES sleep enable."]
        #[inline(always)]
        pub const fn saeslpens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "SAES sleep enable."]
        #[inline(always)]
        pub fn set_saeslpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "PKA sleep enable."]
        #[inline(always)]
        pub const fn pkalpens(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "PKA sleep enable."]
        #[inline(always)]
        pub fn set_pkalpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "RIFSC sleep enable."]
        #[inline(always)]
        pub const fn rifsclpens(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "RIFSC sleep enable."]
        #[inline(always)]
        pub fn set_rifsclpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "IAC sleep enable."]
        #[inline(always)]
        pub const fn iaclpens(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IAC sleep enable."]
        #[inline(always)]
        pub fn set_iaclpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "RISAF sleep enable."]
        #[inline(always)]
        pub const fn risaflpens(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "RISAF sleep enable."]
        #[inline(always)]
        pub fn set_risaflpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
    }
    impl Default for Ahb3lpensr {
        #[inline(always)]
        fn default() -> Ahb3lpensr {
            Ahb3lpensr(0)
        }
    }
    impl core::fmt::Debug for Ahb3lpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb3lpensr")
                .field("rnglpens", &self.rnglpens())
                .field("hashlpens", &self.hashlpens())
                .field("cryplpens", &self.cryplpens())
                .field("saeslpens", &self.saeslpens())
                .field("pkalpens", &self.pkalpens())
                .field("rifsclpens", &self.rifsclpens())
                .field("iaclpens", &self.iaclpens())
                .field("risaflpens", &self.risaflpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb3lpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb3lpensr {{ rnglpens: {=bool:?}, hashlpens: {=bool:?}, cryplpens: {=bool:?}, saeslpens: {=bool:?}, pkalpens: {=bool:?}, rifsclpens: {=bool:?}, iaclpens: {=bool:?}, risaflpens: {=bool:?} }}" , self . rnglpens () , self . hashlpens () , self . cryplpens () , self . saeslpens () , self . pkalpens () , self . rifsclpens () , self . iaclpens () , self . risaflpens ())
        }
    }
    #[doc = "RCC AHB3 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb3rstcr(pub u32);
    impl Ahb3rstcr {
        #[doc = "RNG reset."]
        #[inline(always)]
        pub const fn rngrstc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "RNG reset."]
        #[inline(always)]
        pub fn set_rngrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "HASH reset."]
        #[inline(always)]
        pub const fn hashrstc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "HASH reset."]
        #[inline(always)]
        pub fn set_hashrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "CRYP reset."]
        #[inline(always)]
        pub const fn cryprstc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "CRYP reset."]
        #[inline(always)]
        pub fn set_cryprstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "SAES reset."]
        #[inline(always)]
        pub const fn saesrstc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "SAES reset."]
        #[inline(always)]
        pub fn set_saesrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "PKA reset."]
        #[inline(always)]
        pub const fn pkarstc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "PKA reset."]
        #[inline(always)]
        pub fn set_pkarstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "IAC reset."]
        #[inline(always)]
        pub const fn iacrstc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IAC reset."]
        #[inline(always)]
        pub fn set_iacrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
    }
    impl Default for Ahb3rstcr {
        #[inline(always)]
        fn default() -> Ahb3rstcr {
            Ahb3rstcr(0)
        }
    }
    impl core::fmt::Debug for Ahb3rstcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb3rstcr")
                .field("rngrstc", &self.rngrstc())
                .field("hashrstc", &self.hashrstc())
                .field("cryprstc", &self.cryprstc())
                .field("saesrstc", &self.saesrstc())
                .field("pkarstc", &self.pkarstc())
                .field("iacrstc", &self.iacrstc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb3rstcr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb3rstcr {{ rngrstc: {=bool:?}, hashrstc: {=bool:?}, cryprstc: {=bool:?}, saesrstc: {=bool:?}, pkarstc: {=bool:?}, iacrstc: {=bool:?} }}" , self . rngrstc () , self . hashrstc () , self . cryprstc () , self . saesrstc () , self . pkarstc () , self . iacrstc ())
        }
    }
    #[doc = "RCC AHB3 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb3rstr(pub u32);
    impl Ahb3rstr {
        #[doc = "RNG reset."]
        #[inline(always)]
        pub const fn rngrst(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "RNG reset."]
        #[inline(always)]
        pub fn set_rngrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "HASH reset."]
        #[inline(always)]
        pub const fn hashrst(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "HASH reset."]
        #[inline(always)]
        pub fn set_hashrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "CRYP reset."]
        #[inline(always)]
        pub const fn cryprst(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "CRYP reset."]
        #[inline(always)]
        pub fn set_cryprst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "SAES reset."]
        #[inline(always)]
        pub const fn saesrst(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "SAES reset."]
        #[inline(always)]
        pub fn set_saesrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "PKA reset."]
        #[inline(always)]
        pub const fn pkarst(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "PKA reset."]
        #[inline(always)]
        pub fn set_pkarst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "IAC reset."]
        #[inline(always)]
        pub const fn iacrst(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IAC reset."]
        #[inline(always)]
        pub fn set_iacrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
    }
    impl Default for Ahb3rstr {
        #[inline(always)]
        fn default() -> Ahb3rstr {
            Ahb3rstr(0)
        }
    }
    impl core::fmt::Debug for Ahb3rstr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb3rstr")
                .field("rngrst", &self.rngrst())
                .field("hashrst", &self.hashrst())
                .field("cryprst", &self.cryprst())
                .field("saesrst", &self.saesrst())
                .field("pkarst", &self.pkarst())
                .field("iacrst", &self.iacrst())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb3rstr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb3rstr {{ rngrst: {=bool:?}, hashrst: {=bool:?}, cryprst: {=bool:?}, saesrst: {=bool:?}, pkarst: {=bool:?}, iacrst: {=bool:?} }}" , self . rngrst () , self . hashrst () , self . cryprst () , self . saesrst () , self . pkarst () , self . iacrst ())
        }
    }
    #[doc = "RCC AHB3 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb3rstsr(pub u32);
    impl Ahb3rstsr {
        #[doc = "RNG reset."]
        #[inline(always)]
        pub const fn rngrsts(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "RNG reset."]
        #[inline(always)]
        pub fn set_rngrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "HASH reset."]
        #[inline(always)]
        pub const fn hashrsts(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "HASH reset."]
        #[inline(always)]
        pub fn set_hashrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "CRYP reset."]
        #[inline(always)]
        pub const fn cryprsts(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "CRYP reset."]
        #[inline(always)]
        pub fn set_cryprsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "SAES reset."]
        #[inline(always)]
        pub const fn saesrsts(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "SAES reset."]
        #[inline(always)]
        pub fn set_saesrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "PKA reset."]
        #[inline(always)]
        pub const fn pkarsts(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "PKA reset."]
        #[inline(always)]
        pub fn set_pkarsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "IAC reset."]
        #[inline(always)]
        pub const fn iacrsts(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IAC reset."]
        #[inline(always)]
        pub fn set_iacrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
    }
    impl Default for Ahb3rstsr {
        #[inline(always)]
        fn default() -> Ahb3rstsr {
            Ahb3rstsr(0)
        }
    }
    impl core::fmt::Debug for Ahb3rstsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb3rstsr")
                .field("rngrsts", &self.rngrsts())
                .field("hashrsts", &self.hashrsts())
                .field("cryprsts", &self.cryprsts())
                .field("saesrsts", &self.saesrsts())
                .field("pkarsts", &self.pkarsts())
                .field("iacrsts", &self.iacrsts())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb3rstsr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb3rstsr {{ rngrsts: {=bool:?}, hashrsts: {=bool:?}, cryprsts: {=bool:?}, saesrsts: {=bool:?}, pkarsts: {=bool:?}, iacrsts: {=bool:?} }}" , self . rngrsts () , self . hashrsts () , self . cryprsts () , self . saesrsts () , self . pkarsts () , self . iacrsts ())
        }
    }
    #[doc = "RCC AHB4 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb4encr(pub u32);
    impl Ahb4encr {
        #[doc = "GPIOA enable."]
        #[inline(always)]
        pub const fn gpioaenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOA enable."]
        #[inline(always)]
        pub fn set_gpioaenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "GPIOB enable."]
        #[inline(always)]
        pub const fn gpiobenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOB enable."]
        #[inline(always)]
        pub fn set_gpiobenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "GPIOC enable."]
        #[inline(always)]
        pub const fn gpiocenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOC enable."]
        #[inline(always)]
        pub fn set_gpiocenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GPIOD enable."]
        #[inline(always)]
        pub const fn gpiodenc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOD enable."]
        #[inline(always)]
        pub fn set_gpiodenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "GPIOE enable."]
        #[inline(always)]
        pub const fn gpioeenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOE enable."]
        #[inline(always)]
        pub fn set_gpioeenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "GPIOF enable."]
        #[inline(always)]
        pub const fn gpiofenc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOF enable."]
        #[inline(always)]
        pub fn set_gpiofenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "GPIOG enable."]
        #[inline(always)]
        pub const fn gpiogenc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOG enable."]
        #[inline(always)]
        pub fn set_gpiogenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "GPIOH enable."]
        #[inline(always)]
        pub const fn gpiohenc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOH enable."]
        #[inline(always)]
        pub fn set_gpiohenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "GPION enable."]
        #[inline(always)]
        pub const fn gpionenc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "GPION enable."]
        #[inline(always)]
        pub fn set_gpionenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "GPIOO enable."]
        #[inline(always)]
        pub const fn gpiooenc(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOO enable."]
        #[inline(always)]
        pub fn set_gpiooenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "GPIOP enable."]
        #[inline(always)]
        pub const fn gpiopenc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOP enable."]
        #[inline(always)]
        pub fn set_gpiopenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "GPIOQ enable."]
        #[inline(always)]
        pub const fn gpioqenc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOQ enable."]
        #[inline(always)]
        pub fn set_gpioqenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "PWR enable."]
        #[inline(always)]
        pub const fn pwrenc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "PWR enable."]
        #[inline(always)]
        pub fn set_pwrenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "CRC enable."]
        #[inline(always)]
        pub const fn crcenc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "CRC enable."]
        #[inline(always)]
        pub fn set_crcenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Ahb4encr {
        #[inline(always)]
        fn default() -> Ahb4encr {
            Ahb4encr(0)
        }
    }
    impl core::fmt::Debug for Ahb4encr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb4encr")
                .field("gpioaenc", &self.gpioaenc())
                .field("gpiobenc", &self.gpiobenc())
                .field("gpiocenc", &self.gpiocenc())
                .field("gpiodenc", &self.gpiodenc())
                .field("gpioeenc", &self.gpioeenc())
                .field("gpiofenc", &self.gpiofenc())
                .field("gpiogenc", &self.gpiogenc())
                .field("gpiohenc", &self.gpiohenc())
                .field("gpionenc", &self.gpionenc())
                .field("gpiooenc", &self.gpiooenc())
                .field("gpiopenc", &self.gpiopenc())
                .field("gpioqenc", &self.gpioqenc())
                .field("pwrenc", &self.pwrenc())
                .field("crcenc", &self.crcenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb4encr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb4encr {{ gpioaenc: {=bool:?}, gpiobenc: {=bool:?}, gpiocenc: {=bool:?}, gpiodenc: {=bool:?}, gpioeenc: {=bool:?}, gpiofenc: {=bool:?}, gpiogenc: {=bool:?}, gpiohenc: {=bool:?}, gpionenc: {=bool:?}, gpiooenc: {=bool:?}, gpiopenc: {=bool:?}, gpioqenc: {=bool:?}, pwrenc: {=bool:?}, crcenc: {=bool:?} }}" , self . gpioaenc () , self . gpiobenc () , self . gpiocenc () , self . gpiodenc () , self . gpioeenc () , self . gpiofenc () , self . gpiogenc () , self . gpiohenc () , self . gpionenc () , self . gpiooenc () , self . gpiopenc () , self . gpioqenc () , self . pwrenc () , self . crcenc ())
        }
    }
    #[doc = "RCC AHB4 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb4enr(pub u32);
    impl Ahb4enr {
        #[doc = "GPIOA enable."]
        #[inline(always)]
        pub const fn gpioaen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOA enable."]
        #[inline(always)]
        pub fn set_gpioaen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "GPIOB enable."]
        #[inline(always)]
        pub const fn gpioben(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOB enable."]
        #[inline(always)]
        pub fn set_gpioben(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "GPIOC enable."]
        #[inline(always)]
        pub const fn gpiocen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOC enable."]
        #[inline(always)]
        pub fn set_gpiocen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GPIOD enable."]
        #[inline(always)]
        pub const fn gpioden(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOD enable."]
        #[inline(always)]
        pub fn set_gpioden(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "GPIOE enable."]
        #[inline(always)]
        pub const fn gpioeen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOE enable."]
        #[inline(always)]
        pub fn set_gpioeen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "GPIOF enable."]
        #[inline(always)]
        pub const fn gpiofen(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOF enable."]
        #[inline(always)]
        pub fn set_gpiofen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "GPIOG enable."]
        #[inline(always)]
        pub const fn gpiogen(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOG enable."]
        #[inline(always)]
        pub fn set_gpiogen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "GPIOH enable."]
        #[inline(always)]
        pub const fn gpiohen(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOH enable."]
        #[inline(always)]
        pub fn set_gpiohen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "GPION enable."]
        #[inline(always)]
        pub const fn gpionen(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "GPION enable."]
        #[inline(always)]
        pub fn set_gpionen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "GPIOO enable."]
        #[inline(always)]
        pub const fn gpiooen(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOO enable."]
        #[inline(always)]
        pub fn set_gpiooen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "GPIOP enable."]
        #[inline(always)]
        pub const fn gpiopen(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOP enable."]
        #[inline(always)]
        pub fn set_gpiopen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "GPIOQ enable."]
        #[inline(always)]
        pub const fn gpioqen(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOQ enable."]
        #[inline(always)]
        pub fn set_gpioqen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "PWR enable."]
        #[inline(always)]
        pub const fn pwren(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "PWR enable."]
        #[inline(always)]
        pub fn set_pwren(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "CRC enable."]
        #[inline(always)]
        pub const fn crcen(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "CRC enable."]
        #[inline(always)]
        pub fn set_crcen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Ahb4enr {
        #[inline(always)]
        fn default() -> Ahb4enr {
            Ahb4enr(0)
        }
    }
    impl core::fmt::Debug for Ahb4enr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb4enr")
                .field("gpioaen", &self.gpioaen())
                .field("gpioben", &self.gpioben())
                .field("gpiocen", &self.gpiocen())
                .field("gpioden", &self.gpioden())
                .field("gpioeen", &self.gpioeen())
                .field("gpiofen", &self.gpiofen())
                .field("gpiogen", &self.gpiogen())
                .field("gpiohen", &self.gpiohen())
                .field("gpionen", &self.gpionen())
                .field("gpiooen", &self.gpiooen())
                .field("gpiopen", &self.gpiopen())
                .field("gpioqen", &self.gpioqen())
                .field("pwren", &self.pwren())
                .field("crcen", &self.crcen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb4enr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb4enr {{ gpioaen: {=bool:?}, gpioben: {=bool:?}, gpiocen: {=bool:?}, gpioden: {=bool:?}, gpioeen: {=bool:?}, gpiofen: {=bool:?}, gpiogen: {=bool:?}, gpiohen: {=bool:?}, gpionen: {=bool:?}, gpiooen: {=bool:?}, gpiopen: {=bool:?}, gpioqen: {=bool:?}, pwren: {=bool:?}, crcen: {=bool:?} }}" , self . gpioaen () , self . gpioben () , self . gpiocen () , self . gpioden () , self . gpioeen () , self . gpiofen () , self . gpiogen () , self . gpiohen () , self . gpionen () , self . gpiooen () , self . gpiopen () , self . gpioqen () , self . pwren () , self . crcen ())
        }
    }
    #[doc = "RCC AHB4 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb4ensr(pub u32);
    impl Ahb4ensr {
        #[doc = "GPIOA enable."]
        #[inline(always)]
        pub const fn gpioaens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOA enable."]
        #[inline(always)]
        pub fn set_gpioaens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "GPIOB enable."]
        #[inline(always)]
        pub const fn gpiobens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOB enable."]
        #[inline(always)]
        pub fn set_gpiobens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "GPIOC enable."]
        #[inline(always)]
        pub const fn gpiocens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOC enable."]
        #[inline(always)]
        pub fn set_gpiocens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GPIOD enable."]
        #[inline(always)]
        pub const fn gpiodens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOD enable."]
        #[inline(always)]
        pub fn set_gpiodens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "GPIOE enable."]
        #[inline(always)]
        pub const fn gpioeens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOE enable."]
        #[inline(always)]
        pub fn set_gpioeens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "GPIOF enable."]
        #[inline(always)]
        pub const fn gpiofens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOF enable."]
        #[inline(always)]
        pub fn set_gpiofens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "GPIOG enable."]
        #[inline(always)]
        pub const fn gpiogens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOG enable."]
        #[inline(always)]
        pub fn set_gpiogens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "GPIOH enable."]
        #[inline(always)]
        pub const fn gpiohens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOH enable."]
        #[inline(always)]
        pub fn set_gpiohens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "GPION enable."]
        #[inline(always)]
        pub const fn gpionens(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "GPION enable."]
        #[inline(always)]
        pub fn set_gpionens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "GPIOO enable."]
        #[inline(always)]
        pub const fn gpiooens(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOO enable."]
        #[inline(always)]
        pub fn set_gpiooens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "GPIOP enable."]
        #[inline(always)]
        pub const fn gpiopens(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOP enable."]
        #[inline(always)]
        pub fn set_gpiopens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "GPIOQ enable."]
        #[inline(always)]
        pub const fn gpioqens(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOQ enable."]
        #[inline(always)]
        pub fn set_gpioqens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "PWR enable."]
        #[inline(always)]
        pub const fn pwrens(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "PWR enable."]
        #[inline(always)]
        pub fn set_pwrens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "CRC enable."]
        #[inline(always)]
        pub const fn crcens(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "CRC enable."]
        #[inline(always)]
        pub fn set_crcens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Ahb4ensr {
        #[inline(always)]
        fn default() -> Ahb4ensr {
            Ahb4ensr(0)
        }
    }
    impl core::fmt::Debug for Ahb4ensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb4ensr")
                .field("gpioaens", &self.gpioaens())
                .field("gpiobens", &self.gpiobens())
                .field("gpiocens", &self.gpiocens())
                .field("gpiodens", &self.gpiodens())
                .field("gpioeens", &self.gpioeens())
                .field("gpiofens", &self.gpiofens())
                .field("gpiogens", &self.gpiogens())
                .field("gpiohens", &self.gpiohens())
                .field("gpionens", &self.gpionens())
                .field("gpiooens", &self.gpiooens())
                .field("gpiopens", &self.gpiopens())
                .field("gpioqens", &self.gpioqens())
                .field("pwrens", &self.pwrens())
                .field("crcens", &self.crcens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb4ensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb4ensr {{ gpioaens: {=bool:?}, gpiobens: {=bool:?}, gpiocens: {=bool:?}, gpiodens: {=bool:?}, gpioeens: {=bool:?}, gpiofens: {=bool:?}, gpiogens: {=bool:?}, gpiohens: {=bool:?}, gpionens: {=bool:?}, gpiooens: {=bool:?}, gpiopens: {=bool:?}, gpioqens: {=bool:?}, pwrens: {=bool:?}, crcens: {=bool:?} }}" , self . gpioaens () , self . gpiobens () , self . gpiocens () , self . gpiodens () , self . gpioeens () , self . gpiofens () , self . gpiogens () , self . gpiohens () , self . gpionens () , self . gpiooens () , self . gpiopens () , self . gpioqens () , self . pwrens () , self . crcens ())
        }
    }
    #[doc = "RCC AHB4 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb4lpencr(pub u32);
    impl Ahb4lpencr {
        #[doc = "GPIOA sleep enable."]
        #[inline(always)]
        pub const fn gpioalpenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOA sleep enable."]
        #[inline(always)]
        pub fn set_gpioalpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "GPIOB sleep enable."]
        #[inline(always)]
        pub const fn gpioblpenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOB sleep enable."]
        #[inline(always)]
        pub fn set_gpioblpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "GPIOC sleep enable."]
        #[inline(always)]
        pub const fn gpioclpenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOC sleep enable."]
        #[inline(always)]
        pub fn set_gpioclpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GPIOD sleep enable."]
        #[inline(always)]
        pub const fn gpiodlpenc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOD sleep enable."]
        #[inline(always)]
        pub fn set_gpiodlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "GPIOE sleep enable."]
        #[inline(always)]
        pub const fn gpioelpenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOE sleep enable."]
        #[inline(always)]
        pub fn set_gpioelpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "GPIOF sleep enable."]
        #[inline(always)]
        pub const fn gpioflpenc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOF sleep enable."]
        #[inline(always)]
        pub fn set_gpioflpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "GPIOG sleep enable."]
        #[inline(always)]
        pub const fn gpioglpenc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOG sleep enable."]
        #[inline(always)]
        pub fn set_gpioglpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "GPIOH sleep enable."]
        #[inline(always)]
        pub const fn gpiohlpenc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOH sleep enable."]
        #[inline(always)]
        pub fn set_gpiohlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "GPION sleep enable."]
        #[inline(always)]
        pub const fn gpionlpenc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "GPION sleep enable."]
        #[inline(always)]
        pub fn set_gpionlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "GPIOO sleep enable."]
        #[inline(always)]
        pub const fn gpioolpenc(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOO sleep enable."]
        #[inline(always)]
        pub fn set_gpioolpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "GPIOP sleep enable."]
        #[inline(always)]
        pub const fn gpioplpenc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOP sleep enable."]
        #[inline(always)]
        pub fn set_gpioplpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "GPIOQ sleep enable."]
        #[inline(always)]
        pub const fn gpioqlpenc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOQ sleep enable."]
        #[inline(always)]
        pub fn set_gpioqlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "PWR sleep enable."]
        #[inline(always)]
        pub const fn pwrlpenc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "PWR sleep enable."]
        #[inline(always)]
        pub fn set_pwrlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "CRC sleep enable."]
        #[inline(always)]
        pub const fn crclpenc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "CRC sleep enable."]
        #[inline(always)]
        pub fn set_crclpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Ahb4lpencr {
        #[inline(always)]
        fn default() -> Ahb4lpencr {
            Ahb4lpencr(0)
        }
    }
    impl core::fmt::Debug for Ahb4lpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb4lpencr")
                .field("gpioalpenc", &self.gpioalpenc())
                .field("gpioblpenc", &self.gpioblpenc())
                .field("gpioclpenc", &self.gpioclpenc())
                .field("gpiodlpenc", &self.gpiodlpenc())
                .field("gpioelpenc", &self.gpioelpenc())
                .field("gpioflpenc", &self.gpioflpenc())
                .field("gpioglpenc", &self.gpioglpenc())
                .field("gpiohlpenc", &self.gpiohlpenc())
                .field("gpionlpenc", &self.gpionlpenc())
                .field("gpioolpenc", &self.gpioolpenc())
                .field("gpioplpenc", &self.gpioplpenc())
                .field("gpioqlpenc", &self.gpioqlpenc())
                .field("pwrlpenc", &self.pwrlpenc())
                .field("crclpenc", &self.crclpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb4lpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb4lpencr {{ gpioalpenc: {=bool:?}, gpioblpenc: {=bool:?}, gpioclpenc: {=bool:?}, gpiodlpenc: {=bool:?}, gpioelpenc: {=bool:?}, gpioflpenc: {=bool:?}, gpioglpenc: {=bool:?}, gpiohlpenc: {=bool:?}, gpionlpenc: {=bool:?}, gpioolpenc: {=bool:?}, gpioplpenc: {=bool:?}, gpioqlpenc: {=bool:?}, pwrlpenc: {=bool:?}, crclpenc: {=bool:?} }}" , self . gpioalpenc () , self . gpioblpenc () , self . gpioclpenc () , self . gpiodlpenc () , self . gpioelpenc () , self . gpioflpenc () , self . gpioglpenc () , self . gpiohlpenc () , self . gpionlpenc () , self . gpioolpenc () , self . gpioplpenc () , self . gpioqlpenc () , self . pwrlpenc () , self . crclpenc ())
        }
    }
    #[doc = "RCC AHB4 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb4lpenr(pub u32);
    impl Ahb4lpenr {
        #[doc = "GPIOA sleep enable."]
        #[inline(always)]
        pub const fn gpioalpen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOA sleep enable."]
        #[inline(always)]
        pub fn set_gpioalpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "GPIOB sleep enable."]
        #[inline(always)]
        pub const fn gpioblpen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOB sleep enable."]
        #[inline(always)]
        pub fn set_gpioblpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "GPIOC sleep enable."]
        #[inline(always)]
        pub const fn gpioclpen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOC sleep enable."]
        #[inline(always)]
        pub fn set_gpioclpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GPIOD sleep enable."]
        #[inline(always)]
        pub const fn gpiodlpen(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOD sleep enable."]
        #[inline(always)]
        pub fn set_gpiodlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "GPIOE sleep enable."]
        #[inline(always)]
        pub const fn gpioelpen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOE sleep enable."]
        #[inline(always)]
        pub fn set_gpioelpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "GPIOF sleep enable."]
        #[inline(always)]
        pub const fn gpioflpen(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOF sleep enable."]
        #[inline(always)]
        pub fn set_gpioflpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "GPIOG sleep enable."]
        #[inline(always)]
        pub const fn gpioglpen(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOG sleep enable."]
        #[inline(always)]
        pub fn set_gpioglpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "GPIOH sleep enable."]
        #[inline(always)]
        pub const fn gpiohlpen(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOH sleep enable."]
        #[inline(always)]
        pub fn set_gpiohlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "GPION sleep enable."]
        #[inline(always)]
        pub const fn gpionlpen(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "GPION sleep enable."]
        #[inline(always)]
        pub fn set_gpionlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "GPIOO sleep enable."]
        #[inline(always)]
        pub const fn gpioolpen(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOO sleep enable."]
        #[inline(always)]
        pub fn set_gpioolpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "GPIOP sleep enable."]
        #[inline(always)]
        pub const fn gpioplpen(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOP sleep enable."]
        #[inline(always)]
        pub fn set_gpioplpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "GPIOQ sleep enable."]
        #[inline(always)]
        pub const fn gpioqlpen(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOQ sleep enable."]
        #[inline(always)]
        pub fn set_gpioqlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "PWR sleep enable."]
        #[inline(always)]
        pub const fn pwrlpen(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "PWR sleep enable."]
        #[inline(always)]
        pub fn set_pwrlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "CRC sleep enable."]
        #[inline(always)]
        pub const fn crclpen(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "CRC sleep enable."]
        #[inline(always)]
        pub fn set_crclpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Ahb4lpenr {
        #[inline(always)]
        fn default() -> Ahb4lpenr {
            Ahb4lpenr(0)
        }
    }
    impl core::fmt::Debug for Ahb4lpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb4lpenr")
                .field("gpioalpen", &self.gpioalpen())
                .field("gpioblpen", &self.gpioblpen())
                .field("gpioclpen", &self.gpioclpen())
                .field("gpiodlpen", &self.gpiodlpen())
                .field("gpioelpen", &self.gpioelpen())
                .field("gpioflpen", &self.gpioflpen())
                .field("gpioglpen", &self.gpioglpen())
                .field("gpiohlpen", &self.gpiohlpen())
                .field("gpionlpen", &self.gpionlpen())
                .field("gpioolpen", &self.gpioolpen())
                .field("gpioplpen", &self.gpioplpen())
                .field("gpioqlpen", &self.gpioqlpen())
                .field("pwrlpen", &self.pwrlpen())
                .field("crclpen", &self.crclpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb4lpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb4lpenr {{ gpioalpen: {=bool:?}, gpioblpen: {=bool:?}, gpioclpen: {=bool:?}, gpiodlpen: {=bool:?}, gpioelpen: {=bool:?}, gpioflpen: {=bool:?}, gpioglpen: {=bool:?}, gpiohlpen: {=bool:?}, gpionlpen: {=bool:?}, gpioolpen: {=bool:?}, gpioplpen: {=bool:?}, gpioqlpen: {=bool:?}, pwrlpen: {=bool:?}, crclpen: {=bool:?} }}" , self . gpioalpen () , self . gpioblpen () , self . gpioclpen () , self . gpiodlpen () , self . gpioelpen () , self . gpioflpen () , self . gpioglpen () , self . gpiohlpen () , self . gpionlpen () , self . gpioolpen () , self . gpioplpen () , self . gpioqlpen () , self . pwrlpen () , self . crclpen ())
        }
    }
    #[doc = "RCC AHB4 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb4lpensr(pub u32);
    impl Ahb4lpensr {
        #[doc = "GPIOA sleep enable."]
        #[inline(always)]
        pub const fn gpioalpens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOA sleep enable."]
        #[inline(always)]
        pub fn set_gpioalpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "GPIOB sleep enable."]
        #[inline(always)]
        pub const fn gpioblpens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOB sleep enable."]
        #[inline(always)]
        pub fn set_gpioblpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "GPIOC sleep enable."]
        #[inline(always)]
        pub const fn gpioclpens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOC sleep enable."]
        #[inline(always)]
        pub fn set_gpioclpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GPIOD sleep enable."]
        #[inline(always)]
        pub const fn gpiodlpens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOD sleep enable."]
        #[inline(always)]
        pub fn set_gpiodlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "GPIOE sleep enable."]
        #[inline(always)]
        pub const fn gpioelpens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOE sleep enable."]
        #[inline(always)]
        pub fn set_gpioelpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "GPIOF sleep enable."]
        #[inline(always)]
        pub const fn gpioflpens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOF sleep enable."]
        #[inline(always)]
        pub fn set_gpioflpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "GPIOG sleep enable."]
        #[inline(always)]
        pub const fn gpioglpens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOG sleep enable."]
        #[inline(always)]
        pub fn set_gpioglpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "GPIOH sleep enable."]
        #[inline(always)]
        pub const fn gpiohlpens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOH sleep enable."]
        #[inline(always)]
        pub fn set_gpiohlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "GPION sleep enable."]
        #[inline(always)]
        pub const fn gpionlpens(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "GPION sleep enable."]
        #[inline(always)]
        pub fn set_gpionlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "GPIOO sleep enable."]
        #[inline(always)]
        pub const fn gpioolpens(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOO sleep enable."]
        #[inline(always)]
        pub fn set_gpioolpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "GPIOP sleep enable."]
        #[inline(always)]
        pub const fn gpioplpens(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOP sleep enable."]
        #[inline(always)]
        pub fn set_gpioplpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "GPIOQ sleep enable."]
        #[inline(always)]
        pub const fn gpioqlpens(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOQ sleep enable."]
        #[inline(always)]
        pub fn set_gpioqlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "PWR sleep enable."]
        #[inline(always)]
        pub const fn pwrlpens(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "PWR sleep enable."]
        #[inline(always)]
        pub fn set_pwrlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "CRC sleep enable."]
        #[inline(always)]
        pub const fn crclpens(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "CRC sleep enable."]
        #[inline(always)]
        pub fn set_crclpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Ahb4lpensr {
        #[inline(always)]
        fn default() -> Ahb4lpensr {
            Ahb4lpensr(0)
        }
    }
    impl core::fmt::Debug for Ahb4lpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb4lpensr")
                .field("gpioalpens", &self.gpioalpens())
                .field("gpioblpens", &self.gpioblpens())
                .field("gpioclpens", &self.gpioclpens())
                .field("gpiodlpens", &self.gpiodlpens())
                .field("gpioelpens", &self.gpioelpens())
                .field("gpioflpens", &self.gpioflpens())
                .field("gpioglpens", &self.gpioglpens())
                .field("gpiohlpens", &self.gpiohlpens())
                .field("gpionlpens", &self.gpionlpens())
                .field("gpioolpens", &self.gpioolpens())
                .field("gpioplpens", &self.gpioplpens())
                .field("gpioqlpens", &self.gpioqlpens())
                .field("pwrlpens", &self.pwrlpens())
                .field("crclpens", &self.crclpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb4lpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb4lpensr {{ gpioalpens: {=bool:?}, gpioblpens: {=bool:?}, gpioclpens: {=bool:?}, gpiodlpens: {=bool:?}, gpioelpens: {=bool:?}, gpioflpens: {=bool:?}, gpioglpens: {=bool:?}, gpiohlpens: {=bool:?}, gpionlpens: {=bool:?}, gpioolpens: {=bool:?}, gpioplpens: {=bool:?}, gpioqlpens: {=bool:?}, pwrlpens: {=bool:?}, crclpens: {=bool:?} }}" , self . gpioalpens () , self . gpioblpens () , self . gpioclpens () , self . gpiodlpens () , self . gpioelpens () , self . gpioflpens () , self . gpioglpens () , self . gpiohlpens () , self . gpionlpens () , self . gpioolpens () , self . gpioplpens () , self . gpioqlpens () , self . pwrlpens () , self . crclpens ())
        }
    }
    #[doc = "RCC AHB4 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb4rstcr(pub u32);
    impl Ahb4rstcr {
        #[doc = "GPIOA reset."]
        #[inline(always)]
        pub const fn gpioarstc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOA reset."]
        #[inline(always)]
        pub fn set_gpioarstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "GPIOB reset."]
        #[inline(always)]
        pub const fn gpiobrstc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOB reset."]
        #[inline(always)]
        pub fn set_gpiobrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "GPIOC reset."]
        #[inline(always)]
        pub const fn gpiocrstc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOC reset."]
        #[inline(always)]
        pub fn set_gpiocrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GPIOD reset."]
        #[inline(always)]
        pub const fn gpiodrstc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOD reset."]
        #[inline(always)]
        pub fn set_gpiodrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "GPIOE reset."]
        #[inline(always)]
        pub const fn gpioerstc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOE reset."]
        #[inline(always)]
        pub fn set_gpioerstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "GPIOF reset."]
        #[inline(always)]
        pub const fn gpiofrstc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOF reset."]
        #[inline(always)]
        pub fn set_gpiofrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "GPIOG reset."]
        #[inline(always)]
        pub const fn gpiogrstc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOG reset."]
        #[inline(always)]
        pub fn set_gpiogrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "GPIOH reset."]
        #[inline(always)]
        pub const fn gpiohrstc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOH reset."]
        #[inline(always)]
        pub fn set_gpiohrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "GPION reset."]
        #[inline(always)]
        pub const fn gpionrstc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "GPION reset."]
        #[inline(always)]
        pub fn set_gpionrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "GPIOO reset."]
        #[inline(always)]
        pub const fn gpioorstc(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOO reset."]
        #[inline(always)]
        pub fn set_gpioorstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "GPIOP reset."]
        #[inline(always)]
        pub const fn gpioprstc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOP reset."]
        #[inline(always)]
        pub fn set_gpioprstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "GPIOQ reset."]
        #[inline(always)]
        pub const fn gpioqrstc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOQ reset."]
        #[inline(always)]
        pub fn set_gpioqrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "PWR reset."]
        #[inline(always)]
        pub const fn pwrrstc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "PWR reset."]
        #[inline(always)]
        pub fn set_pwrrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "CRC reset."]
        #[inline(always)]
        pub const fn crcrstc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "CRC reset."]
        #[inline(always)]
        pub fn set_crcrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Ahb4rstcr {
        #[inline(always)]
        fn default() -> Ahb4rstcr {
            Ahb4rstcr(0)
        }
    }
    impl core::fmt::Debug for Ahb4rstcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb4rstcr")
                .field("gpioarstc", &self.gpioarstc())
                .field("gpiobrstc", &self.gpiobrstc())
                .field("gpiocrstc", &self.gpiocrstc())
                .field("gpiodrstc", &self.gpiodrstc())
                .field("gpioerstc", &self.gpioerstc())
                .field("gpiofrstc", &self.gpiofrstc())
                .field("gpiogrstc", &self.gpiogrstc())
                .field("gpiohrstc", &self.gpiohrstc())
                .field("gpionrstc", &self.gpionrstc())
                .field("gpioorstc", &self.gpioorstc())
                .field("gpioprstc", &self.gpioprstc())
                .field("gpioqrstc", &self.gpioqrstc())
                .field("pwrrstc", &self.pwrrstc())
                .field("crcrstc", &self.crcrstc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb4rstcr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb4rstcr {{ gpioarstc: {=bool:?}, gpiobrstc: {=bool:?}, gpiocrstc: {=bool:?}, gpiodrstc: {=bool:?}, gpioerstc: {=bool:?}, gpiofrstc: {=bool:?}, gpiogrstc: {=bool:?}, gpiohrstc: {=bool:?}, gpionrstc: {=bool:?}, gpioorstc: {=bool:?}, gpioprstc: {=bool:?}, gpioqrstc: {=bool:?}, pwrrstc: {=bool:?}, crcrstc: {=bool:?} }}" , self . gpioarstc () , self . gpiobrstc () , self . gpiocrstc () , self . gpiodrstc () , self . gpioerstc () , self . gpiofrstc () , self . gpiogrstc () , self . gpiohrstc () , self . gpionrstc () , self . gpioorstc () , self . gpioprstc () , self . gpioqrstc () , self . pwrrstc () , self . crcrstc ())
        }
    }
    #[doc = "RCC AHB4 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb4rstr(pub u32);
    impl Ahb4rstr {
        #[doc = "GPIOA reset."]
        #[inline(always)]
        pub const fn gpioarst(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOA reset."]
        #[inline(always)]
        pub fn set_gpioarst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "GPIOB reset."]
        #[inline(always)]
        pub const fn gpiobrst(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOB reset."]
        #[inline(always)]
        pub fn set_gpiobrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "GPIOC reset."]
        #[inline(always)]
        pub const fn gpiocrst(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOC reset."]
        #[inline(always)]
        pub fn set_gpiocrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GPIOD reset."]
        #[inline(always)]
        pub const fn gpiodrst(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOD reset."]
        #[inline(always)]
        pub fn set_gpiodrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "GPIOE reset."]
        #[inline(always)]
        pub const fn gpioerst(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOE reset."]
        #[inline(always)]
        pub fn set_gpioerst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "GPIOF reset."]
        #[inline(always)]
        pub const fn gpiofrst(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOF reset."]
        #[inline(always)]
        pub fn set_gpiofrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "GPIOG reset."]
        #[inline(always)]
        pub const fn gpiogrst(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOG reset."]
        #[inline(always)]
        pub fn set_gpiogrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "GPIOH reset."]
        #[inline(always)]
        pub const fn gpiohrst(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOH reset."]
        #[inline(always)]
        pub fn set_gpiohrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "GPION reset."]
        #[inline(always)]
        pub const fn gpionrst(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "GPION reset."]
        #[inline(always)]
        pub fn set_gpionrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "GPIOO reset."]
        #[inline(always)]
        pub const fn gpioorst(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOO reset."]
        #[inline(always)]
        pub fn set_gpioorst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "GPIOP reset."]
        #[inline(always)]
        pub const fn gpioprst(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOP reset."]
        #[inline(always)]
        pub fn set_gpioprst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "GPIOQ reset."]
        #[inline(always)]
        pub const fn gpioqrst(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOQ reset."]
        #[inline(always)]
        pub fn set_gpioqrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "PWR reset."]
        #[inline(always)]
        pub const fn pwrrst(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "PWR reset."]
        #[inline(always)]
        pub fn set_pwrrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "CRC reset."]
        #[inline(always)]
        pub const fn crcrst(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "CRC reset."]
        #[inline(always)]
        pub fn set_crcrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Ahb4rstr {
        #[inline(always)]
        fn default() -> Ahb4rstr {
            Ahb4rstr(0)
        }
    }
    impl core::fmt::Debug for Ahb4rstr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb4rstr")
                .field("gpioarst", &self.gpioarst())
                .field("gpiobrst", &self.gpiobrst())
                .field("gpiocrst", &self.gpiocrst())
                .field("gpiodrst", &self.gpiodrst())
                .field("gpioerst", &self.gpioerst())
                .field("gpiofrst", &self.gpiofrst())
                .field("gpiogrst", &self.gpiogrst())
                .field("gpiohrst", &self.gpiohrst())
                .field("gpionrst", &self.gpionrst())
                .field("gpioorst", &self.gpioorst())
                .field("gpioprst", &self.gpioprst())
                .field("gpioqrst", &self.gpioqrst())
                .field("pwrrst", &self.pwrrst())
                .field("crcrst", &self.crcrst())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb4rstr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb4rstr {{ gpioarst: {=bool:?}, gpiobrst: {=bool:?}, gpiocrst: {=bool:?}, gpiodrst: {=bool:?}, gpioerst: {=bool:?}, gpiofrst: {=bool:?}, gpiogrst: {=bool:?}, gpiohrst: {=bool:?}, gpionrst: {=bool:?}, gpioorst: {=bool:?}, gpioprst: {=bool:?}, gpioqrst: {=bool:?}, pwrrst: {=bool:?}, crcrst: {=bool:?} }}" , self . gpioarst () , self . gpiobrst () , self . gpiocrst () , self . gpiodrst () , self . gpioerst () , self . gpiofrst () , self . gpiogrst () , self . gpiohrst () , self . gpionrst () , self . gpioorst () , self . gpioprst () , self . gpioqrst () , self . pwrrst () , self . crcrst ())
        }
    }
    #[doc = "RCC AHB4 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb4rstsr(pub u32);
    impl Ahb4rstsr {
        #[doc = "GPIOA reset."]
        #[inline(always)]
        pub const fn gpioarsts(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOA reset."]
        #[inline(always)]
        pub fn set_gpioarsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "GPIOB reset."]
        #[inline(always)]
        pub const fn gpiobrsts(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOB reset."]
        #[inline(always)]
        pub fn set_gpiobrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "GPIOC reset."]
        #[inline(always)]
        pub const fn gpiocrsts(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOC reset."]
        #[inline(always)]
        pub fn set_gpiocrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GPIOD reset."]
        #[inline(always)]
        pub const fn gpiodrsts(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOD reset."]
        #[inline(always)]
        pub fn set_gpiodrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "GPIOE reset."]
        #[inline(always)]
        pub const fn gpioersts(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOE reset."]
        #[inline(always)]
        pub fn set_gpioersts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "GPIOF reset."]
        #[inline(always)]
        pub const fn gpiofrsts(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOF reset."]
        #[inline(always)]
        pub fn set_gpiofrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "GPIOG reset."]
        #[inline(always)]
        pub const fn gpiogrsts(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOG reset."]
        #[inline(always)]
        pub fn set_gpiogrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "GPIOH reset."]
        #[inline(always)]
        pub const fn gpiohrsts(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOH reset."]
        #[inline(always)]
        pub fn set_gpiohrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "GPION reset."]
        #[inline(always)]
        pub const fn gpionrsts(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "GPION reset."]
        #[inline(always)]
        pub fn set_gpionrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "GPIOO reset."]
        #[inline(always)]
        pub const fn gpioorsts(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOO reset."]
        #[inline(always)]
        pub fn set_gpioorsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "GPIOP reset."]
        #[inline(always)]
        pub const fn gpioprsts(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOP reset."]
        #[inline(always)]
        pub fn set_gpioprsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "GPIOQ reset."]
        #[inline(always)]
        pub const fn gpioqrsts(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "GPIOQ reset."]
        #[inline(always)]
        pub fn set_gpioqrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "PWR reset."]
        #[inline(always)]
        pub const fn pwrrsts(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "PWR reset."]
        #[inline(always)]
        pub fn set_pwrrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "CRC reset."]
        #[inline(always)]
        pub const fn crcrsts(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "CRC reset."]
        #[inline(always)]
        pub fn set_crcrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Ahb4rstsr {
        #[inline(always)]
        fn default() -> Ahb4rstsr {
            Ahb4rstsr(0)
        }
    }
    impl core::fmt::Debug for Ahb4rstsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb4rstsr")
                .field("gpioarsts", &self.gpioarsts())
                .field("gpiobrsts", &self.gpiobrsts())
                .field("gpiocrsts", &self.gpiocrsts())
                .field("gpiodrsts", &self.gpiodrsts())
                .field("gpioersts", &self.gpioersts())
                .field("gpiofrsts", &self.gpiofrsts())
                .field("gpiogrsts", &self.gpiogrsts())
                .field("gpiohrsts", &self.gpiohrsts())
                .field("gpionrsts", &self.gpionrsts())
                .field("gpioorsts", &self.gpioorsts())
                .field("gpioprsts", &self.gpioprsts())
                .field("gpioqrsts", &self.gpioqrsts())
                .field("pwrrsts", &self.pwrrsts())
                .field("crcrsts", &self.crcrsts())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb4rstsr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb4rstsr {{ gpioarsts: {=bool:?}, gpiobrsts: {=bool:?}, gpiocrsts: {=bool:?}, gpiodrsts: {=bool:?}, gpioersts: {=bool:?}, gpiofrsts: {=bool:?}, gpiogrsts: {=bool:?}, gpiohrsts: {=bool:?}, gpionrsts: {=bool:?}, gpioorsts: {=bool:?}, gpioprsts: {=bool:?}, gpioqrsts: {=bool:?}, pwrrsts: {=bool:?}, crcrsts: {=bool:?} }}" , self . gpioarsts () , self . gpiobrsts () , self . gpiocrsts () , self . gpiodrsts () , self . gpioersts () , self . gpiofrsts () , self . gpiogrsts () , self . gpiohrsts () , self . gpionrsts () , self . gpioorsts () , self . gpioprsts () , self . gpioqrsts () , self . pwrrsts () , self . crcrsts ())
        }
    }
    #[doc = "RCC AHB5 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb5encr(pub u32);
    impl Ahb5encr {
        #[doc = "HPDMA1 enable."]
        #[inline(always)]
        pub const fn hpdma1enc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "HPDMA1 enable."]
        #[inline(always)]
        pub fn set_hpdma1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "DMA2D enable."]
        #[inline(always)]
        pub const fn dma2denc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "DMA2D enable."]
        #[inline(always)]
        pub fn set_dma2denc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "JPEG enable."]
        #[inline(always)]
        pub const fn jpegenc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "JPEG enable."]
        #[inline(always)]
        pub fn set_jpegenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "FMC enable."]
        #[inline(always)]
        pub const fn fmcenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "FMC enable."]
        #[inline(always)]
        pub fn set_fmcenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "XSPI1 enable."]
        #[inline(always)]
        pub const fn xspi1enc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI1 enable."]
        #[inline(always)]
        pub fn set_xspi1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "PSSI enable."]
        #[inline(always)]
        pub const fn pssienc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PSSI enable."]
        #[inline(always)]
        pub fn set_pssienc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "SDMMC2 enable."]
        #[inline(always)]
        pub const fn sdmmc2enc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC2 enable."]
        #[inline(always)]
        pub fn set_sdmmc2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SDMMC1 enable."]
        #[inline(always)]
        pub const fn sdmmc1enc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC1 enable."]
        #[inline(always)]
        pub fn set_sdmmc1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "XSPI2 enable."]
        #[inline(always)]
        pub const fn xspi2enc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI2 enable."]
        #[inline(always)]
        pub fn set_xspi2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "XSPIM enable."]
        #[inline(always)]
        pub const fn xspimenc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIM enable."]
        #[inline(always)]
        pub fn set_xspimenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "MCE1 enable."]
        #[inline(always)]
        pub const fn mce1enc(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "MCE1 enable."]
        #[inline(always)]
        pub fn set_mce1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "MCE2 enable."]
        #[inline(always)]
        pub const fn mce2enc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "MCE2 enable."]
        #[inline(always)]
        pub fn set_mce2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "MCE3 enable."]
        #[inline(always)]
        pub const fn mce3enc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MCE3 enable."]
        #[inline(always)]
        pub fn set_mce3enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "XSPI3 enable."]
        #[inline(always)]
        pub const fn xspi3enc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI3 enable."]
        #[inline(always)]
        pub fn set_xspi3enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "MCE4 enable."]
        #[inline(always)]
        pub const fn mce4enc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "MCE4 enable."]
        #[inline(always)]
        pub fn set_mce4enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "GFXMMU enable."]
        #[inline(always)]
        pub const fn gfxmmuenc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "GFXMMU enable."]
        #[inline(always)]
        pub fn set_gfxmmuenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "GPU enable."]
        #[inline(always)]
        pub const fn gpuenc(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "GPU enable."]
        #[inline(always)]
        pub fn set_gpuenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "ETH1MAC enable."]
        #[inline(always)]
        pub const fn eth1macenc(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1MAC enable."]
        #[inline(always)]
        pub fn set_eth1macenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "ETH1TX enable."]
        #[inline(always)]
        pub const fn eth1txenc(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1TX enable."]
        #[inline(always)]
        pub fn set_eth1txenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "ETH1RX enable."]
        #[inline(always)]
        pub const fn eth1rxenc(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1RX enable."]
        #[inline(always)]
        pub fn set_eth1rxenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "ETH1 enable."]
        #[inline(always)]
        pub const fn eth1enc(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1 enable."]
        #[inline(always)]
        pub fn set_eth1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "OTG1 enable."]
        #[inline(always)]
        pub const fn otg1enc(&self) -> bool {
            let val = (self.0 >> 26usize) & 0x01;
            val != 0
        }
        #[doc = "OTG1 enable."]
        #[inline(always)]
        pub fn set_otg1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
        }
        #[doc = "OTGPHY1 enable."]
        #[inline(always)]
        pub const fn otgphy1enc(&self) -> bool {
            let val = (self.0 >> 27usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY1 enable."]
        #[inline(always)]
        pub fn set_otgphy1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
        }
        #[doc = "OTGPHY2 enable."]
        #[inline(always)]
        pub const fn otgphy2enc(&self) -> bool {
            let val = (self.0 >> 28usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY2 enable."]
        #[inline(always)]
        pub fn set_otgphy2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
        }
        #[doc = "OTG2 enable."]
        #[inline(always)]
        pub const fn otg2enc(&self) -> bool {
            let val = (self.0 >> 29usize) & 0x01;
            val != 0
        }
        #[doc = "OTG2 enable."]
        #[inline(always)]
        pub fn set_otg2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
        }
        #[doc = "NPUCACHE enable."]
        #[inline(always)]
        pub const fn npucacheenc(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHE enable."]
        #[inline(always)]
        pub fn set_npucacheenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "NPU enable."]
        #[inline(always)]
        pub const fn npuenc(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "NPU enable."]
        #[inline(always)]
        pub fn set_npuenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Ahb5encr {
        #[inline(always)]
        fn default() -> Ahb5encr {
            Ahb5encr(0)
        }
    }
    impl core::fmt::Debug for Ahb5encr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb5encr")
                .field("hpdma1enc", &self.hpdma1enc())
                .field("dma2denc", &self.dma2denc())
                .field("jpegenc", &self.jpegenc())
                .field("fmcenc", &self.fmcenc())
                .field("xspi1enc", &self.xspi1enc())
                .field("pssienc", &self.pssienc())
                .field("sdmmc2enc", &self.sdmmc2enc())
                .field("sdmmc1enc", &self.sdmmc1enc())
                .field("xspi2enc", &self.xspi2enc())
                .field("xspimenc", &self.xspimenc())
                .field("mce1enc", &self.mce1enc())
                .field("mce2enc", &self.mce2enc())
                .field("mce3enc", &self.mce3enc())
                .field("xspi3enc", &self.xspi3enc())
                .field("mce4enc", &self.mce4enc())
                .field("gfxmmuenc", &self.gfxmmuenc())
                .field("gpuenc", &self.gpuenc())
                .field("eth1macenc", &self.eth1macenc())
                .field("eth1txenc", &self.eth1txenc())
                .field("eth1rxenc", &self.eth1rxenc())
                .field("eth1enc", &self.eth1enc())
                .field("otg1enc", &self.otg1enc())
                .field("otgphy1enc", &self.otgphy1enc())
                .field("otgphy2enc", &self.otgphy2enc())
                .field("otg2enc", &self.otg2enc())
                .field("npucacheenc", &self.npucacheenc())
                .field("npuenc", &self.npuenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb5encr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb5encr {{ hpdma1enc: {=bool:?}, dma2denc: {=bool:?}, jpegenc: {=bool:?}, fmcenc: {=bool:?}, xspi1enc: {=bool:?}, pssienc: {=bool:?}, sdmmc2enc: {=bool:?}, sdmmc1enc: {=bool:?}, xspi2enc: {=bool:?}, xspimenc: {=bool:?}, mce1enc: {=bool:?}, mce2enc: {=bool:?}, mce3enc: {=bool:?}, xspi3enc: {=bool:?}, mce4enc: {=bool:?}, gfxmmuenc: {=bool:?}, gpuenc: {=bool:?}, eth1macenc: {=bool:?}, eth1txenc: {=bool:?}, eth1rxenc: {=bool:?}, eth1enc: {=bool:?}, otg1enc: {=bool:?}, otgphy1enc: {=bool:?}, otgphy2enc: {=bool:?}, otg2enc: {=bool:?}, npucacheenc: {=bool:?}, npuenc: {=bool:?} }}" , self . hpdma1enc () , self . dma2denc () , self . jpegenc () , self . fmcenc () , self . xspi1enc () , self . pssienc () , self . sdmmc2enc () , self . sdmmc1enc () , self . xspi2enc () , self . xspimenc () , self . mce1enc () , self . mce2enc () , self . mce3enc () , self . xspi3enc () , self . mce4enc () , self . gfxmmuenc () , self . gpuenc () , self . eth1macenc () , self . eth1txenc () , self . eth1rxenc () , self . eth1enc () , self . otg1enc () , self . otgphy1enc () , self . otgphy2enc () , self . otg2enc () , self . npucacheenc () , self . npuenc ())
        }
    }
    #[doc = "RCC AHB5 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb5enr(pub u32);
    impl Ahb5enr {
        #[doc = "HPDMA1 enable."]
        #[inline(always)]
        pub const fn hpdma1en(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "HPDMA1 enable."]
        #[inline(always)]
        pub fn set_hpdma1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "DMA2D enable."]
        #[inline(always)]
        pub const fn dma2den(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "DMA2D enable."]
        #[inline(always)]
        pub fn set_dma2den(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "JPEG enable."]
        #[inline(always)]
        pub const fn jpegen(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "JPEG enable."]
        #[inline(always)]
        pub fn set_jpegen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "FMC enable."]
        #[inline(always)]
        pub const fn fmcen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "FMC enable."]
        #[inline(always)]
        pub fn set_fmcen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "XSPI1 enable."]
        #[inline(always)]
        pub const fn xspi1en(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI1 enable."]
        #[inline(always)]
        pub fn set_xspi1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "PSSI enable."]
        #[inline(always)]
        pub const fn pssien(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PSSI enable."]
        #[inline(always)]
        pub fn set_pssien(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "SDMMC2 enable."]
        #[inline(always)]
        pub const fn sdmmc2en(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC2 enable."]
        #[inline(always)]
        pub fn set_sdmmc2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SDMMC1 enable."]
        #[inline(always)]
        pub const fn sdmmc1en(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC1 enable."]
        #[inline(always)]
        pub fn set_sdmmc1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "XSPI2 enable."]
        #[inline(always)]
        pub const fn xspi2en(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI2 enable."]
        #[inline(always)]
        pub fn set_xspi2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "XSPIM enable."]
        #[inline(always)]
        pub const fn xspimen(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIM enable."]
        #[inline(always)]
        pub fn set_xspimen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "MCE1 enable."]
        #[inline(always)]
        pub const fn mce1en(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "MCE1 enable."]
        #[inline(always)]
        pub fn set_mce1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "MCE2 enable."]
        #[inline(always)]
        pub const fn mce2en(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "MCE2 enable."]
        #[inline(always)]
        pub fn set_mce2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "MCE3 enable."]
        #[inline(always)]
        pub const fn mce3en(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MCE3 enable."]
        #[inline(always)]
        pub fn set_mce3en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "XSPI3 enable."]
        #[inline(always)]
        pub const fn xspi3en(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI3 enable."]
        #[inline(always)]
        pub fn set_xspi3en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "MCE4 enable."]
        #[inline(always)]
        pub const fn mce4en(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "MCE4 enable."]
        #[inline(always)]
        pub fn set_mce4en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "GFXMMU enable."]
        #[inline(always)]
        pub const fn gfxmmuen(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "GFXMMU enable."]
        #[inline(always)]
        pub fn set_gfxmmuen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "GPU enable."]
        #[inline(always)]
        pub const fn gpuen(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "GPU enable."]
        #[inline(always)]
        pub fn set_gpuen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "ETH1MAC enable."]
        #[inline(always)]
        pub const fn eth1macen(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1MAC enable."]
        #[inline(always)]
        pub fn set_eth1macen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "ETH1TX enable."]
        #[inline(always)]
        pub const fn eth1txen(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1TX enable."]
        #[inline(always)]
        pub fn set_eth1txen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "ETH1RX enable."]
        #[inline(always)]
        pub const fn eth1rxen(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1RX enable."]
        #[inline(always)]
        pub fn set_eth1rxen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "ETH1 enable."]
        #[inline(always)]
        pub const fn eth1en(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1 enable."]
        #[inline(always)]
        pub fn set_eth1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "OTG1 enable."]
        #[inline(always)]
        pub const fn otg1en(&self) -> bool {
            let val = (self.0 >> 26usize) & 0x01;
            val != 0
        }
        #[doc = "OTG1 enable."]
        #[inline(always)]
        pub fn set_otg1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
        }
        #[doc = "OTGPHY1 enable."]
        #[inline(always)]
        pub const fn otgphy1en(&self) -> bool {
            let val = (self.0 >> 27usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY1 enable."]
        #[inline(always)]
        pub fn set_otgphy1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
        }
        #[doc = "OTGPHY2 enable."]
        #[inline(always)]
        pub const fn otgphy2en(&self) -> bool {
            let val = (self.0 >> 28usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY2 enable."]
        #[inline(always)]
        pub fn set_otgphy2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
        }
        #[doc = "OTG2 enable."]
        #[inline(always)]
        pub const fn otg2en(&self) -> bool {
            let val = (self.0 >> 29usize) & 0x01;
            val != 0
        }
        #[doc = "OTG2 enable."]
        #[inline(always)]
        pub fn set_otg2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
        }
        #[doc = "NPUCACHE enable."]
        #[inline(always)]
        pub const fn npucacheen(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHE enable."]
        #[inline(always)]
        pub fn set_npucacheen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "NPU enable."]
        #[inline(always)]
        pub const fn npuen(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "NPU enable."]
        #[inline(always)]
        pub fn set_npuen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Ahb5enr {
        #[inline(always)]
        fn default() -> Ahb5enr {
            Ahb5enr(0)
        }
    }
    impl core::fmt::Debug for Ahb5enr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb5enr")
                .field("hpdma1en", &self.hpdma1en())
                .field("dma2den", &self.dma2den())
                .field("jpegen", &self.jpegen())
                .field("fmcen", &self.fmcen())
                .field("xspi1en", &self.xspi1en())
                .field("pssien", &self.pssien())
                .field("sdmmc2en", &self.sdmmc2en())
                .field("sdmmc1en", &self.sdmmc1en())
                .field("xspi2en", &self.xspi2en())
                .field("xspimen", &self.xspimen())
                .field("mce1en", &self.mce1en())
                .field("mce2en", &self.mce2en())
                .field("mce3en", &self.mce3en())
                .field("xspi3en", &self.xspi3en())
                .field("mce4en", &self.mce4en())
                .field("gfxmmuen", &self.gfxmmuen())
                .field("gpuen", &self.gpuen())
                .field("eth1macen", &self.eth1macen())
                .field("eth1txen", &self.eth1txen())
                .field("eth1rxen", &self.eth1rxen())
                .field("eth1en", &self.eth1en())
                .field("otg1en", &self.otg1en())
                .field("otgphy1en", &self.otgphy1en())
                .field("otgphy2en", &self.otgphy2en())
                .field("otg2en", &self.otg2en())
                .field("npucacheen", &self.npucacheen())
                .field("npuen", &self.npuen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb5enr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb5enr {{ hpdma1en: {=bool:?}, dma2den: {=bool:?}, jpegen: {=bool:?}, fmcen: {=bool:?}, xspi1en: {=bool:?}, pssien: {=bool:?}, sdmmc2en: {=bool:?}, sdmmc1en: {=bool:?}, xspi2en: {=bool:?}, xspimen: {=bool:?}, mce1en: {=bool:?}, mce2en: {=bool:?}, mce3en: {=bool:?}, xspi3en: {=bool:?}, mce4en: {=bool:?}, gfxmmuen: {=bool:?}, gpuen: {=bool:?}, eth1macen: {=bool:?}, eth1txen: {=bool:?}, eth1rxen: {=bool:?}, eth1en: {=bool:?}, otg1en: {=bool:?}, otgphy1en: {=bool:?}, otgphy2en: {=bool:?}, otg2en: {=bool:?}, npucacheen: {=bool:?}, npuen: {=bool:?} }}" , self . hpdma1en () , self . dma2den () , self . jpegen () , self . fmcen () , self . xspi1en () , self . pssien () , self . sdmmc2en () , self . sdmmc1en () , self . xspi2en () , self . xspimen () , self . mce1en () , self . mce2en () , self . mce3en () , self . xspi3en () , self . mce4en () , self . gfxmmuen () , self . gpuen () , self . eth1macen () , self . eth1txen () , self . eth1rxen () , self . eth1en () , self . otg1en () , self . otgphy1en () , self . otgphy2en () , self . otg2en () , self . npucacheen () , self . npuen ())
        }
    }
    #[doc = "RCC AHB5 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb5ensr(pub u32);
    impl Ahb5ensr {
        #[doc = "HPDMA1 enable."]
        #[inline(always)]
        pub const fn hpdma1ens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "HPDMA1 enable."]
        #[inline(always)]
        pub fn set_hpdma1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "DMA2D enable."]
        #[inline(always)]
        pub const fn dma2dens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "DMA2D enable."]
        #[inline(always)]
        pub fn set_dma2dens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "JPEG enable."]
        #[inline(always)]
        pub const fn jpegens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "JPEG enable."]
        #[inline(always)]
        pub fn set_jpegens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "FMC enable."]
        #[inline(always)]
        pub const fn fmcens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "FMC enable."]
        #[inline(always)]
        pub fn set_fmcens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "XSPI1 enable."]
        #[inline(always)]
        pub const fn xspi1ens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI1 enable."]
        #[inline(always)]
        pub fn set_xspi1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "PSSI enable."]
        #[inline(always)]
        pub const fn pssiens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PSSI enable."]
        #[inline(always)]
        pub fn set_pssiens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "SDMMC2 enable."]
        #[inline(always)]
        pub const fn sdmmc2ens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC2 enable."]
        #[inline(always)]
        pub fn set_sdmmc2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SDMMC1 enable."]
        #[inline(always)]
        pub const fn sdmmc1ens(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC1 enable."]
        #[inline(always)]
        pub fn set_sdmmc1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "XSPI2 enable."]
        #[inline(always)]
        pub const fn xspi2ens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI2 enable."]
        #[inline(always)]
        pub fn set_xspi2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "XSPIM enable."]
        #[inline(always)]
        pub const fn xspimens(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIM enable."]
        #[inline(always)]
        pub fn set_xspimens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "MCE1 enable."]
        #[inline(always)]
        pub const fn mce1ens(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "MCE1 enable."]
        #[inline(always)]
        pub fn set_mce1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "MCE2 enable."]
        #[inline(always)]
        pub const fn mce2ens(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "MCE2 enable."]
        #[inline(always)]
        pub fn set_mce2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "MCE3 enable."]
        #[inline(always)]
        pub const fn mce3ens(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MCE3 enable."]
        #[inline(always)]
        pub fn set_mce3ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "XSPI3 enable."]
        #[inline(always)]
        pub const fn xspi3ens(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI3 enable."]
        #[inline(always)]
        pub fn set_xspi3ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "MCE4 enable."]
        #[inline(always)]
        pub const fn mce4ens(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "MCE4 enable."]
        #[inline(always)]
        pub fn set_mce4ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "GFXMMU enable."]
        #[inline(always)]
        pub const fn gfxmmuens(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "GFXMMU enable."]
        #[inline(always)]
        pub fn set_gfxmmuens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "GPU enable."]
        #[inline(always)]
        pub const fn gpuens(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "GPU enable."]
        #[inline(always)]
        pub fn set_gpuens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "ETH1MAC enable."]
        #[inline(always)]
        pub const fn eth1macens(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1MAC enable."]
        #[inline(always)]
        pub fn set_eth1macens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "ETH1TX enable."]
        #[inline(always)]
        pub const fn eth1txens(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1TX enable."]
        #[inline(always)]
        pub fn set_eth1txens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "ETH1RX enable."]
        #[inline(always)]
        pub const fn eth1rxens(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1RX enable."]
        #[inline(always)]
        pub fn set_eth1rxens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "ETH1 enable."]
        #[inline(always)]
        pub const fn eth1ens(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1 enable."]
        #[inline(always)]
        pub fn set_eth1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "OTG1 enable."]
        #[inline(always)]
        pub const fn otg1ens(&self) -> bool {
            let val = (self.0 >> 26usize) & 0x01;
            val != 0
        }
        #[doc = "OTG1 enable."]
        #[inline(always)]
        pub fn set_otg1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
        }
        #[doc = "OTGPHY1 enable."]
        #[inline(always)]
        pub const fn otgphy1ens(&self) -> bool {
            let val = (self.0 >> 27usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY1 enable."]
        #[inline(always)]
        pub fn set_otgphy1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
        }
        #[doc = "OTGPHY2 enable."]
        #[inline(always)]
        pub const fn otgphy2ens(&self) -> bool {
            let val = (self.0 >> 28usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY2 enable."]
        #[inline(always)]
        pub fn set_otgphy2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
        }
        #[doc = "OTG2 enable."]
        #[inline(always)]
        pub const fn otg2ens(&self) -> bool {
            let val = (self.0 >> 29usize) & 0x01;
            val != 0
        }
        #[doc = "OTG2 enable."]
        #[inline(always)]
        pub fn set_otg2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
        }
        #[doc = "NPUCACHE enable."]
        #[inline(always)]
        pub const fn npucacheens(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHE enable."]
        #[inline(always)]
        pub fn set_npucacheens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "NPU enable."]
        #[inline(always)]
        pub const fn npuens(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "NPU enable."]
        #[inline(always)]
        pub fn set_npuens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Ahb5ensr {
        #[inline(always)]
        fn default() -> Ahb5ensr {
            Ahb5ensr(0)
        }
    }
    impl core::fmt::Debug for Ahb5ensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb5ensr")
                .field("hpdma1ens", &self.hpdma1ens())
                .field("dma2dens", &self.dma2dens())
                .field("jpegens", &self.jpegens())
                .field("fmcens", &self.fmcens())
                .field("xspi1ens", &self.xspi1ens())
                .field("pssiens", &self.pssiens())
                .field("sdmmc2ens", &self.sdmmc2ens())
                .field("sdmmc1ens", &self.sdmmc1ens())
                .field("xspi2ens", &self.xspi2ens())
                .field("xspimens", &self.xspimens())
                .field("mce1ens", &self.mce1ens())
                .field("mce2ens", &self.mce2ens())
                .field("mce3ens", &self.mce3ens())
                .field("xspi3ens", &self.xspi3ens())
                .field("mce4ens", &self.mce4ens())
                .field("gfxmmuens", &self.gfxmmuens())
                .field("gpuens", &self.gpuens())
                .field("eth1macens", &self.eth1macens())
                .field("eth1txens", &self.eth1txens())
                .field("eth1rxens", &self.eth1rxens())
                .field("eth1ens", &self.eth1ens())
                .field("otg1ens", &self.otg1ens())
                .field("otgphy1ens", &self.otgphy1ens())
                .field("otgphy2ens", &self.otgphy2ens())
                .field("otg2ens", &self.otg2ens())
                .field("npucacheens", &self.npucacheens())
                .field("npuens", &self.npuens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb5ensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb5ensr {{ hpdma1ens: {=bool:?}, dma2dens: {=bool:?}, jpegens: {=bool:?}, fmcens: {=bool:?}, xspi1ens: {=bool:?}, pssiens: {=bool:?}, sdmmc2ens: {=bool:?}, sdmmc1ens: {=bool:?}, xspi2ens: {=bool:?}, xspimens: {=bool:?}, mce1ens: {=bool:?}, mce2ens: {=bool:?}, mce3ens: {=bool:?}, xspi3ens: {=bool:?}, mce4ens: {=bool:?}, gfxmmuens: {=bool:?}, gpuens: {=bool:?}, eth1macens: {=bool:?}, eth1txens: {=bool:?}, eth1rxens: {=bool:?}, eth1ens: {=bool:?}, otg1ens: {=bool:?}, otgphy1ens: {=bool:?}, otgphy2ens: {=bool:?}, otg2ens: {=bool:?}, npucacheens: {=bool:?}, npuens: {=bool:?} }}" , self . hpdma1ens () , self . dma2dens () , self . jpegens () , self . fmcens () , self . xspi1ens () , self . pssiens () , self . sdmmc2ens () , self . sdmmc1ens () , self . xspi2ens () , self . xspimens () , self . mce1ens () , self . mce2ens () , self . mce3ens () , self . xspi3ens () , self . mce4ens () , self . gfxmmuens () , self . gpuens () , self . eth1macens () , self . eth1txens () , self . eth1rxens () , self . eth1ens () , self . otg1ens () , self . otgphy1ens () , self . otgphy2ens () , self . otg2ens () , self . npucacheens () , self . npuens ())
        }
    }
    #[doc = "RCC AHB5 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb5lpencr(pub u32);
    impl Ahb5lpencr {
        #[doc = "HPDMA1 sleep enable."]
        #[inline(always)]
        pub const fn hpdma1lpenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "HPDMA1 sleep enable."]
        #[inline(always)]
        pub fn set_hpdma1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "DMA2D sleep enable."]
        #[inline(always)]
        pub const fn dma2dlpenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "DMA2D sleep enable."]
        #[inline(always)]
        pub fn set_dma2dlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "JPEG sleep enable."]
        #[inline(always)]
        pub const fn jpeglpenc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "JPEG sleep enable."]
        #[inline(always)]
        pub fn set_jpeglpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "FMC sleep enable."]
        #[inline(always)]
        pub const fn fmclpenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "FMC sleep enable."]
        #[inline(always)]
        pub fn set_fmclpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "XSPI1 sleep enable."]
        #[inline(always)]
        pub const fn xspi1lpenc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI1 sleep enable."]
        #[inline(always)]
        pub fn set_xspi1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "PSSI sleep enable."]
        #[inline(always)]
        pub const fn pssilpenc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PSSI sleep enable."]
        #[inline(always)]
        pub fn set_pssilpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "SDMMC2 sleep enable."]
        #[inline(always)]
        pub const fn sdmmc2lpenc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC2 sleep enable."]
        #[inline(always)]
        pub fn set_sdmmc2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SDMMC1 sleep enable."]
        #[inline(always)]
        pub const fn sdmmc1lpenc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC1 sleep enable."]
        #[inline(always)]
        pub fn set_sdmmc1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "XSPI2 sleep enable."]
        #[inline(always)]
        pub const fn xspi2lpenc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI2 sleep enable."]
        #[inline(always)]
        pub fn set_xspi2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "XSPIM sleep enable."]
        #[inline(always)]
        pub const fn xspimlpenc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIM sleep enable."]
        #[inline(always)]
        pub fn set_xspimlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "MCE1 sleep enable."]
        #[inline(always)]
        pub const fn mce1lpenc(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "MCE1 sleep enable."]
        #[inline(always)]
        pub fn set_mce1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "MCE2 sleep enable."]
        #[inline(always)]
        pub const fn mce2lpenc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "MCE2 sleep enable."]
        #[inline(always)]
        pub fn set_mce2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "MCE3 sleep enable."]
        #[inline(always)]
        pub const fn mce3lpenc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MCE3 sleep enable."]
        #[inline(always)]
        pub fn set_mce3lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "XSPI3 sleep enable."]
        #[inline(always)]
        pub const fn xspi3lpenc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI3 sleep enable."]
        #[inline(always)]
        pub fn set_xspi3lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "MCE4 sleep enable."]
        #[inline(always)]
        pub const fn mce4lpenc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "MCE4 sleep enable."]
        #[inline(always)]
        pub fn set_mce4lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "GFXMMU sleep enable."]
        #[inline(always)]
        pub const fn gfxmmulpenc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "GFXMMU sleep enable."]
        #[inline(always)]
        pub fn set_gfxmmulpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "GPU sleep enable."]
        #[inline(always)]
        pub const fn gpulpenc(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "GPU sleep enable."]
        #[inline(always)]
        pub fn set_gpulpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "ETH1MAC sleep enable."]
        #[inline(always)]
        pub const fn eth1maclpenc(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1MAC sleep enable."]
        #[inline(always)]
        pub fn set_eth1maclpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "ETH1TX sleep enable."]
        #[inline(always)]
        pub const fn eth1txlpenc(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1TX sleep enable."]
        #[inline(always)]
        pub fn set_eth1txlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "ETH1RX sleep enable."]
        #[inline(always)]
        pub const fn eth1rxlpenc(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1RX sleep enable."]
        #[inline(always)]
        pub fn set_eth1rxlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "ETH1 sleep enable."]
        #[inline(always)]
        pub const fn eth1lpenc(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1 sleep enable."]
        #[inline(always)]
        pub fn set_eth1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "OTG1 sleep enable."]
        #[inline(always)]
        pub const fn otg1lpenc(&self) -> bool {
            let val = (self.0 >> 26usize) & 0x01;
            val != 0
        }
        #[doc = "OTG1 sleep enable."]
        #[inline(always)]
        pub fn set_otg1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
        }
        #[doc = "OTGPHY1 sleep enable."]
        #[inline(always)]
        pub const fn otgphy1lpenc(&self) -> bool {
            let val = (self.0 >> 27usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY1 sleep enable."]
        #[inline(always)]
        pub fn set_otgphy1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
        }
        #[doc = "OTGPHY2 sleep enable."]
        #[inline(always)]
        pub const fn otgphy2lpenc(&self) -> bool {
            let val = (self.0 >> 28usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY2 sleep enable."]
        #[inline(always)]
        pub fn set_otgphy2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
        }
        #[doc = "OTG2 sleep enable."]
        #[inline(always)]
        pub const fn otg2lpenc(&self) -> bool {
            let val = (self.0 >> 29usize) & 0x01;
            val != 0
        }
        #[doc = "OTG2 sleep enable."]
        #[inline(always)]
        pub fn set_otg2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
        }
        #[doc = "NPUCACHE sleep enable."]
        #[inline(always)]
        pub const fn npucachelpenc(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHE sleep enable."]
        #[inline(always)]
        pub fn set_npucachelpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "NPU sleep enable."]
        #[inline(always)]
        pub const fn npulpenc(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "NPU sleep enable."]
        #[inline(always)]
        pub fn set_npulpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Ahb5lpencr {
        #[inline(always)]
        fn default() -> Ahb5lpencr {
            Ahb5lpencr(0)
        }
    }
    impl core::fmt::Debug for Ahb5lpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb5lpencr")
                .field("hpdma1lpenc", &self.hpdma1lpenc())
                .field("dma2dlpenc", &self.dma2dlpenc())
                .field("jpeglpenc", &self.jpeglpenc())
                .field("fmclpenc", &self.fmclpenc())
                .field("xspi1lpenc", &self.xspi1lpenc())
                .field("pssilpenc", &self.pssilpenc())
                .field("sdmmc2lpenc", &self.sdmmc2lpenc())
                .field("sdmmc1lpenc", &self.sdmmc1lpenc())
                .field("xspi2lpenc", &self.xspi2lpenc())
                .field("xspimlpenc", &self.xspimlpenc())
                .field("mce1lpenc", &self.mce1lpenc())
                .field("mce2lpenc", &self.mce2lpenc())
                .field("mce3lpenc", &self.mce3lpenc())
                .field("xspi3lpenc", &self.xspi3lpenc())
                .field("mce4lpenc", &self.mce4lpenc())
                .field("gfxmmulpenc", &self.gfxmmulpenc())
                .field("gpulpenc", &self.gpulpenc())
                .field("eth1maclpenc", &self.eth1maclpenc())
                .field("eth1txlpenc", &self.eth1txlpenc())
                .field("eth1rxlpenc", &self.eth1rxlpenc())
                .field("eth1lpenc", &self.eth1lpenc())
                .field("otg1lpenc", &self.otg1lpenc())
                .field("otgphy1lpenc", &self.otgphy1lpenc())
                .field("otgphy2lpenc", &self.otgphy2lpenc())
                .field("otg2lpenc", &self.otg2lpenc())
                .field("npucachelpenc", &self.npucachelpenc())
                .field("npulpenc", &self.npulpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb5lpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb5lpencr {{ hpdma1lpenc: {=bool:?}, dma2dlpenc: {=bool:?}, jpeglpenc: {=bool:?}, fmclpenc: {=bool:?}, xspi1lpenc: {=bool:?}, pssilpenc: {=bool:?}, sdmmc2lpenc: {=bool:?}, sdmmc1lpenc: {=bool:?}, xspi2lpenc: {=bool:?}, xspimlpenc: {=bool:?}, mce1lpenc: {=bool:?}, mce2lpenc: {=bool:?}, mce3lpenc: {=bool:?}, xspi3lpenc: {=bool:?}, mce4lpenc: {=bool:?}, gfxmmulpenc: {=bool:?}, gpulpenc: {=bool:?}, eth1maclpenc: {=bool:?}, eth1txlpenc: {=bool:?}, eth1rxlpenc: {=bool:?}, eth1lpenc: {=bool:?}, otg1lpenc: {=bool:?}, otgphy1lpenc: {=bool:?}, otgphy2lpenc: {=bool:?}, otg2lpenc: {=bool:?}, npucachelpenc: {=bool:?}, npulpenc: {=bool:?} }}" , self . hpdma1lpenc () , self . dma2dlpenc () , self . jpeglpenc () , self . fmclpenc () , self . xspi1lpenc () , self . pssilpenc () , self . sdmmc2lpenc () , self . sdmmc1lpenc () , self . xspi2lpenc () , self . xspimlpenc () , self . mce1lpenc () , self . mce2lpenc () , self . mce3lpenc () , self . xspi3lpenc () , self . mce4lpenc () , self . gfxmmulpenc () , self . gpulpenc () , self . eth1maclpenc () , self . eth1txlpenc () , self . eth1rxlpenc () , self . eth1lpenc () , self . otg1lpenc () , self . otgphy1lpenc () , self . otgphy2lpenc () , self . otg2lpenc () , self . npucachelpenc () , self . npulpenc ())
        }
    }
    #[doc = "RCC AHB5 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb5lpenr(pub u32);
    impl Ahb5lpenr {
        #[doc = "HPDMA1 sleep enable."]
        #[inline(always)]
        pub const fn hpdma1lpen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "HPDMA1 sleep enable."]
        #[inline(always)]
        pub fn set_hpdma1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "DMA2D sleep enable."]
        #[inline(always)]
        pub const fn dma2dlpen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "DMA2D sleep enable."]
        #[inline(always)]
        pub fn set_dma2dlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "JPEG sleep enable."]
        #[inline(always)]
        pub const fn jpeglpen(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "JPEG sleep enable."]
        #[inline(always)]
        pub fn set_jpeglpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "FMC sleep enable."]
        #[inline(always)]
        pub const fn fmclpen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "FMC sleep enable."]
        #[inline(always)]
        pub fn set_fmclpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "XSPI1 sleep enable."]
        #[inline(always)]
        pub const fn xspi1lpen(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI1 sleep enable."]
        #[inline(always)]
        pub fn set_xspi1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "PSSI sleep enable."]
        #[inline(always)]
        pub const fn pssilpen(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PSSI sleep enable."]
        #[inline(always)]
        pub fn set_pssilpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "SDMMC2 sleep enable."]
        #[inline(always)]
        pub const fn sdmmc2lpen(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC2 sleep enable."]
        #[inline(always)]
        pub fn set_sdmmc2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SDMMC1 sleep enable."]
        #[inline(always)]
        pub const fn sdmmc1lpen(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC1 sleep enable."]
        #[inline(always)]
        pub fn set_sdmmc1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "XSPI2 sleep enable."]
        #[inline(always)]
        pub const fn xspi2lpen(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI2 sleep enable."]
        #[inline(always)]
        pub fn set_xspi2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "XSPIM sleep enable."]
        #[inline(always)]
        pub const fn xspimlpen(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIM sleep enable."]
        #[inline(always)]
        pub fn set_xspimlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "MCE1 sleep enable."]
        #[inline(always)]
        pub const fn mce1lpen(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "MCE1 sleep enable."]
        #[inline(always)]
        pub fn set_mce1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "MCE2 sleep enable."]
        #[inline(always)]
        pub const fn mce2lpen(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "MCE2 sleep enable."]
        #[inline(always)]
        pub fn set_mce2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "MCE3 sleep enable."]
        #[inline(always)]
        pub const fn mce3lpen(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MCE3 sleep enable."]
        #[inline(always)]
        pub fn set_mce3lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "XSPI3 sleep enable."]
        #[inline(always)]
        pub const fn xspi3lpen(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI3 sleep enable."]
        #[inline(always)]
        pub fn set_xspi3lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "MCE4 sleep enable."]
        #[inline(always)]
        pub const fn mce4lpen(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "MCE4 sleep enable."]
        #[inline(always)]
        pub fn set_mce4lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "GFXMMU sleep enable."]
        #[inline(always)]
        pub const fn gfxmmulpen(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "GFXMMU sleep enable."]
        #[inline(always)]
        pub fn set_gfxmmulpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "GPU sleep enable."]
        #[inline(always)]
        pub const fn gpulpen(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "GPU sleep enable."]
        #[inline(always)]
        pub fn set_gpulpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "ETH1MAC sleep enable."]
        #[inline(always)]
        pub const fn eth1maclpen(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1MAC sleep enable."]
        #[inline(always)]
        pub fn set_eth1maclpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "ETH1TX sleep enable."]
        #[inline(always)]
        pub const fn eth1txlpen(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1TX sleep enable."]
        #[inline(always)]
        pub fn set_eth1txlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "ETH1RX sleep enable."]
        #[inline(always)]
        pub const fn eth1rxlpen(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1RX sleep enable."]
        #[inline(always)]
        pub fn set_eth1rxlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "ETH1 sleep enable."]
        #[inline(always)]
        pub const fn eth1lpen(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1 sleep enable."]
        #[inline(always)]
        pub fn set_eth1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "OTG1 sleep enable."]
        #[inline(always)]
        pub const fn otg1lpen(&self) -> bool {
            let val = (self.0 >> 26usize) & 0x01;
            val != 0
        }
        #[doc = "OTG1 sleep enable."]
        #[inline(always)]
        pub fn set_otg1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
        }
        #[doc = "OTGPHY1 sleep enable."]
        #[inline(always)]
        pub const fn otgphy1lpen(&self) -> bool {
            let val = (self.0 >> 27usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY1 sleep enable."]
        #[inline(always)]
        pub fn set_otgphy1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
        }
        #[doc = "OTGPHY2 sleep enable."]
        #[inline(always)]
        pub const fn otgphy2lpen(&self) -> bool {
            let val = (self.0 >> 28usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY2 sleep enable."]
        #[inline(always)]
        pub fn set_otgphy2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
        }
        #[doc = "OTG2 sleep enable."]
        #[inline(always)]
        pub const fn otg2lpen(&self) -> bool {
            let val = (self.0 >> 29usize) & 0x01;
            val != 0
        }
        #[doc = "OTG2 sleep enable."]
        #[inline(always)]
        pub fn set_otg2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
        }
        #[doc = "NPUCACHE sleep enable."]
        #[inline(always)]
        pub const fn npucachelpen(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHE sleep enable."]
        #[inline(always)]
        pub fn set_npucachelpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "NPU sleep enable."]
        #[inline(always)]
        pub const fn npulpen(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "NPU sleep enable."]
        #[inline(always)]
        pub fn set_npulpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Ahb5lpenr {
        #[inline(always)]
        fn default() -> Ahb5lpenr {
            Ahb5lpenr(0)
        }
    }
    impl core::fmt::Debug for Ahb5lpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb5lpenr")
                .field("hpdma1lpen", &self.hpdma1lpen())
                .field("dma2dlpen", &self.dma2dlpen())
                .field("jpeglpen", &self.jpeglpen())
                .field("fmclpen", &self.fmclpen())
                .field("xspi1lpen", &self.xspi1lpen())
                .field("pssilpen", &self.pssilpen())
                .field("sdmmc2lpen", &self.sdmmc2lpen())
                .field("sdmmc1lpen", &self.sdmmc1lpen())
                .field("xspi2lpen", &self.xspi2lpen())
                .field("xspimlpen", &self.xspimlpen())
                .field("mce1lpen", &self.mce1lpen())
                .field("mce2lpen", &self.mce2lpen())
                .field("mce3lpen", &self.mce3lpen())
                .field("xspi3lpen", &self.xspi3lpen())
                .field("mce4lpen", &self.mce4lpen())
                .field("gfxmmulpen", &self.gfxmmulpen())
                .field("gpulpen", &self.gpulpen())
                .field("eth1maclpen", &self.eth1maclpen())
                .field("eth1txlpen", &self.eth1txlpen())
                .field("eth1rxlpen", &self.eth1rxlpen())
                .field("eth1lpen", &self.eth1lpen())
                .field("otg1lpen", &self.otg1lpen())
                .field("otgphy1lpen", &self.otgphy1lpen())
                .field("otgphy2lpen", &self.otgphy2lpen())
                .field("otg2lpen", &self.otg2lpen())
                .field("npucachelpen", &self.npucachelpen())
                .field("npulpen", &self.npulpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb5lpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb5lpenr {{ hpdma1lpen: {=bool:?}, dma2dlpen: {=bool:?}, jpeglpen: {=bool:?}, fmclpen: {=bool:?}, xspi1lpen: {=bool:?}, pssilpen: {=bool:?}, sdmmc2lpen: {=bool:?}, sdmmc1lpen: {=bool:?}, xspi2lpen: {=bool:?}, xspimlpen: {=bool:?}, mce1lpen: {=bool:?}, mce2lpen: {=bool:?}, mce3lpen: {=bool:?}, xspi3lpen: {=bool:?}, mce4lpen: {=bool:?}, gfxmmulpen: {=bool:?}, gpulpen: {=bool:?}, eth1maclpen: {=bool:?}, eth1txlpen: {=bool:?}, eth1rxlpen: {=bool:?}, eth1lpen: {=bool:?}, otg1lpen: {=bool:?}, otgphy1lpen: {=bool:?}, otgphy2lpen: {=bool:?}, otg2lpen: {=bool:?}, npucachelpen: {=bool:?}, npulpen: {=bool:?} }}" , self . hpdma1lpen () , self . dma2dlpen () , self . jpeglpen () , self . fmclpen () , self . xspi1lpen () , self . pssilpen () , self . sdmmc2lpen () , self . sdmmc1lpen () , self . xspi2lpen () , self . xspimlpen () , self . mce1lpen () , self . mce2lpen () , self . mce3lpen () , self . xspi3lpen () , self . mce4lpen () , self . gfxmmulpen () , self . gpulpen () , self . eth1maclpen () , self . eth1txlpen () , self . eth1rxlpen () , self . eth1lpen () , self . otg1lpen () , self . otgphy1lpen () , self . otgphy2lpen () , self . otg2lpen () , self . npucachelpen () , self . npulpen ())
        }
    }
    #[doc = "RCC AHB5 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb5lpensr(pub u32);
    impl Ahb5lpensr {
        #[doc = "HPDMA1 sleep enable."]
        #[inline(always)]
        pub const fn hpdma1lpens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "HPDMA1 sleep enable."]
        #[inline(always)]
        pub fn set_hpdma1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "DMA2D sleep enable."]
        #[inline(always)]
        pub const fn dma2dlpens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "DMA2D sleep enable."]
        #[inline(always)]
        pub fn set_dma2dlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "JPEG sleep enable."]
        #[inline(always)]
        pub const fn jpeglpens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "JPEG sleep enable."]
        #[inline(always)]
        pub fn set_jpeglpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "FMC sleep enable."]
        #[inline(always)]
        pub const fn fmclpens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "FMC sleep enable."]
        #[inline(always)]
        pub fn set_fmclpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "XSPI1 sleep enable."]
        #[inline(always)]
        pub const fn xspi1lpens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI1 sleep enable."]
        #[inline(always)]
        pub fn set_xspi1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "PSSI sleep enable."]
        #[inline(always)]
        pub const fn pssilpens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PSSI sleep enable."]
        #[inline(always)]
        pub fn set_pssilpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "SDMMC2 sleep enable."]
        #[inline(always)]
        pub const fn sdmmc2lpens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC2 sleep enable."]
        #[inline(always)]
        pub fn set_sdmmc2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SDMMC1 sleep enable."]
        #[inline(always)]
        pub const fn sdmmc1lpens(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC1 sleep enable."]
        #[inline(always)]
        pub fn set_sdmmc1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "XSPI2 sleep enable."]
        #[inline(always)]
        pub const fn xspi2lpens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI2 sleep enable."]
        #[inline(always)]
        pub fn set_xspi2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "XSPIM sleep enable."]
        #[inline(always)]
        pub const fn xspimlpens(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIM sleep enable."]
        #[inline(always)]
        pub fn set_xspimlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "MCE1 sleep enable."]
        #[inline(always)]
        pub const fn mce1lpens(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "MCE1 sleep enable."]
        #[inline(always)]
        pub fn set_mce1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "MCE2 sleep enable."]
        #[inline(always)]
        pub const fn mce2lpens(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "MCE2 sleep enable."]
        #[inline(always)]
        pub fn set_mce2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "MCE3 sleep enable."]
        #[inline(always)]
        pub const fn mce3lpens(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "MCE3 sleep enable."]
        #[inline(always)]
        pub fn set_mce3lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "XSPI3 sleep enable."]
        #[inline(always)]
        pub const fn xspi3lpens(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI3 sleep enable."]
        #[inline(always)]
        pub fn set_xspi3lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "MCE4 sleep enable."]
        #[inline(always)]
        pub const fn mce4lpens(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "MCE4 sleep enable."]
        #[inline(always)]
        pub fn set_mce4lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "GFXMMU sleep enable."]
        #[inline(always)]
        pub const fn gfxmmulpens(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "GFXMMU sleep enable."]
        #[inline(always)]
        pub fn set_gfxmmulpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "GPU sleep enable."]
        #[inline(always)]
        pub const fn gpulpens(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "GPU sleep enable."]
        #[inline(always)]
        pub fn set_gpulpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "ETH1MAC sleep enable."]
        #[inline(always)]
        pub const fn eth1maclpens(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1MAC sleep enable."]
        #[inline(always)]
        pub fn set_eth1maclpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "ETH1TX sleep enable."]
        #[inline(always)]
        pub const fn eth1txlpens(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1TX sleep enable."]
        #[inline(always)]
        pub fn set_eth1txlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "ETH1RX sleep enable."]
        #[inline(always)]
        pub const fn eth1rxlpens(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1RX sleep enable."]
        #[inline(always)]
        pub fn set_eth1rxlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "ETH1 sleep enable."]
        #[inline(always)]
        pub const fn eth1lpens(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1 sleep enable."]
        #[inline(always)]
        pub fn set_eth1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "OTG1 sleep enable."]
        #[inline(always)]
        pub const fn otg1lpens(&self) -> bool {
            let val = (self.0 >> 26usize) & 0x01;
            val != 0
        }
        #[doc = "OTG1 sleep enable."]
        #[inline(always)]
        pub fn set_otg1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
        }
        #[doc = "OTGPHY1 sleep enable."]
        #[inline(always)]
        pub const fn otgphy1lpens(&self) -> bool {
            let val = (self.0 >> 27usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY1 sleep enable."]
        #[inline(always)]
        pub fn set_otgphy1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
        }
        #[doc = "OTGPHY2 sleep enable."]
        #[inline(always)]
        pub const fn otgphy2lpens(&self) -> bool {
            let val = (self.0 >> 28usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY2 sleep enable."]
        #[inline(always)]
        pub fn set_otgphy2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
        }
        #[doc = "OTG2 sleep enable."]
        #[inline(always)]
        pub const fn otg2lpens(&self) -> bool {
            let val = (self.0 >> 29usize) & 0x01;
            val != 0
        }
        #[doc = "OTG2 sleep enable."]
        #[inline(always)]
        pub fn set_otg2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
        }
        #[doc = "NPUCACHE sleep enable."]
        #[inline(always)]
        pub const fn npucachelpens(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHE sleep enable."]
        #[inline(always)]
        pub fn set_npucachelpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "NPU sleep enable."]
        #[inline(always)]
        pub const fn npulpens(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "NPU sleep enable."]
        #[inline(always)]
        pub fn set_npulpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Ahb5lpensr {
        #[inline(always)]
        fn default() -> Ahb5lpensr {
            Ahb5lpensr(0)
        }
    }
    impl core::fmt::Debug for Ahb5lpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb5lpensr")
                .field("hpdma1lpens", &self.hpdma1lpens())
                .field("dma2dlpens", &self.dma2dlpens())
                .field("jpeglpens", &self.jpeglpens())
                .field("fmclpens", &self.fmclpens())
                .field("xspi1lpens", &self.xspi1lpens())
                .field("pssilpens", &self.pssilpens())
                .field("sdmmc2lpens", &self.sdmmc2lpens())
                .field("sdmmc1lpens", &self.sdmmc1lpens())
                .field("xspi2lpens", &self.xspi2lpens())
                .field("xspimlpens", &self.xspimlpens())
                .field("mce1lpens", &self.mce1lpens())
                .field("mce2lpens", &self.mce2lpens())
                .field("mce3lpens", &self.mce3lpens())
                .field("xspi3lpens", &self.xspi3lpens())
                .field("mce4lpens", &self.mce4lpens())
                .field("gfxmmulpens", &self.gfxmmulpens())
                .field("gpulpens", &self.gpulpens())
                .field("eth1maclpens", &self.eth1maclpens())
                .field("eth1txlpens", &self.eth1txlpens())
                .field("eth1rxlpens", &self.eth1rxlpens())
                .field("eth1lpens", &self.eth1lpens())
                .field("otg1lpens", &self.otg1lpens())
                .field("otgphy1lpens", &self.otgphy1lpens())
                .field("otgphy2lpens", &self.otgphy2lpens())
                .field("otg2lpens", &self.otg2lpens())
                .field("npucachelpens", &self.npucachelpens())
                .field("npulpens", &self.npulpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb5lpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb5lpensr {{ hpdma1lpens: {=bool:?}, dma2dlpens: {=bool:?}, jpeglpens: {=bool:?}, fmclpens: {=bool:?}, xspi1lpens: {=bool:?}, pssilpens: {=bool:?}, sdmmc2lpens: {=bool:?}, sdmmc1lpens: {=bool:?}, xspi2lpens: {=bool:?}, xspimlpens: {=bool:?}, mce1lpens: {=bool:?}, mce2lpens: {=bool:?}, mce3lpens: {=bool:?}, xspi3lpens: {=bool:?}, mce4lpens: {=bool:?}, gfxmmulpens: {=bool:?}, gpulpens: {=bool:?}, eth1maclpens: {=bool:?}, eth1txlpens: {=bool:?}, eth1rxlpens: {=bool:?}, eth1lpens: {=bool:?}, otg1lpens: {=bool:?}, otgphy1lpens: {=bool:?}, otgphy2lpens: {=bool:?}, otg2lpens: {=bool:?}, npucachelpens: {=bool:?}, npulpens: {=bool:?} }}" , self . hpdma1lpens () , self . dma2dlpens () , self . jpeglpens () , self . fmclpens () , self . xspi1lpens () , self . pssilpens () , self . sdmmc2lpens () , self . sdmmc1lpens () , self . xspi2lpens () , self . xspimlpens () , self . mce1lpens () , self . mce2lpens () , self . mce3lpens () , self . xspi3lpens () , self . mce4lpens () , self . gfxmmulpens () , self . gpulpens () , self . eth1maclpens () , self . eth1txlpens () , self . eth1rxlpens () , self . eth1lpens () , self . otg1lpens () , self . otgphy1lpens () , self . otgphy2lpens () , self . otg2lpens () , self . npucachelpens () , self . npulpens ())
        }
    }
    #[doc = "RCC AHB5 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb5rstcr(pub u32);
    impl Ahb5rstcr {
        #[doc = "HPDMA1 reset."]
        #[inline(always)]
        pub const fn hpdma1rstc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "HPDMA1 reset."]
        #[inline(always)]
        pub fn set_hpdma1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "DMA2D reset."]
        #[inline(always)]
        pub const fn dma2drstc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "DMA2D reset."]
        #[inline(always)]
        pub fn set_dma2drstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "JPEG reset."]
        #[inline(always)]
        pub const fn jpegrstc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "JPEG reset."]
        #[inline(always)]
        pub fn set_jpegrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "FMC reset."]
        #[inline(always)]
        pub const fn fmcrstc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "FMC reset."]
        #[inline(always)]
        pub fn set_fmcrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "XSPI1 reset."]
        #[inline(always)]
        pub const fn xspi1rstc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI1 reset."]
        #[inline(always)]
        pub fn set_xspi1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "PSSI reset."]
        #[inline(always)]
        pub const fn pssirstc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PSSI reset."]
        #[inline(always)]
        pub fn set_pssirstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "SDMMC2 reset."]
        #[inline(always)]
        pub const fn sdmmc2rstc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC2 reset."]
        #[inline(always)]
        pub fn set_sdmmc2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SDMMC1 reset."]
        #[inline(always)]
        pub const fn sdmmc1rstc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC1 reset."]
        #[inline(always)]
        pub fn set_sdmmc1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "XSPI2 reset."]
        #[inline(always)]
        pub const fn xspi2rstc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI2 reset."]
        #[inline(always)]
        pub fn set_xspi2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "XSPIM reset."]
        #[inline(always)]
        pub const fn xspimrstc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIM reset."]
        #[inline(always)]
        pub fn set_xspimrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "XSPI3 reset."]
        #[inline(always)]
        pub const fn xspi3rstc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI3 reset."]
        #[inline(always)]
        pub fn set_xspi3rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "MCE4 reset."]
        #[inline(always)]
        pub const fn mce4rstc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "MCE4 reset."]
        #[inline(always)]
        pub fn set_mce4rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "GFXMMU reset."]
        #[inline(always)]
        pub const fn gfxmmurstc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "GFXMMU reset."]
        #[inline(always)]
        pub fn set_gfxmmurstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "GPU reset."]
        #[inline(always)]
        pub const fn gpurstc(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "GPU reset."]
        #[inline(always)]
        pub fn set_gpurstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "SYSCFGOTGHSPHY1 reset."]
        #[inline(always)]
        pub const fn syscfgotghsphy1rstc(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFGOTGHSPHY1 reset."]
        #[inline(always)]
        pub fn set_syscfgotghsphy1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "SYSCFGOTGHSPHY2 reset."]
        #[inline(always)]
        pub const fn syscfgotghsphy2rstc(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFGOTGHSPHY2 reset."]
        #[inline(always)]
        pub fn set_syscfgotghsphy2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "ETH1 reset."]
        #[inline(always)]
        pub const fn eth1rstc(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1 reset."]
        #[inline(always)]
        pub fn set_eth1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "OTG1 reset."]
        #[inline(always)]
        pub const fn otg1rstc(&self) -> bool {
            let val = (self.0 >> 26usize) & 0x01;
            val != 0
        }
        #[doc = "OTG1 reset."]
        #[inline(always)]
        pub fn set_otg1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
        }
        #[doc = "OTGPHY1 reset."]
        #[inline(always)]
        pub const fn otgphy1rstc(&self) -> bool {
            let val = (self.0 >> 27usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY1 reset."]
        #[inline(always)]
        pub fn set_otgphy1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
        }
        #[doc = "OTGPHY2 reset."]
        #[inline(always)]
        pub const fn otgphy2rstc(&self) -> bool {
            let val = (self.0 >> 28usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY2 reset."]
        #[inline(always)]
        pub fn set_otgphy2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
        }
        #[doc = "OTG2 reset."]
        #[inline(always)]
        pub const fn otg2rstc(&self) -> bool {
            let val = (self.0 >> 29usize) & 0x01;
            val != 0
        }
        #[doc = "OTG2 reset."]
        #[inline(always)]
        pub fn set_otg2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
        }
        #[doc = "NPUCACHE reset."]
        #[inline(always)]
        pub const fn npucacherstc(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHE reset."]
        #[inline(always)]
        pub fn set_npucacherstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "NPU reset."]
        #[inline(always)]
        pub const fn npurstc(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "NPU reset."]
        #[inline(always)]
        pub fn set_npurstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Ahb5rstcr {
        #[inline(always)]
        fn default() -> Ahb5rstcr {
            Ahb5rstcr(0)
        }
    }
    impl core::fmt::Debug for Ahb5rstcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb5rstcr")
                .field("hpdma1rstc", &self.hpdma1rstc())
                .field("dma2drstc", &self.dma2drstc())
                .field("jpegrstc", &self.jpegrstc())
                .field("fmcrstc", &self.fmcrstc())
                .field("xspi1rstc", &self.xspi1rstc())
                .field("pssirstc", &self.pssirstc())
                .field("sdmmc2rstc", &self.sdmmc2rstc())
                .field("sdmmc1rstc", &self.sdmmc1rstc())
                .field("xspi2rstc", &self.xspi2rstc())
                .field("xspimrstc", &self.xspimrstc())
                .field("xspi3rstc", &self.xspi3rstc())
                .field("mce4rstc", &self.mce4rstc())
                .field("gfxmmurstc", &self.gfxmmurstc())
                .field("gpurstc", &self.gpurstc())
                .field("syscfgotghsphy1rstc", &self.syscfgotghsphy1rstc())
                .field("syscfgotghsphy2rstc", &self.syscfgotghsphy2rstc())
                .field("eth1rstc", &self.eth1rstc())
                .field("otg1rstc", &self.otg1rstc())
                .field("otgphy1rstc", &self.otgphy1rstc())
                .field("otgphy2rstc", &self.otgphy2rstc())
                .field("otg2rstc", &self.otg2rstc())
                .field("npucacherstc", &self.npucacherstc())
                .field("npurstc", &self.npurstc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb5rstcr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb5rstcr {{ hpdma1rstc: {=bool:?}, dma2drstc: {=bool:?}, jpegrstc: {=bool:?}, fmcrstc: {=bool:?}, xspi1rstc: {=bool:?}, pssirstc: {=bool:?}, sdmmc2rstc: {=bool:?}, sdmmc1rstc: {=bool:?}, xspi2rstc: {=bool:?}, xspimrstc: {=bool:?}, xspi3rstc: {=bool:?}, mce4rstc: {=bool:?}, gfxmmurstc: {=bool:?}, gpurstc: {=bool:?}, syscfgotghsphy1rstc: {=bool:?}, syscfgotghsphy2rstc: {=bool:?}, eth1rstc: {=bool:?}, otg1rstc: {=bool:?}, otgphy1rstc: {=bool:?}, otgphy2rstc: {=bool:?}, otg2rstc: {=bool:?}, npucacherstc: {=bool:?}, npurstc: {=bool:?} }}" , self . hpdma1rstc () , self . dma2drstc () , self . jpegrstc () , self . fmcrstc () , self . xspi1rstc () , self . pssirstc () , self . sdmmc2rstc () , self . sdmmc1rstc () , self . xspi2rstc () , self . xspimrstc () , self . xspi3rstc () , self . mce4rstc () , self . gfxmmurstc () , self . gpurstc () , self . syscfgotghsphy1rstc () , self . syscfgotghsphy2rstc () , self . eth1rstc () , self . otg1rstc () , self . otgphy1rstc () , self . otgphy2rstc () , self . otg2rstc () , self . npucacherstc () , self . npurstc ())
        }
    }
    #[doc = "RCC AHB5 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb5rstr(pub u32);
    impl Ahb5rstr {
        #[doc = "HPDMA1 reset."]
        #[inline(always)]
        pub const fn hpdma1rst(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "HPDMA1 reset."]
        #[inline(always)]
        pub fn set_hpdma1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "DMA2D reset."]
        #[inline(always)]
        pub const fn dma2drst(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "DMA2D reset."]
        #[inline(always)]
        pub fn set_dma2drst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "JPEG reset."]
        #[inline(always)]
        pub const fn jpegrst(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "JPEG reset."]
        #[inline(always)]
        pub fn set_jpegrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "FMC reset."]
        #[inline(always)]
        pub const fn fmcrst(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "FMC reset."]
        #[inline(always)]
        pub fn set_fmcrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "XSPI1 reset."]
        #[inline(always)]
        pub const fn xspi1rst(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI1 reset."]
        #[inline(always)]
        pub fn set_xspi1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "PSSI reset."]
        #[inline(always)]
        pub const fn pssirst(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PSSI reset."]
        #[inline(always)]
        pub fn set_pssirst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "SDMMC2 reset."]
        #[inline(always)]
        pub const fn sdmmc2rst(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC2 reset."]
        #[inline(always)]
        pub fn set_sdmmc2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SDMMC1 reset."]
        #[inline(always)]
        pub const fn sdmmc1rst(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC1 reset."]
        #[inline(always)]
        pub fn set_sdmmc1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "XSPI2 reset."]
        #[inline(always)]
        pub const fn xspi2rst(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI2 reset."]
        #[inline(always)]
        pub fn set_xspi2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "XSPIM reset."]
        #[inline(always)]
        pub const fn xspimrst(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIM reset."]
        #[inline(always)]
        pub fn set_xspimrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "XSPI3 reset."]
        #[inline(always)]
        pub const fn xspi3rst(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI3 reset."]
        #[inline(always)]
        pub fn set_xspi3rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "MCE4 reset."]
        #[inline(always)]
        pub const fn mce4rst(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "MCE4 reset."]
        #[inline(always)]
        pub fn set_mce4rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "GFXMMU reset."]
        #[inline(always)]
        pub const fn gfxmmurst(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "GFXMMU reset."]
        #[inline(always)]
        pub fn set_gfxmmurst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "GPU reset."]
        #[inline(always)]
        pub const fn gpurst(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "GPU reset."]
        #[inline(always)]
        pub fn set_gpurst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "SYSCFGOTGHSPHY1 reset."]
        #[inline(always)]
        pub const fn syscfgotghsphy1rst(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFGOTGHSPHY1 reset."]
        #[inline(always)]
        pub fn set_syscfgotghsphy1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "SYSCFGOTGHSPHY2 reset."]
        #[inline(always)]
        pub const fn syscfgotghsphy2rst(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFGOTGHSPHY2 reset."]
        #[inline(always)]
        pub fn set_syscfgotghsphy2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "ETH1 reset."]
        #[inline(always)]
        pub const fn eth1rst(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1 reset."]
        #[inline(always)]
        pub fn set_eth1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "OTG1 reset."]
        #[inline(always)]
        pub const fn otg1rst(&self) -> bool {
            let val = (self.0 >> 26usize) & 0x01;
            val != 0
        }
        #[doc = "OTG1 reset."]
        #[inline(always)]
        pub fn set_otg1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
        }
        #[doc = "OTGPHY1 reset."]
        #[inline(always)]
        pub const fn otgphy1rst(&self) -> bool {
            let val = (self.0 >> 27usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY1 reset."]
        #[inline(always)]
        pub fn set_otgphy1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
        }
        #[doc = "OTGPHY2 reset."]
        #[inline(always)]
        pub const fn otgphy2rst(&self) -> bool {
            let val = (self.0 >> 28usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY2 reset."]
        #[inline(always)]
        pub fn set_otgphy2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
        }
        #[doc = "OTG2 reset."]
        #[inline(always)]
        pub const fn otg2rst(&self) -> bool {
            let val = (self.0 >> 29usize) & 0x01;
            val != 0
        }
        #[doc = "OTG2 reset."]
        #[inline(always)]
        pub fn set_otg2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
        }
        #[doc = "NPUCACHE reset."]
        #[inline(always)]
        pub const fn npucacherst(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHE reset."]
        #[inline(always)]
        pub fn set_npucacherst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "NPU reset."]
        #[inline(always)]
        pub const fn npurst(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "NPU reset."]
        #[inline(always)]
        pub fn set_npurst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Ahb5rstr {
        #[inline(always)]
        fn default() -> Ahb5rstr {
            Ahb5rstr(0)
        }
    }
    impl core::fmt::Debug for Ahb5rstr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb5rstr")
                .field("hpdma1rst", &self.hpdma1rst())
                .field("dma2drst", &self.dma2drst())
                .field("jpegrst", &self.jpegrst())
                .field("fmcrst", &self.fmcrst())
                .field("xspi1rst", &self.xspi1rst())
                .field("pssirst", &self.pssirst())
                .field("sdmmc2rst", &self.sdmmc2rst())
                .field("sdmmc1rst", &self.sdmmc1rst())
                .field("xspi2rst", &self.xspi2rst())
                .field("xspimrst", &self.xspimrst())
                .field("xspi3rst", &self.xspi3rst())
                .field("mce4rst", &self.mce4rst())
                .field("gfxmmurst", &self.gfxmmurst())
                .field("gpurst", &self.gpurst())
                .field("syscfgotghsphy1rst", &self.syscfgotghsphy1rst())
                .field("syscfgotghsphy2rst", &self.syscfgotghsphy2rst())
                .field("eth1rst", &self.eth1rst())
                .field("otg1rst", &self.otg1rst())
                .field("otgphy1rst", &self.otgphy1rst())
                .field("otgphy2rst", &self.otgphy2rst())
                .field("otg2rst", &self.otg2rst())
                .field("npucacherst", &self.npucacherst())
                .field("npurst", &self.npurst())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb5rstr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb5rstr {{ hpdma1rst: {=bool:?}, dma2drst: {=bool:?}, jpegrst: {=bool:?}, fmcrst: {=bool:?}, xspi1rst: {=bool:?}, pssirst: {=bool:?}, sdmmc2rst: {=bool:?}, sdmmc1rst: {=bool:?}, xspi2rst: {=bool:?}, xspimrst: {=bool:?}, xspi3rst: {=bool:?}, mce4rst: {=bool:?}, gfxmmurst: {=bool:?}, gpurst: {=bool:?}, syscfgotghsphy1rst: {=bool:?}, syscfgotghsphy2rst: {=bool:?}, eth1rst: {=bool:?}, otg1rst: {=bool:?}, otgphy1rst: {=bool:?}, otgphy2rst: {=bool:?}, otg2rst: {=bool:?}, npucacherst: {=bool:?}, npurst: {=bool:?} }}" , self . hpdma1rst () , self . dma2drst () , self . jpegrst () , self . fmcrst () , self . xspi1rst () , self . pssirst () , self . sdmmc2rst () , self . sdmmc1rst () , self . xspi2rst () , self . xspimrst () , self . xspi3rst () , self . mce4rst () , self . gfxmmurst () , self . gpurst () , self . syscfgotghsphy1rst () , self . syscfgotghsphy2rst () , self . eth1rst () , self . otg1rst () , self . otgphy1rst () , self . otgphy2rst () , self . otg2rst () , self . npucacherst () , self . npurst ())
        }
    }
    #[doc = "RCC AHB5 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ahb5rstsr(pub u32);
    impl Ahb5rstsr {
        #[doc = "HPDMA1 reset."]
        #[inline(always)]
        pub const fn hpdma1rsts(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "HPDMA1 reset."]
        #[inline(always)]
        pub fn set_hpdma1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "DMA2D reset."]
        #[inline(always)]
        pub const fn dma2drsts(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "DMA2D reset."]
        #[inline(always)]
        pub fn set_dma2drsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "JPEG reset."]
        #[inline(always)]
        pub const fn jpegrsts(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "JPEG reset."]
        #[inline(always)]
        pub fn set_jpegrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "FMC reset."]
        #[inline(always)]
        pub const fn fmcrsts(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "FMC reset."]
        #[inline(always)]
        pub fn set_fmcrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "XSPI1 reset."]
        #[inline(always)]
        pub const fn xspi1rsts(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI1 reset."]
        #[inline(always)]
        pub fn set_xspi1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "PSSI reset."]
        #[inline(always)]
        pub const fn pssirsts(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PSSI reset."]
        #[inline(always)]
        pub fn set_pssirsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "SDMMC2 reset."]
        #[inline(always)]
        pub const fn sdmmc2rsts(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC2 reset."]
        #[inline(always)]
        pub fn set_sdmmc2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SDMMC1 reset."]
        #[inline(always)]
        pub const fn sdmmc1rsts(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC1 reset."]
        #[inline(always)]
        pub fn set_sdmmc1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "XSPI2 reset."]
        #[inline(always)]
        pub const fn xspi2rsts(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI2 reset."]
        #[inline(always)]
        pub fn set_xspi2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "XSPIM reset."]
        #[inline(always)]
        pub const fn xspimrsts(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIM reset."]
        #[inline(always)]
        pub fn set_xspimrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "XSPI3 reset."]
        #[inline(always)]
        pub const fn xspi3rsts(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "XSPI3 reset."]
        #[inline(always)]
        pub fn set_xspi3rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "MCE4 reset."]
        #[inline(always)]
        pub const fn mce4rsts(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "MCE4 reset."]
        #[inline(always)]
        pub fn set_mce4rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "GFXMMU reset."]
        #[inline(always)]
        pub const fn gfxmmursts(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "GFXMMU reset."]
        #[inline(always)]
        pub fn set_gfxmmursts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "GPU reset."]
        #[inline(always)]
        pub const fn gpursts(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "GPU reset."]
        #[inline(always)]
        pub fn set_gpursts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "SYSCFGOTGHSPHY1 reset."]
        #[inline(always)]
        pub const fn syscfgotghsphy1rsts(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFGOTGHSPHY1 reset."]
        #[inline(always)]
        pub fn set_syscfgotghsphy1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "SYSCFGOTGHSPHY2 reset."]
        #[inline(always)]
        pub const fn syscfgotghsphy2rsts(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFGOTGHSPHY2 reset."]
        #[inline(always)]
        pub fn set_syscfgotghsphy2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "ETH1 reset."]
        #[inline(always)]
        pub const fn eth1rsts(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "ETH1 reset."]
        #[inline(always)]
        pub fn set_eth1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "OTG1 reset."]
        #[inline(always)]
        pub const fn otg1rsts(&self) -> bool {
            let val = (self.0 >> 26usize) & 0x01;
            val != 0
        }
        #[doc = "OTG1 reset."]
        #[inline(always)]
        pub fn set_otg1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
        }
        #[doc = "OTGPHY1 reset."]
        #[inline(always)]
        pub const fn otgphy1rsts(&self) -> bool {
            let val = (self.0 >> 27usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY1 reset."]
        #[inline(always)]
        pub fn set_otgphy1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
        }
        #[doc = "OTGPHY2 reset."]
        #[inline(always)]
        pub const fn otgphy2rsts(&self) -> bool {
            let val = (self.0 >> 28usize) & 0x01;
            val != 0
        }
        #[doc = "OTGPHY2 reset."]
        #[inline(always)]
        pub fn set_otgphy2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
        }
        #[doc = "OTG2 reset."]
        #[inline(always)]
        pub const fn otg2rsts(&self) -> bool {
            let val = (self.0 >> 29usize) & 0x01;
            val != 0
        }
        #[doc = "OTG2 reset."]
        #[inline(always)]
        pub fn set_otg2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
        }
        #[doc = "NPUCACHE reset."]
        #[inline(always)]
        pub const fn npucachersts(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHE reset."]
        #[inline(always)]
        pub fn set_npucachersts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "NPU reset."]
        #[inline(always)]
        pub const fn npursts(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "NPU reset."]
        #[inline(always)]
        pub fn set_npursts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Ahb5rstsr {
        #[inline(always)]
        fn default() -> Ahb5rstsr {
            Ahb5rstsr(0)
        }
    }
    impl core::fmt::Debug for Ahb5rstsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ahb5rstsr")
                .field("hpdma1rsts", &self.hpdma1rsts())
                .field("dma2drsts", &self.dma2drsts())
                .field("jpegrsts", &self.jpegrsts())
                .field("fmcrsts", &self.fmcrsts())
                .field("xspi1rsts", &self.xspi1rsts())
                .field("pssirsts", &self.pssirsts())
                .field("sdmmc2rsts", &self.sdmmc2rsts())
                .field("sdmmc1rsts", &self.sdmmc1rsts())
                .field("xspi2rsts", &self.xspi2rsts())
                .field("xspimrsts", &self.xspimrsts())
                .field("xspi3rsts", &self.xspi3rsts())
                .field("mce4rsts", &self.mce4rsts())
                .field("gfxmmursts", &self.gfxmmursts())
                .field("gpursts", &self.gpursts())
                .field("syscfgotghsphy1rsts", &self.syscfgotghsphy1rsts())
                .field("syscfgotghsphy2rsts", &self.syscfgotghsphy2rsts())
                .field("eth1rsts", &self.eth1rsts())
                .field("otg1rsts", &self.otg1rsts())
                .field("otgphy1rsts", &self.otgphy1rsts())
                .field("otgphy2rsts", &self.otgphy2rsts())
                .field("otg2rsts", &self.otg2rsts())
                .field("npucachersts", &self.npucachersts())
                .field("npursts", &self.npursts())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ahb5rstsr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ahb5rstsr {{ hpdma1rsts: {=bool:?}, dma2drsts: {=bool:?}, jpegrsts: {=bool:?}, fmcrsts: {=bool:?}, xspi1rsts: {=bool:?}, pssirsts: {=bool:?}, sdmmc2rsts: {=bool:?}, sdmmc1rsts: {=bool:?}, xspi2rsts: {=bool:?}, xspimrsts: {=bool:?}, xspi3rsts: {=bool:?}, mce4rsts: {=bool:?}, gfxmmursts: {=bool:?}, gpursts: {=bool:?}, syscfgotghsphy1rsts: {=bool:?}, syscfgotghsphy2rsts: {=bool:?}, eth1rsts: {=bool:?}, otg1rsts: {=bool:?}, otgphy1rsts: {=bool:?}, otgphy2rsts: {=bool:?}, otg2rsts: {=bool:?}, npucachersts: {=bool:?}, npursts: {=bool:?} }}" , self . hpdma1rsts () , self . dma2drsts () , self . jpegrsts () , self . fmcrsts () , self . xspi1rsts () , self . pssirsts () , self . sdmmc2rsts () , self . sdmmc1rsts () , self . xspi2rsts () , self . xspimrsts () , self . xspi3rsts () , self . mce4rsts () , self . gfxmmursts () , self . gpursts () , self . syscfgotghsphy1rsts () , self . syscfgotghsphy2rsts () , self . eth1rsts () , self . otg1rsts () , self . otgphy1rsts () , self . otgphy2rsts () , self . otg2rsts () , self . npucachersts () , self . npursts ())
        }
    }
    #[doc = "RCC APB1H enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1hencr(pub u32);
    impl Apb1hencr {
        #[doc = "MDIOS enable."]
        #[inline(always)]
        pub const fn mdiosenc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "MDIOS enable."]
        #[inline(always)]
        pub fn set_mdiosenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "FDCAN enable."]
        #[inline(always)]
        pub const fn fdcanenc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "FDCAN enable."]
        #[inline(always)]
        pub fn set_fdcanenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "UCPD1 enable."]
        #[inline(always)]
        pub const fn ucpd1enc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "UCPD1 enable."]
        #[inline(always)]
        pub fn set_ucpd1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
    }
    impl Default for Apb1hencr {
        #[inline(always)]
        fn default() -> Apb1hencr {
            Apb1hencr(0)
        }
    }
    impl core::fmt::Debug for Apb1hencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1hencr")
                .field("mdiosenc", &self.mdiosenc())
                .field("fdcanenc", &self.fdcanenc())
                .field("ucpd1enc", &self.ucpd1enc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1hencr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb1hencr {{ mdiosenc: {=bool:?}, fdcanenc: {=bool:?}, ucpd1enc: {=bool:?} }}",
                self.mdiosenc(),
                self.fdcanenc(),
                self.ucpd1enc()
            )
        }
    }
    #[doc = "RCC APB1H enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1henr(pub u32);
    impl Apb1henr {
        #[doc = "MDIOS enable."]
        #[inline(always)]
        pub const fn mdiosen(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "MDIOS enable."]
        #[inline(always)]
        pub fn set_mdiosen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "FDCAN enable."]
        #[inline(always)]
        pub const fn fdcanen(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "FDCAN enable."]
        #[inline(always)]
        pub fn set_fdcanen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "UCPD1 enable."]
        #[inline(always)]
        pub const fn ucpd1en(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "UCPD1 enable."]
        #[inline(always)]
        pub fn set_ucpd1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
    }
    impl Default for Apb1henr {
        #[inline(always)]
        fn default() -> Apb1henr {
            Apb1henr(0)
        }
    }
    impl core::fmt::Debug for Apb1henr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1henr")
                .field("mdiosen", &self.mdiosen())
                .field("fdcanen", &self.fdcanen())
                .field("ucpd1en", &self.ucpd1en())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1henr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb1henr {{ mdiosen: {=bool:?}, fdcanen: {=bool:?}, ucpd1en: {=bool:?} }}",
                self.mdiosen(),
                self.fdcanen(),
                self.ucpd1en()
            )
        }
    }
    #[doc = "RCC APB1H enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1hensr(pub u32);
    impl Apb1hensr {
        #[doc = "MDIOS enable."]
        #[inline(always)]
        pub const fn mdiosens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "MDIOS enable."]
        #[inline(always)]
        pub fn set_mdiosens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "FDCAN enable."]
        #[inline(always)]
        pub const fn fdcanens(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "FDCAN enable."]
        #[inline(always)]
        pub fn set_fdcanens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "UCPD1 enable."]
        #[inline(always)]
        pub const fn ucpd1ens(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "UCPD1 enable."]
        #[inline(always)]
        pub fn set_ucpd1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
    }
    impl Default for Apb1hensr {
        #[inline(always)]
        fn default() -> Apb1hensr {
            Apb1hensr(0)
        }
    }
    impl core::fmt::Debug for Apb1hensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1hensr")
                .field("mdiosens", &self.mdiosens())
                .field("fdcanens", &self.fdcanens())
                .field("ucpd1ens", &self.ucpd1ens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1hensr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb1hensr {{ mdiosens: {=bool:?}, fdcanens: {=bool:?}, ucpd1ens: {=bool:?} }}",
                self.mdiosens(),
                self.fdcanens(),
                self.ucpd1ens()
            )
        }
    }
    #[doc = "RCC APB1H Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1hlpencr(pub u32);
    impl Apb1hlpencr {
        #[doc = "MDIOS sleep enable."]
        #[inline(always)]
        pub const fn mdioslpenc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "MDIOS sleep enable."]
        #[inline(always)]
        pub fn set_mdioslpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "FDCAN sleep enable."]
        #[inline(always)]
        pub const fn fdcanlpenc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "FDCAN sleep enable."]
        #[inline(always)]
        pub fn set_fdcanlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "UCPD1 sleep enable."]
        #[inline(always)]
        pub const fn ucpd1lpenc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "UCPD1 sleep enable."]
        #[inline(always)]
        pub fn set_ucpd1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
    }
    impl Default for Apb1hlpencr {
        #[inline(always)]
        fn default() -> Apb1hlpencr {
            Apb1hlpencr(0)
        }
    }
    impl core::fmt::Debug for Apb1hlpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1hlpencr")
                .field("mdioslpenc", &self.mdioslpenc())
                .field("fdcanlpenc", &self.fdcanlpenc())
                .field("ucpd1lpenc", &self.ucpd1lpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1hlpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb1hlpencr {{ mdioslpenc: {=bool:?}, fdcanlpenc: {=bool:?}, ucpd1lpenc: {=bool:?} }}",
                self.mdioslpenc(),
                self.fdcanlpenc(),
                self.ucpd1lpenc()
            )
        }
    }
    #[doc = "RCC APB1H Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1hlpenr(pub u32);
    impl Apb1hlpenr {
        #[doc = "MDIOS sleep enable."]
        #[inline(always)]
        pub const fn mdioslpen(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "MDIOS sleep enable."]
        #[inline(always)]
        pub fn set_mdioslpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "FDCAN sleep enable."]
        #[inline(always)]
        pub const fn fdcanlpen(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "FDCAN sleep enable."]
        #[inline(always)]
        pub fn set_fdcanlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "UCPD1 sleep enable."]
        #[inline(always)]
        pub const fn ucpd1lpen(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "UCPD1 sleep enable."]
        #[inline(always)]
        pub fn set_ucpd1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
    }
    impl Default for Apb1hlpenr {
        #[inline(always)]
        fn default() -> Apb1hlpenr {
            Apb1hlpenr(0)
        }
    }
    impl core::fmt::Debug for Apb1hlpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1hlpenr")
                .field("mdioslpen", &self.mdioslpen())
                .field("fdcanlpen", &self.fdcanlpen())
                .field("ucpd1lpen", &self.ucpd1lpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1hlpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb1hlpenr {{ mdioslpen: {=bool:?}, fdcanlpen: {=bool:?}, ucpd1lpen: {=bool:?} }}",
                self.mdioslpen(),
                self.fdcanlpen(),
                self.ucpd1lpen()
            )
        }
    }
    #[doc = "RCC APB1H Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1hlpensr(pub u32);
    impl Apb1hlpensr {
        #[doc = "MDIOS sleep enable."]
        #[inline(always)]
        pub const fn mdioslpens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "MDIOS sleep enable."]
        #[inline(always)]
        pub fn set_mdioslpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "FDCAN sleep enable."]
        #[inline(always)]
        pub const fn fdcanlpens(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "FDCAN sleep enable."]
        #[inline(always)]
        pub fn set_fdcanlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "UCPD1 sleep enable."]
        #[inline(always)]
        pub const fn ucpd1lpens(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "UCPD1 sleep enable."]
        #[inline(always)]
        pub fn set_ucpd1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
    }
    impl Default for Apb1hlpensr {
        #[inline(always)]
        fn default() -> Apb1hlpensr {
            Apb1hlpensr(0)
        }
    }
    impl core::fmt::Debug for Apb1hlpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1hlpensr")
                .field("mdioslpens", &self.mdioslpens())
                .field("fdcanlpens", &self.fdcanlpens())
                .field("ucpd1lpens", &self.ucpd1lpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1hlpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb1hlpensr {{ mdioslpens: {=bool:?}, fdcanlpens: {=bool:?}, ucpd1lpens: {=bool:?} }}",
                self.mdioslpens(),
                self.fdcanlpens(),
                self.ucpd1lpens()
            )
        }
    }
    #[doc = "RCC APB1H reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1hrstcr(pub u32);
    impl Apb1hrstcr {
        #[doc = "MDIOS reset."]
        #[inline(always)]
        pub const fn mdiosrstc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "MDIOS reset."]
        #[inline(always)]
        pub fn set_mdiosrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "FDCAN reset."]
        #[inline(always)]
        pub const fn fdcanrstc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "FDCAN reset."]
        #[inline(always)]
        pub fn set_fdcanrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "UCPD1 reset."]
        #[inline(always)]
        pub const fn ucpd1rstc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "UCPD1 reset."]
        #[inline(always)]
        pub fn set_ucpd1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
    }
    impl Default for Apb1hrstcr {
        #[inline(always)]
        fn default() -> Apb1hrstcr {
            Apb1hrstcr(0)
        }
    }
    impl core::fmt::Debug for Apb1hrstcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1hrstcr")
                .field("mdiosrstc", &self.mdiosrstc())
                .field("fdcanrstc", &self.fdcanrstc())
                .field("ucpd1rstc", &self.ucpd1rstc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1hrstcr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb1hrstcr {{ mdiosrstc: {=bool:?}, fdcanrstc: {=bool:?}, ucpd1rstc: {=bool:?} }}",
                self.mdiosrstc(),
                self.fdcanrstc(),
                self.ucpd1rstc()
            )
        }
    }
    #[doc = "RCC APB1H reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1hrstr(pub u32);
    impl Apb1hrstr {
        #[doc = "MDIOS reset."]
        #[inline(always)]
        pub const fn mdiosrst(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "MDIOS reset."]
        #[inline(always)]
        pub fn set_mdiosrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "FDCAN reset."]
        #[inline(always)]
        pub const fn fdcanrst(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "FDCAN reset."]
        #[inline(always)]
        pub fn set_fdcanrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "UCPD1 reset."]
        #[inline(always)]
        pub const fn ucpd1rst(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "UCPD1 reset."]
        #[inline(always)]
        pub fn set_ucpd1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
    }
    impl Default for Apb1hrstr {
        #[inline(always)]
        fn default() -> Apb1hrstr {
            Apb1hrstr(0)
        }
    }
    impl core::fmt::Debug for Apb1hrstr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1hrstr")
                .field("mdiosrst", &self.mdiosrst())
                .field("fdcanrst", &self.fdcanrst())
                .field("ucpd1rst", &self.ucpd1rst())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1hrstr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb1hrstr {{ mdiosrst: {=bool:?}, fdcanrst: {=bool:?}, ucpd1rst: {=bool:?} }}",
                self.mdiosrst(),
                self.fdcanrst(),
                self.ucpd1rst()
            )
        }
    }
    #[doc = "RCC APB1H reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1hrstsr(pub u32);
    impl Apb1hrstsr {
        #[doc = "MDIOS reset."]
        #[inline(always)]
        pub const fn mdiosrsts(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "MDIOS reset."]
        #[inline(always)]
        pub fn set_mdiosrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "FDCAN reset."]
        #[inline(always)]
        pub const fn fdcanrsts(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "FDCAN reset."]
        #[inline(always)]
        pub fn set_fdcanrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "UCPD1 reset."]
        #[inline(always)]
        pub const fn ucpd1rsts(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "UCPD1 reset."]
        #[inline(always)]
        pub fn set_ucpd1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
    }
    impl Default for Apb1hrstsr {
        #[inline(always)]
        fn default() -> Apb1hrstsr {
            Apb1hrstsr(0)
        }
    }
    impl core::fmt::Debug for Apb1hrstsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1hrstsr")
                .field("mdiosrsts", &self.mdiosrsts())
                .field("fdcanrsts", &self.fdcanrsts())
                .field("ucpd1rsts", &self.ucpd1rsts())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1hrstsr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb1hrstsr {{ mdiosrsts: {=bool:?}, fdcanrsts: {=bool:?}, ucpd1rsts: {=bool:?} }}",
                self.mdiosrsts(),
                self.fdcanrsts(),
                self.ucpd1rsts()
            )
        }
    }
    #[doc = "RCC APB1L enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1lencr(pub u32);
    impl Apb1lencr {
        #[doc = "TIM2 enable."]
        #[inline(always)]
        pub const fn tim2enc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM2 enable."]
        #[inline(always)]
        pub fn set_tim2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM3 enable."]
        #[inline(always)]
        pub const fn tim3enc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM3 enable."]
        #[inline(always)]
        pub fn set_tim3enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "TIM4 enable."]
        #[inline(always)]
        pub const fn tim4enc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "TIM4 enable."]
        #[inline(always)]
        pub fn set_tim4enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "TIM5 enable."]
        #[inline(always)]
        pub const fn tim5enc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "TIM5 enable."]
        #[inline(always)]
        pub fn set_tim5enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "TIM6 enable."]
        #[inline(always)]
        pub const fn tim6enc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "TIM6 enable."]
        #[inline(always)]
        pub fn set_tim6enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "TIM7 enable."]
        #[inline(always)]
        pub const fn tim7enc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "TIM7 enable."]
        #[inline(always)]
        pub fn set_tim7enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "TIM12 enable."]
        #[inline(always)]
        pub const fn tim12enc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "TIM12 enable."]
        #[inline(always)]
        pub fn set_tim12enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "TIM13 enable."]
        #[inline(always)]
        pub const fn tim13enc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "TIM13 enable."]
        #[inline(always)]
        pub fn set_tim13enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "TIM14 enable."]
        #[inline(always)]
        pub const fn tim14enc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "TIM14 enable."]
        #[inline(always)]
        pub fn set_tim14enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "LPTIM1 enable."]
        #[inline(always)]
        pub const fn lptim1enc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM1 enable."]
        #[inline(always)]
        pub fn set_lptim1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "TIM10 enable."]
        #[inline(always)]
        pub const fn tim10enc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "TIM10 enable."]
        #[inline(always)]
        pub fn set_tim10enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "TIM11 enable."]
        #[inline(always)]
        pub const fn tim11enc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "TIM11 enable."]
        #[inline(always)]
        pub fn set_tim11enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "SPI2 enable."]
        #[inline(always)]
        pub const fn spi2enc(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "SPI2 enable."]
        #[inline(always)]
        pub fn set_spi2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "SPI3 enable."]
        #[inline(always)]
        pub const fn spi3enc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "SPI3 enable."]
        #[inline(always)]
        pub fn set_spi3enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "SPDIFRX1 enable."]
        #[inline(always)]
        pub const fn spdifrx1enc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "SPDIFRX1 enable."]
        #[inline(always)]
        pub fn set_spdifrx1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "USART2 enable."]
        #[inline(always)]
        pub const fn usart2enc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "USART2 enable."]
        #[inline(always)]
        pub fn set_usart2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "USART3 enable."]
        #[inline(always)]
        pub const fn usart3enc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "USART3 enable."]
        #[inline(always)]
        pub fn set_usart3enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "UART4 enable."]
        #[inline(always)]
        pub const fn uart4enc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "UART4 enable."]
        #[inline(always)]
        pub fn set_uart4enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "UART5 enable."]
        #[inline(always)]
        pub const fn uart5enc(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "UART5 enable."]
        #[inline(always)]
        pub fn set_uart5enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "I2C1 enable."]
        #[inline(always)]
        pub const fn i2c1enc(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "I2C1 enable."]
        #[inline(always)]
        pub fn set_i2c1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "I2C2 enable."]
        #[inline(always)]
        pub const fn i2c2enc(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "I2C2 enable."]
        #[inline(always)]
        pub fn set_i2c2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "I2C3 enable."]
        #[inline(always)]
        pub const fn i2c3enc(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "I2C3 enable."]
        #[inline(always)]
        pub fn set_i2c3enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "I3C1 enable."]
        #[inline(always)]
        pub const fn i3c1enc(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "I3C1 enable."]
        #[inline(always)]
        pub fn set_i3c1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "I3C2 enable."]
        #[inline(always)]
        pub const fn i3c2enc(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "I3C2 enable."]
        #[inline(always)]
        pub fn set_i3c2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "UART7 enable."]
        #[inline(always)]
        pub const fn uart7enc(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "UART7 enable."]
        #[inline(always)]
        pub fn set_uart7enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "UART8 enable."]
        #[inline(always)]
        pub const fn uart8enc(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "UART8 enable."]
        #[inline(always)]
        pub fn set_uart8enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb1lencr {
        #[inline(always)]
        fn default() -> Apb1lencr {
            Apb1lencr(0)
        }
    }
    impl core::fmt::Debug for Apb1lencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1lencr")
                .field("tim2enc", &self.tim2enc())
                .field("tim3enc", &self.tim3enc())
                .field("tim4enc", &self.tim4enc())
                .field("tim5enc", &self.tim5enc())
                .field("tim6enc", &self.tim6enc())
                .field("tim7enc", &self.tim7enc())
                .field("tim12enc", &self.tim12enc())
                .field("tim13enc", &self.tim13enc())
                .field("tim14enc", &self.tim14enc())
                .field("lptim1enc", &self.lptim1enc())
                .field("tim10enc", &self.tim10enc())
                .field("tim11enc", &self.tim11enc())
                .field("spi2enc", &self.spi2enc())
                .field("spi3enc", &self.spi3enc())
                .field("spdifrx1enc", &self.spdifrx1enc())
                .field("usart2enc", &self.usart2enc())
                .field("usart3enc", &self.usart3enc())
                .field("uart4enc", &self.uart4enc())
                .field("uart5enc", &self.uart5enc())
                .field("i2c1enc", &self.i2c1enc())
                .field("i2c2enc", &self.i2c2enc())
                .field("i2c3enc", &self.i2c3enc())
                .field("i3c1enc", &self.i3c1enc())
                .field("i3c2enc", &self.i3c2enc())
                .field("uart7enc", &self.uart7enc())
                .field("uart8enc", &self.uart8enc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1lencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb1lencr {{ tim2enc: {=bool:?}, tim3enc: {=bool:?}, tim4enc: {=bool:?}, tim5enc: {=bool:?}, tim6enc: {=bool:?}, tim7enc: {=bool:?}, tim12enc: {=bool:?}, tim13enc: {=bool:?}, tim14enc: {=bool:?}, lptim1enc: {=bool:?}, tim10enc: {=bool:?}, tim11enc: {=bool:?}, spi2enc: {=bool:?}, spi3enc: {=bool:?}, spdifrx1enc: {=bool:?}, usart2enc: {=bool:?}, usart3enc: {=bool:?}, uart4enc: {=bool:?}, uart5enc: {=bool:?}, i2c1enc: {=bool:?}, i2c2enc: {=bool:?}, i2c3enc: {=bool:?}, i3c1enc: {=bool:?}, i3c2enc: {=bool:?}, uart7enc: {=bool:?}, uart8enc: {=bool:?} }}" , self . tim2enc () , self . tim3enc () , self . tim4enc () , self . tim5enc () , self . tim6enc () , self . tim7enc () , self . tim12enc () , self . tim13enc () , self . tim14enc () , self . lptim1enc () , self . tim10enc () , self . tim11enc () , self . spi2enc () , self . spi3enc () , self . spdifrx1enc () , self . usart2enc () , self . usart3enc () , self . uart4enc () , self . uart5enc () , self . i2c1enc () , self . i2c2enc () , self . i2c3enc () , self . i3c1enc () , self . i3c2enc () , self . uart7enc () , self . uart8enc ())
        }
    }
    #[doc = "RCC APB1L enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1lenr(pub u32);
    impl Apb1lenr {
        #[doc = "TIM2 enable."]
        #[inline(always)]
        pub const fn tim2en(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM2 enable."]
        #[inline(always)]
        pub fn set_tim2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM3 enable."]
        #[inline(always)]
        pub const fn tim3en(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM3 enable."]
        #[inline(always)]
        pub fn set_tim3en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "TIM4 enable."]
        #[inline(always)]
        pub const fn tim4en(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "TIM4 enable."]
        #[inline(always)]
        pub fn set_tim4en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "TIM5 enable."]
        #[inline(always)]
        pub const fn tim5en(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "TIM5 enable."]
        #[inline(always)]
        pub fn set_tim5en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "TIM6 enable."]
        #[inline(always)]
        pub const fn tim6en(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "TIM6 enable."]
        #[inline(always)]
        pub fn set_tim6en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "TIM7 enable."]
        #[inline(always)]
        pub const fn tim7en(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "TIM7 enable."]
        #[inline(always)]
        pub fn set_tim7en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "TIM12 enable."]
        #[inline(always)]
        pub const fn tim12en(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "TIM12 enable."]
        #[inline(always)]
        pub fn set_tim12en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "TIM13 enable."]
        #[inline(always)]
        pub const fn tim13en(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "TIM13 enable."]
        #[inline(always)]
        pub fn set_tim13en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "TIM14 enable."]
        #[inline(always)]
        pub const fn tim14en(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "TIM14 enable."]
        #[inline(always)]
        pub fn set_tim14en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "LPTIM1 enable."]
        #[inline(always)]
        pub const fn lptim1en(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM1 enable."]
        #[inline(always)]
        pub fn set_lptim1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "WWDG enable."]
        #[inline(always)]
        pub const fn wwdgen(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "WWDG enable."]
        #[inline(always)]
        pub fn set_wwdgen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "TIM10 enable."]
        #[inline(always)]
        pub const fn tim10en(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "TIM10 enable."]
        #[inline(always)]
        pub fn set_tim10en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "TIM11 enable."]
        #[inline(always)]
        pub const fn tim11en(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "TIM11 enable."]
        #[inline(always)]
        pub fn set_tim11en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "SPI2 enable."]
        #[inline(always)]
        pub const fn spi2en(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "SPI2 enable."]
        #[inline(always)]
        pub fn set_spi2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "SPI3 enable."]
        #[inline(always)]
        pub const fn spi3en(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "SPI3 enable."]
        #[inline(always)]
        pub fn set_spi3en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "SPDIFRX1 enable."]
        #[inline(always)]
        pub const fn spdifrx1en(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "SPDIFRX1 enable."]
        #[inline(always)]
        pub fn set_spdifrx1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "USART2 enable."]
        #[inline(always)]
        pub const fn usart2en(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "USART2 enable."]
        #[inline(always)]
        pub fn set_usart2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "USART3 enable."]
        #[inline(always)]
        pub const fn usart3en(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "USART3 enable."]
        #[inline(always)]
        pub fn set_usart3en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "UART4 enable."]
        #[inline(always)]
        pub const fn uart4en(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "UART4 enable."]
        #[inline(always)]
        pub fn set_uart4en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "UART5 enable."]
        #[inline(always)]
        pub const fn uart5en(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "UART5 enable."]
        #[inline(always)]
        pub fn set_uart5en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "I2C1 enable."]
        #[inline(always)]
        pub const fn i2c1en(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "I2C1 enable."]
        #[inline(always)]
        pub fn set_i2c1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "I2C2 enable."]
        #[inline(always)]
        pub const fn i2c2en(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "I2C2 enable."]
        #[inline(always)]
        pub fn set_i2c2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "I2C3 enable."]
        #[inline(always)]
        pub const fn i2c3en(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "I2C3 enable."]
        #[inline(always)]
        pub fn set_i2c3en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "I3C1 enable."]
        #[inline(always)]
        pub const fn i3c1en(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "I3C1 enable."]
        #[inline(always)]
        pub fn set_i3c1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "I3C2 enable."]
        #[inline(always)]
        pub const fn i3c2en(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "I3C2 enable."]
        #[inline(always)]
        pub fn set_i3c2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "UART7 enable."]
        #[inline(always)]
        pub const fn uart7en(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "UART7 enable."]
        #[inline(always)]
        pub fn set_uart7en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "UART8 enable."]
        #[inline(always)]
        pub const fn uart8en(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "UART8 enable."]
        #[inline(always)]
        pub fn set_uart8en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb1lenr {
        #[inline(always)]
        fn default() -> Apb1lenr {
            Apb1lenr(0)
        }
    }
    impl core::fmt::Debug for Apb1lenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1lenr")
                .field("tim2en", &self.tim2en())
                .field("tim3en", &self.tim3en())
                .field("tim4en", &self.tim4en())
                .field("tim5en", &self.tim5en())
                .field("tim6en", &self.tim6en())
                .field("tim7en", &self.tim7en())
                .field("tim12en", &self.tim12en())
                .field("tim13en", &self.tim13en())
                .field("tim14en", &self.tim14en())
                .field("lptim1en", &self.lptim1en())
                .field("wwdgen", &self.wwdgen())
                .field("tim10en", &self.tim10en())
                .field("tim11en", &self.tim11en())
                .field("spi2en", &self.spi2en())
                .field("spi3en", &self.spi3en())
                .field("spdifrx1en", &self.spdifrx1en())
                .field("usart2en", &self.usart2en())
                .field("usart3en", &self.usart3en())
                .field("uart4en", &self.uart4en())
                .field("uart5en", &self.uart5en())
                .field("i2c1en", &self.i2c1en())
                .field("i2c2en", &self.i2c2en())
                .field("i2c3en", &self.i2c3en())
                .field("i3c1en", &self.i3c1en())
                .field("i3c2en", &self.i3c2en())
                .field("uart7en", &self.uart7en())
                .field("uart8en", &self.uart8en())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1lenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb1lenr {{ tim2en: {=bool:?}, tim3en: {=bool:?}, tim4en: {=bool:?}, tim5en: {=bool:?}, tim6en: {=bool:?}, tim7en: {=bool:?}, tim12en: {=bool:?}, tim13en: {=bool:?}, tim14en: {=bool:?}, lptim1en: {=bool:?}, wwdgen: {=bool:?}, tim10en: {=bool:?}, tim11en: {=bool:?}, spi2en: {=bool:?}, spi3en: {=bool:?}, spdifrx1en: {=bool:?}, usart2en: {=bool:?}, usart3en: {=bool:?}, uart4en: {=bool:?}, uart5en: {=bool:?}, i2c1en: {=bool:?}, i2c2en: {=bool:?}, i2c3en: {=bool:?}, i3c1en: {=bool:?}, i3c2en: {=bool:?}, uart7en: {=bool:?}, uart8en: {=bool:?} }}" , self . tim2en () , self . tim3en () , self . tim4en () , self . tim5en () , self . tim6en () , self . tim7en () , self . tim12en () , self . tim13en () , self . tim14en () , self . lptim1en () , self . wwdgen () , self . tim10en () , self . tim11en () , self . spi2en () , self . spi3en () , self . spdifrx1en () , self . usart2en () , self . usart3en () , self . uart4en () , self . uart5en () , self . i2c1en () , self . i2c2en () , self . i2c3en () , self . i3c1en () , self . i3c2en () , self . uart7en () , self . uart8en ())
        }
    }
    #[doc = "RCC APB1L enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1lensr(pub u32);
    impl Apb1lensr {
        #[doc = "TIM2 enable."]
        #[inline(always)]
        pub const fn tim2ens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM2 enable."]
        #[inline(always)]
        pub fn set_tim2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM3 enable."]
        #[inline(always)]
        pub const fn tim3ens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM3 enable."]
        #[inline(always)]
        pub fn set_tim3ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "TIM4 enable."]
        #[inline(always)]
        pub const fn tim4ens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "TIM4 enable."]
        #[inline(always)]
        pub fn set_tim4ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "TIM5 enable."]
        #[inline(always)]
        pub const fn tim5ens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "TIM5 enable."]
        #[inline(always)]
        pub fn set_tim5ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "TIM6 enable."]
        #[inline(always)]
        pub const fn tim6ens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "TIM6 enable."]
        #[inline(always)]
        pub fn set_tim6ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "TIM7 enable."]
        #[inline(always)]
        pub const fn tim7ens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "TIM7 enable."]
        #[inline(always)]
        pub fn set_tim7ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "TIM12 enable."]
        #[inline(always)]
        pub const fn tim12ens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "TIM12 enable."]
        #[inline(always)]
        pub fn set_tim12ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "TIM13 enable."]
        #[inline(always)]
        pub const fn tim13ens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "TIM13 enable."]
        #[inline(always)]
        pub fn set_tim13ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "TIM14 enable."]
        #[inline(always)]
        pub const fn tim14ens(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "TIM14 enable."]
        #[inline(always)]
        pub fn set_tim14ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "LPTIM1 enable."]
        #[inline(always)]
        pub const fn lptim1ens(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM1 enable."]
        #[inline(always)]
        pub fn set_lptim1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "WWDG enable."]
        #[inline(always)]
        pub const fn wwdgens(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "WWDG enable."]
        #[inline(always)]
        pub fn set_wwdgens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "TIM10 enable."]
        #[inline(always)]
        pub const fn tim10ens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "TIM10 enable."]
        #[inline(always)]
        pub fn set_tim10ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "TIM11 enable."]
        #[inline(always)]
        pub const fn tim11ens(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "TIM11 enable."]
        #[inline(always)]
        pub fn set_tim11ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "SPI2 enable."]
        #[inline(always)]
        pub const fn spi2ens(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "SPI2 enable."]
        #[inline(always)]
        pub fn set_spi2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "SPI3 enable."]
        #[inline(always)]
        pub const fn spi3ens(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "SPI3 enable."]
        #[inline(always)]
        pub fn set_spi3ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "SPDIFRX1 enable."]
        #[inline(always)]
        pub const fn spdifrx1ens(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "SPDIFRX1 enable."]
        #[inline(always)]
        pub fn set_spdifrx1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "USART2 enable."]
        #[inline(always)]
        pub const fn usart2ens(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "USART2 enable."]
        #[inline(always)]
        pub fn set_usart2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "USART3 enable."]
        #[inline(always)]
        pub const fn usart3ens(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "USART3 enable."]
        #[inline(always)]
        pub fn set_usart3ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "UART4 enable."]
        #[inline(always)]
        pub const fn uart4ens(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "UART4 enable."]
        #[inline(always)]
        pub fn set_uart4ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "UART5 enable."]
        #[inline(always)]
        pub const fn uart5ens(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "UART5 enable."]
        #[inline(always)]
        pub fn set_uart5ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "I2C1 enable."]
        #[inline(always)]
        pub const fn i2c1ens(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "I2C1 enable."]
        #[inline(always)]
        pub fn set_i2c1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "I2C2 enable."]
        #[inline(always)]
        pub const fn i2c2ens(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "I2C2 enable."]
        #[inline(always)]
        pub fn set_i2c2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "I2C3 enable."]
        #[inline(always)]
        pub const fn i2c3ens(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "I2C3 enable."]
        #[inline(always)]
        pub fn set_i2c3ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "I3C1 enable."]
        #[inline(always)]
        pub const fn i3c1ens(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "I3C1 enable."]
        #[inline(always)]
        pub fn set_i3c1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "I3C2 enable."]
        #[inline(always)]
        pub const fn i3c2ens(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "I3C2 enable."]
        #[inline(always)]
        pub fn set_i3c2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "UART7 enable."]
        #[inline(always)]
        pub const fn uart7ens(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "UART7 enable."]
        #[inline(always)]
        pub fn set_uart7ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "UART8 enable."]
        #[inline(always)]
        pub const fn uart8ens(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "UART8 enable."]
        #[inline(always)]
        pub fn set_uart8ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb1lensr {
        #[inline(always)]
        fn default() -> Apb1lensr {
            Apb1lensr(0)
        }
    }
    impl core::fmt::Debug for Apb1lensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1lensr")
                .field("tim2ens", &self.tim2ens())
                .field("tim3ens", &self.tim3ens())
                .field("tim4ens", &self.tim4ens())
                .field("tim5ens", &self.tim5ens())
                .field("tim6ens", &self.tim6ens())
                .field("tim7ens", &self.tim7ens())
                .field("tim12ens", &self.tim12ens())
                .field("tim13ens", &self.tim13ens())
                .field("tim14ens", &self.tim14ens())
                .field("lptim1ens", &self.lptim1ens())
                .field("wwdgens", &self.wwdgens())
                .field("tim10ens", &self.tim10ens())
                .field("tim11ens", &self.tim11ens())
                .field("spi2ens", &self.spi2ens())
                .field("spi3ens", &self.spi3ens())
                .field("spdifrx1ens", &self.spdifrx1ens())
                .field("usart2ens", &self.usart2ens())
                .field("usart3ens", &self.usart3ens())
                .field("uart4ens", &self.uart4ens())
                .field("uart5ens", &self.uart5ens())
                .field("i2c1ens", &self.i2c1ens())
                .field("i2c2ens", &self.i2c2ens())
                .field("i2c3ens", &self.i2c3ens())
                .field("i3c1ens", &self.i3c1ens())
                .field("i3c2ens", &self.i3c2ens())
                .field("uart7ens", &self.uart7ens())
                .field("uart8ens", &self.uart8ens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1lensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb1lensr {{ tim2ens: {=bool:?}, tim3ens: {=bool:?}, tim4ens: {=bool:?}, tim5ens: {=bool:?}, tim6ens: {=bool:?}, tim7ens: {=bool:?}, tim12ens: {=bool:?}, tim13ens: {=bool:?}, tim14ens: {=bool:?}, lptim1ens: {=bool:?}, wwdgens: {=bool:?}, tim10ens: {=bool:?}, tim11ens: {=bool:?}, spi2ens: {=bool:?}, spi3ens: {=bool:?}, spdifrx1ens: {=bool:?}, usart2ens: {=bool:?}, usart3ens: {=bool:?}, uart4ens: {=bool:?}, uart5ens: {=bool:?}, i2c1ens: {=bool:?}, i2c2ens: {=bool:?}, i2c3ens: {=bool:?}, i3c1ens: {=bool:?}, i3c2ens: {=bool:?}, uart7ens: {=bool:?}, uart8ens: {=bool:?} }}" , self . tim2ens () , self . tim3ens () , self . tim4ens () , self . tim5ens () , self . tim6ens () , self . tim7ens () , self . tim12ens () , self . tim13ens () , self . tim14ens () , self . lptim1ens () , self . wwdgens () , self . tim10ens () , self . tim11ens () , self . spi2ens () , self . spi3ens () , self . spdifrx1ens () , self . usart2ens () , self . usart3ens () , self . uart4ens () , self . uart5ens () , self . i2c1ens () , self . i2c2ens () , self . i2c3ens () , self . i3c1ens () , self . i3c2ens () , self . uart7ens () , self . uart8ens ())
        }
    }
    #[doc = "RCC APB1L Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1llpencr(pub u32);
    impl Apb1llpencr {
        #[doc = "TIM2 sleep enable."]
        #[inline(always)]
        pub const fn tim2lpenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM2 sleep enable."]
        #[inline(always)]
        pub fn set_tim2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM3 sleep enable."]
        #[inline(always)]
        pub const fn tim3lpenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM3 sleep enable."]
        #[inline(always)]
        pub fn set_tim3lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "TIM4 sleep enable."]
        #[inline(always)]
        pub const fn tim4lpenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "TIM4 sleep enable."]
        #[inline(always)]
        pub fn set_tim4lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "TIM5 sleep enable."]
        #[inline(always)]
        pub const fn tim5lpenc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "TIM5 sleep enable."]
        #[inline(always)]
        pub fn set_tim5lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "TIM6 sleep enable."]
        #[inline(always)]
        pub const fn tim6lpenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "TIM6 sleep enable."]
        #[inline(always)]
        pub fn set_tim6lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "TIM7 sleep enable."]
        #[inline(always)]
        pub const fn tim7lpenc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "TIM7 sleep enable."]
        #[inline(always)]
        pub fn set_tim7lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "TIM12 sleep enable."]
        #[inline(always)]
        pub const fn tim12lpenc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "TIM12 sleep enable."]
        #[inline(always)]
        pub fn set_tim12lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "TIM13 sleep enable."]
        #[inline(always)]
        pub const fn tim13lpenc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "TIM13 sleep enable."]
        #[inline(always)]
        pub fn set_tim13lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "TIM14 sleep enable."]
        #[inline(always)]
        pub const fn tim14lpenc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "TIM14 sleep enable."]
        #[inline(always)]
        pub fn set_tim14lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "LPTIM1 sleep enable."]
        #[inline(always)]
        pub const fn lptim1lpenc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM1 sleep enable."]
        #[inline(always)]
        pub fn set_lptim1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "WWDG sleep enable."]
        #[inline(always)]
        pub const fn wwdglpenc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "WWDG sleep enable."]
        #[inline(always)]
        pub fn set_wwdglpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "TIM10 sleep enable."]
        #[inline(always)]
        pub const fn tim10lpenc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "TIM10 sleep enable."]
        #[inline(always)]
        pub fn set_tim10lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "TIM11 sleep enable."]
        #[inline(always)]
        pub const fn tim11lpenc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "TIM11 sleep enable."]
        #[inline(always)]
        pub fn set_tim11lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "SPI2 sleep enable."]
        #[inline(always)]
        pub const fn spi2lpenc(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "SPI2 sleep enable."]
        #[inline(always)]
        pub fn set_spi2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "SPI3 sleep enable."]
        #[inline(always)]
        pub const fn spi3lpenc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "SPI3 sleep enable."]
        #[inline(always)]
        pub fn set_spi3lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "SPDIFRX1 sleep enable."]
        #[inline(always)]
        pub const fn spdifrx1lpenc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "SPDIFRX1 sleep enable."]
        #[inline(always)]
        pub fn set_spdifrx1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "USART2 sleep enable."]
        #[inline(always)]
        pub const fn usart2lpenc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "USART2 sleep enable."]
        #[inline(always)]
        pub fn set_usart2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "USART3 sleep enable."]
        #[inline(always)]
        pub const fn usart3lpenc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "USART3 sleep enable."]
        #[inline(always)]
        pub fn set_usart3lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "UART4 sleep enable."]
        #[inline(always)]
        pub const fn uart4lpenc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "UART4 sleep enable."]
        #[inline(always)]
        pub fn set_uart4lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "UART5 sleep enable."]
        #[inline(always)]
        pub const fn uart5lpenc(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "UART5 sleep enable."]
        #[inline(always)]
        pub fn set_uart5lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "I2C1 sleep enable."]
        #[inline(always)]
        pub const fn i2c1lpenc(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "I2C1 sleep enable."]
        #[inline(always)]
        pub fn set_i2c1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "I2C2 sleep enable."]
        #[inline(always)]
        pub const fn i2c2lpenc(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "I2C2 sleep enable."]
        #[inline(always)]
        pub fn set_i2c2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "I2C3 sleep enable."]
        #[inline(always)]
        pub const fn i2c3lpenc(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "I2C3 sleep enable."]
        #[inline(always)]
        pub fn set_i2c3lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "I3C1 sleep enable."]
        #[inline(always)]
        pub const fn i3c1lpenc(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "I3C1 sleep enable."]
        #[inline(always)]
        pub fn set_i3c1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "I3C2 sleep enable."]
        #[inline(always)]
        pub const fn i3c2lpenc(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "I3C2 sleep enable."]
        #[inline(always)]
        pub fn set_i3c2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "UART7 sleep enable."]
        #[inline(always)]
        pub const fn uart7lpenc(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "UART7 sleep enable."]
        #[inline(always)]
        pub fn set_uart7lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "UART8 sleep enable."]
        #[inline(always)]
        pub const fn uart8lpenc(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "UART8 sleep enable."]
        #[inline(always)]
        pub fn set_uart8lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb1llpencr {
        #[inline(always)]
        fn default() -> Apb1llpencr {
            Apb1llpencr(0)
        }
    }
    impl core::fmt::Debug for Apb1llpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1llpencr")
                .field("tim2lpenc", &self.tim2lpenc())
                .field("tim3lpenc", &self.tim3lpenc())
                .field("tim4lpenc", &self.tim4lpenc())
                .field("tim5lpenc", &self.tim5lpenc())
                .field("tim6lpenc", &self.tim6lpenc())
                .field("tim7lpenc", &self.tim7lpenc())
                .field("tim12lpenc", &self.tim12lpenc())
                .field("tim13lpenc", &self.tim13lpenc())
                .field("tim14lpenc", &self.tim14lpenc())
                .field("lptim1lpenc", &self.lptim1lpenc())
                .field("wwdglpenc", &self.wwdglpenc())
                .field("tim10lpenc", &self.tim10lpenc())
                .field("tim11lpenc", &self.tim11lpenc())
                .field("spi2lpenc", &self.spi2lpenc())
                .field("spi3lpenc", &self.spi3lpenc())
                .field("spdifrx1lpenc", &self.spdifrx1lpenc())
                .field("usart2lpenc", &self.usart2lpenc())
                .field("usart3lpenc", &self.usart3lpenc())
                .field("uart4lpenc", &self.uart4lpenc())
                .field("uart5lpenc", &self.uart5lpenc())
                .field("i2c1lpenc", &self.i2c1lpenc())
                .field("i2c2lpenc", &self.i2c2lpenc())
                .field("i2c3lpenc", &self.i2c3lpenc())
                .field("i3c1lpenc", &self.i3c1lpenc())
                .field("i3c2lpenc", &self.i3c2lpenc())
                .field("uart7lpenc", &self.uart7lpenc())
                .field("uart8lpenc", &self.uart8lpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1llpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb1llpencr {{ tim2lpenc: {=bool:?}, tim3lpenc: {=bool:?}, tim4lpenc: {=bool:?}, tim5lpenc: {=bool:?}, tim6lpenc: {=bool:?}, tim7lpenc: {=bool:?}, tim12lpenc: {=bool:?}, tim13lpenc: {=bool:?}, tim14lpenc: {=bool:?}, lptim1lpenc: {=bool:?}, wwdglpenc: {=bool:?}, tim10lpenc: {=bool:?}, tim11lpenc: {=bool:?}, spi2lpenc: {=bool:?}, spi3lpenc: {=bool:?}, spdifrx1lpenc: {=bool:?}, usart2lpenc: {=bool:?}, usart3lpenc: {=bool:?}, uart4lpenc: {=bool:?}, uart5lpenc: {=bool:?}, i2c1lpenc: {=bool:?}, i2c2lpenc: {=bool:?}, i2c3lpenc: {=bool:?}, i3c1lpenc: {=bool:?}, i3c2lpenc: {=bool:?}, uart7lpenc: {=bool:?}, uart8lpenc: {=bool:?} }}" , self . tim2lpenc () , self . tim3lpenc () , self . tim4lpenc () , self . tim5lpenc () , self . tim6lpenc () , self . tim7lpenc () , self . tim12lpenc () , self . tim13lpenc () , self . tim14lpenc () , self . lptim1lpenc () , self . wwdglpenc () , self . tim10lpenc () , self . tim11lpenc () , self . spi2lpenc () , self . spi3lpenc () , self . spdifrx1lpenc () , self . usart2lpenc () , self . usart3lpenc () , self . uart4lpenc () , self . uart5lpenc () , self . i2c1lpenc () , self . i2c2lpenc () , self . i2c3lpenc () , self . i3c1lpenc () , self . i3c2lpenc () , self . uart7lpenc () , self . uart8lpenc ())
        }
    }
    #[doc = "RCC APB1L Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1llpenr(pub u32);
    impl Apb1llpenr {
        #[doc = "TIM2 sleep enable."]
        #[inline(always)]
        pub const fn tim2lpen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM2 sleep enable."]
        #[inline(always)]
        pub fn set_tim2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM3 sleep enable."]
        #[inline(always)]
        pub const fn tim3lpen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM3 sleep enable."]
        #[inline(always)]
        pub fn set_tim3lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "TIM4 sleep enable."]
        #[inline(always)]
        pub const fn tim4lpen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "TIM4 sleep enable."]
        #[inline(always)]
        pub fn set_tim4lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "TIM5 sleep enable."]
        #[inline(always)]
        pub const fn tim5lpen(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "TIM5 sleep enable."]
        #[inline(always)]
        pub fn set_tim5lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "TIM6 sleep enable."]
        #[inline(always)]
        pub const fn tim6lpen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "TIM6 sleep enable."]
        #[inline(always)]
        pub fn set_tim6lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "TIM7 sleep enable."]
        #[inline(always)]
        pub const fn tim7lpen(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "TIM7 sleep enable."]
        #[inline(always)]
        pub fn set_tim7lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "TIM12 sleep enable."]
        #[inline(always)]
        pub const fn tim12lpen(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "TIM12 sleep enable."]
        #[inline(always)]
        pub fn set_tim12lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "TIM13 sleep enable."]
        #[inline(always)]
        pub const fn tim13lpen(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "TIM13 sleep enable."]
        #[inline(always)]
        pub fn set_tim13lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "TIM14 sleep enable."]
        #[inline(always)]
        pub const fn tim14lpen(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "TIM14 sleep enable."]
        #[inline(always)]
        pub fn set_tim14lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "LPTIM1 sleep enable."]
        #[inline(always)]
        pub const fn lptim1lpen(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM1 sleep enable."]
        #[inline(always)]
        pub fn set_lptim1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "WWDG sleep enable."]
        #[inline(always)]
        pub const fn wwdglpen(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "WWDG sleep enable."]
        #[inline(always)]
        pub fn set_wwdglpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "TIM10 sleep enable."]
        #[inline(always)]
        pub const fn tim10lpen(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "TIM10 sleep enable."]
        #[inline(always)]
        pub fn set_tim10lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "TIM11 sleep enable."]
        #[inline(always)]
        pub const fn tim11lpen(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "TIM11 sleep enable."]
        #[inline(always)]
        pub fn set_tim11lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "SPI2 sleep enable."]
        #[inline(always)]
        pub const fn spi2lpen(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "SPI2 sleep enable."]
        #[inline(always)]
        pub fn set_spi2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "SPI3 sleep enable."]
        #[inline(always)]
        pub const fn spi3lpen(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "SPI3 sleep enable."]
        #[inline(always)]
        pub fn set_spi3lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "SPDIFRX1 sleep enable."]
        #[inline(always)]
        pub const fn spdifrx1lpen(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "SPDIFRX1 sleep enable."]
        #[inline(always)]
        pub fn set_spdifrx1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "USART2 sleep enable."]
        #[inline(always)]
        pub const fn usart2lpen(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "USART2 sleep enable."]
        #[inline(always)]
        pub fn set_usart2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "USART3 sleep enable."]
        #[inline(always)]
        pub const fn usart3lpen(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "USART3 sleep enable."]
        #[inline(always)]
        pub fn set_usart3lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "UART4 sleep enable."]
        #[inline(always)]
        pub const fn uart4lpen(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "UART4 sleep enable."]
        #[inline(always)]
        pub fn set_uart4lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "UART5 sleep enable."]
        #[inline(always)]
        pub const fn uart5lpen(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "UART5 sleep enable."]
        #[inline(always)]
        pub fn set_uart5lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "I2C1 sleep enable."]
        #[inline(always)]
        pub const fn i2c1lpen(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "I2C1 sleep enable."]
        #[inline(always)]
        pub fn set_i2c1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "I2C2 sleep enable."]
        #[inline(always)]
        pub const fn i2c2lpen(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "I2C2 sleep enable."]
        #[inline(always)]
        pub fn set_i2c2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "I2C3 sleep enable."]
        #[inline(always)]
        pub const fn i2c3lpen(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "I2C3 sleep enable."]
        #[inline(always)]
        pub fn set_i2c3lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "I3C1 sleep enable."]
        #[inline(always)]
        pub const fn i3c1lpen(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "I3C1 sleep enable."]
        #[inline(always)]
        pub fn set_i3c1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "I3C2 sleep enable."]
        #[inline(always)]
        pub const fn i3c2lpen(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "I3C2 sleep enable."]
        #[inline(always)]
        pub fn set_i3c2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "UART7 sleep enable."]
        #[inline(always)]
        pub const fn uart7lpen(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "UART7 sleep enable."]
        #[inline(always)]
        pub fn set_uart7lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "UART8 sleep enable."]
        #[inline(always)]
        pub const fn uart8lpen(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "UART8 sleep enable."]
        #[inline(always)]
        pub fn set_uart8lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb1llpenr {
        #[inline(always)]
        fn default() -> Apb1llpenr {
            Apb1llpenr(0)
        }
    }
    impl core::fmt::Debug for Apb1llpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1llpenr")
                .field("tim2lpen", &self.tim2lpen())
                .field("tim3lpen", &self.tim3lpen())
                .field("tim4lpen", &self.tim4lpen())
                .field("tim5lpen", &self.tim5lpen())
                .field("tim6lpen", &self.tim6lpen())
                .field("tim7lpen", &self.tim7lpen())
                .field("tim12lpen", &self.tim12lpen())
                .field("tim13lpen", &self.tim13lpen())
                .field("tim14lpen", &self.tim14lpen())
                .field("lptim1lpen", &self.lptim1lpen())
                .field("wwdglpen", &self.wwdglpen())
                .field("tim10lpen", &self.tim10lpen())
                .field("tim11lpen", &self.tim11lpen())
                .field("spi2lpen", &self.spi2lpen())
                .field("spi3lpen", &self.spi3lpen())
                .field("spdifrx1lpen", &self.spdifrx1lpen())
                .field("usart2lpen", &self.usart2lpen())
                .field("usart3lpen", &self.usart3lpen())
                .field("uart4lpen", &self.uart4lpen())
                .field("uart5lpen", &self.uart5lpen())
                .field("i2c1lpen", &self.i2c1lpen())
                .field("i2c2lpen", &self.i2c2lpen())
                .field("i2c3lpen", &self.i2c3lpen())
                .field("i3c1lpen", &self.i3c1lpen())
                .field("i3c2lpen", &self.i3c2lpen())
                .field("uart7lpen", &self.uart7lpen())
                .field("uart8lpen", &self.uart8lpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1llpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb1llpenr {{ tim2lpen: {=bool:?}, tim3lpen: {=bool:?}, tim4lpen: {=bool:?}, tim5lpen: {=bool:?}, tim6lpen: {=bool:?}, tim7lpen: {=bool:?}, tim12lpen: {=bool:?}, tim13lpen: {=bool:?}, tim14lpen: {=bool:?}, lptim1lpen: {=bool:?}, wwdglpen: {=bool:?}, tim10lpen: {=bool:?}, tim11lpen: {=bool:?}, spi2lpen: {=bool:?}, spi3lpen: {=bool:?}, spdifrx1lpen: {=bool:?}, usart2lpen: {=bool:?}, usart3lpen: {=bool:?}, uart4lpen: {=bool:?}, uart5lpen: {=bool:?}, i2c1lpen: {=bool:?}, i2c2lpen: {=bool:?}, i2c3lpen: {=bool:?}, i3c1lpen: {=bool:?}, i3c2lpen: {=bool:?}, uart7lpen: {=bool:?}, uart8lpen: {=bool:?} }}" , self . tim2lpen () , self . tim3lpen () , self . tim4lpen () , self . tim5lpen () , self . tim6lpen () , self . tim7lpen () , self . tim12lpen () , self . tim13lpen () , self . tim14lpen () , self . lptim1lpen () , self . wwdglpen () , self . tim10lpen () , self . tim11lpen () , self . spi2lpen () , self . spi3lpen () , self . spdifrx1lpen () , self . usart2lpen () , self . usart3lpen () , self . uart4lpen () , self . uart5lpen () , self . i2c1lpen () , self . i2c2lpen () , self . i2c3lpen () , self . i3c1lpen () , self . i3c2lpen () , self . uart7lpen () , self . uart8lpen ())
        }
    }
    #[doc = "RCC APB1L Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1llpensr(pub u32);
    impl Apb1llpensr {
        #[doc = "TIM2 sleep enable."]
        #[inline(always)]
        pub const fn tim2lpens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM2 sleep enable."]
        #[inline(always)]
        pub fn set_tim2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM3 sleep enable."]
        #[inline(always)]
        pub const fn tim3lpens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM3 sleep enable."]
        #[inline(always)]
        pub fn set_tim3lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "TIM4 sleep enable."]
        #[inline(always)]
        pub const fn tim4lpens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "TIM4 sleep enable."]
        #[inline(always)]
        pub fn set_tim4lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "TIM5 sleep enable."]
        #[inline(always)]
        pub const fn tim5lpens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "TIM5 sleep enable."]
        #[inline(always)]
        pub fn set_tim5lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "TIM6 sleep enable."]
        #[inline(always)]
        pub const fn tim6lpens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "TIM6 sleep enable."]
        #[inline(always)]
        pub fn set_tim6lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "TIM7 sleep enable."]
        #[inline(always)]
        pub const fn tim7lpens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "TIM7 sleep enable."]
        #[inline(always)]
        pub fn set_tim7lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "TIM12 sleep enable."]
        #[inline(always)]
        pub const fn tim12lpens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "TIM12 sleep enable."]
        #[inline(always)]
        pub fn set_tim12lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "TIM13 sleep enable."]
        #[inline(always)]
        pub const fn tim13lpens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "TIM13 sleep enable."]
        #[inline(always)]
        pub fn set_tim13lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "TIM14 sleep enable."]
        #[inline(always)]
        pub const fn tim14lpens(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "TIM14 sleep enable."]
        #[inline(always)]
        pub fn set_tim14lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "LPTIM1 sleep enable."]
        #[inline(always)]
        pub const fn lptim1lpens(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM1 sleep enable."]
        #[inline(always)]
        pub fn set_lptim1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "WWDG sleep enable."]
        #[inline(always)]
        pub const fn wwdglpens(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "WWDG sleep enable."]
        #[inline(always)]
        pub fn set_wwdglpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "TIM10 sleep enable."]
        #[inline(always)]
        pub const fn tim10lpens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "TIM10 sleep enable."]
        #[inline(always)]
        pub fn set_tim10lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "TIM11 sleep enable."]
        #[inline(always)]
        pub const fn tim11lpens(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "TIM11 sleep enable."]
        #[inline(always)]
        pub fn set_tim11lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "SPI2 sleep enable."]
        #[inline(always)]
        pub const fn spi2lpens(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "SPI2 sleep enable."]
        #[inline(always)]
        pub fn set_spi2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "SPI3 sleep enable."]
        #[inline(always)]
        pub const fn spi3lpens(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "SPI3 sleep enable."]
        #[inline(always)]
        pub fn set_spi3lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "SPDIFRX1 sleep enable."]
        #[inline(always)]
        pub const fn spdifrx1lpens(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "SPDIFRX1 sleep enable."]
        #[inline(always)]
        pub fn set_spdifrx1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "USART2 sleep enable."]
        #[inline(always)]
        pub const fn usart2lpens(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "USART2 sleep enable."]
        #[inline(always)]
        pub fn set_usart2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "USART3 sleep enable."]
        #[inline(always)]
        pub const fn usart3lpens(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "USART3 sleep enable."]
        #[inline(always)]
        pub fn set_usart3lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "UART4 sleep enable."]
        #[inline(always)]
        pub const fn uart4lpens(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "UART4 sleep enable."]
        #[inline(always)]
        pub fn set_uart4lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "UART5 sleep enable."]
        #[inline(always)]
        pub const fn uart5lpens(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "UART5 sleep enable."]
        #[inline(always)]
        pub fn set_uart5lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "I2C1 sleep enable."]
        #[inline(always)]
        pub const fn i2c1lpens(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "I2C1 sleep enable."]
        #[inline(always)]
        pub fn set_i2c1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "I2C2 sleep enable."]
        #[inline(always)]
        pub const fn i2c2lpens(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "I2C2 sleep enable."]
        #[inline(always)]
        pub fn set_i2c2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "I2C3 sleep enable."]
        #[inline(always)]
        pub const fn i2c3lpens(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "I2C3 sleep enable."]
        #[inline(always)]
        pub fn set_i2c3lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "I3C1 sleep enable."]
        #[inline(always)]
        pub const fn i3c1lpens(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "I3C1 sleep enable."]
        #[inline(always)]
        pub fn set_i3c1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "I3C2 sleep enable."]
        #[inline(always)]
        pub const fn i3c2lpens(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "I3C2 sleep enable."]
        #[inline(always)]
        pub fn set_i3c2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "UART7 sleep enable."]
        #[inline(always)]
        pub const fn uart7lpens(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "UART7 sleep enable."]
        #[inline(always)]
        pub fn set_uart7lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "UART8 sleep enable."]
        #[inline(always)]
        pub const fn uart8lpens(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "UART8 sleep enable."]
        #[inline(always)]
        pub fn set_uart8lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb1llpensr {
        #[inline(always)]
        fn default() -> Apb1llpensr {
            Apb1llpensr(0)
        }
    }
    impl core::fmt::Debug for Apb1llpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1llpensr")
                .field("tim2lpens", &self.tim2lpens())
                .field("tim3lpens", &self.tim3lpens())
                .field("tim4lpens", &self.tim4lpens())
                .field("tim5lpens", &self.tim5lpens())
                .field("tim6lpens", &self.tim6lpens())
                .field("tim7lpens", &self.tim7lpens())
                .field("tim12lpens", &self.tim12lpens())
                .field("tim13lpens", &self.tim13lpens())
                .field("tim14lpens", &self.tim14lpens())
                .field("lptim1lpens", &self.lptim1lpens())
                .field("wwdglpens", &self.wwdglpens())
                .field("tim10lpens", &self.tim10lpens())
                .field("tim11lpens", &self.tim11lpens())
                .field("spi2lpens", &self.spi2lpens())
                .field("spi3lpens", &self.spi3lpens())
                .field("spdifrx1lpens", &self.spdifrx1lpens())
                .field("usart2lpens", &self.usart2lpens())
                .field("usart3lpens", &self.usart3lpens())
                .field("uart4lpens", &self.uart4lpens())
                .field("uart5lpens", &self.uart5lpens())
                .field("i2c1lpens", &self.i2c1lpens())
                .field("i2c2lpens", &self.i2c2lpens())
                .field("i2c3lpens", &self.i2c3lpens())
                .field("i3c1lpens", &self.i3c1lpens())
                .field("i3c2lpens", &self.i3c2lpens())
                .field("uart7lpens", &self.uart7lpens())
                .field("uart8lpens", &self.uart8lpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1llpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb1llpensr {{ tim2lpens: {=bool:?}, tim3lpens: {=bool:?}, tim4lpens: {=bool:?}, tim5lpens: {=bool:?}, tim6lpens: {=bool:?}, tim7lpens: {=bool:?}, tim12lpens: {=bool:?}, tim13lpens: {=bool:?}, tim14lpens: {=bool:?}, lptim1lpens: {=bool:?}, wwdglpens: {=bool:?}, tim10lpens: {=bool:?}, tim11lpens: {=bool:?}, spi2lpens: {=bool:?}, spi3lpens: {=bool:?}, spdifrx1lpens: {=bool:?}, usart2lpens: {=bool:?}, usart3lpens: {=bool:?}, uart4lpens: {=bool:?}, uart5lpens: {=bool:?}, i2c1lpens: {=bool:?}, i2c2lpens: {=bool:?}, i2c3lpens: {=bool:?}, i3c1lpens: {=bool:?}, i3c2lpens: {=bool:?}, uart7lpens: {=bool:?}, uart8lpens: {=bool:?} }}" , self . tim2lpens () , self . tim3lpens () , self . tim4lpens () , self . tim5lpens () , self . tim6lpens () , self . tim7lpens () , self . tim12lpens () , self . tim13lpens () , self . tim14lpens () , self . lptim1lpens () , self . wwdglpens () , self . tim10lpens () , self . tim11lpens () , self . spi2lpens () , self . spi3lpens () , self . spdifrx1lpens () , self . usart2lpens () , self . usart3lpens () , self . uart4lpens () , self . uart5lpens () , self . i2c1lpens () , self . i2c2lpens () , self . i2c3lpens () , self . i3c1lpens () , self . i3c2lpens () , self . uart7lpens () , self . uart8lpens ())
        }
    }
    #[doc = "RCC APB1L reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1lrstcr(pub u32);
    impl Apb1lrstcr {
        #[doc = "TIM2 reset."]
        #[inline(always)]
        pub const fn tim2rstc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM2 reset."]
        #[inline(always)]
        pub fn set_tim2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM3 reset."]
        #[inline(always)]
        pub const fn tim3rstc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM3 reset."]
        #[inline(always)]
        pub fn set_tim3rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "TIM4 reset."]
        #[inline(always)]
        pub const fn tim4rstc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "TIM4 reset."]
        #[inline(always)]
        pub fn set_tim4rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "TIM5 reset."]
        #[inline(always)]
        pub const fn tim5rstc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "TIM5 reset."]
        #[inline(always)]
        pub fn set_tim5rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "TIM6 reset."]
        #[inline(always)]
        pub const fn tim6rstc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "TIM6 reset."]
        #[inline(always)]
        pub fn set_tim6rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "TIM7 reset."]
        #[inline(always)]
        pub const fn tim7rstc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "TIM7 reset."]
        #[inline(always)]
        pub fn set_tim7rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "TIM12 reset."]
        #[inline(always)]
        pub const fn tim12rstc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "TIM12 reset."]
        #[inline(always)]
        pub fn set_tim12rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "TIM13 reset."]
        #[inline(always)]
        pub const fn tim13rstc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "TIM13 reset."]
        #[inline(always)]
        pub fn set_tim13rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "TIM14 reset."]
        #[inline(always)]
        pub const fn tim14rstc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "TIM14 reset."]
        #[inline(always)]
        pub fn set_tim14rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "LPTIM1 reset."]
        #[inline(always)]
        pub const fn lptim1rstc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM1 reset."]
        #[inline(always)]
        pub fn set_lptim1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "WWDG reset."]
        #[inline(always)]
        pub const fn wwdgrstc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "WWDG reset."]
        #[inline(always)]
        pub fn set_wwdgrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "TIM10 reset."]
        #[inline(always)]
        pub const fn tim10rstc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "TIM10 reset."]
        #[inline(always)]
        pub fn set_tim10rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "TIM11 reset."]
        #[inline(always)]
        pub const fn tim11rstc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "TIM11 reset."]
        #[inline(always)]
        pub fn set_tim11rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "SPI2 reset."]
        #[inline(always)]
        pub const fn spi2rstc(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "SPI2 reset."]
        #[inline(always)]
        pub fn set_spi2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "SPI3 reset."]
        #[inline(always)]
        pub const fn spi3rstc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "SPI3 reset."]
        #[inline(always)]
        pub fn set_spi3rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "SPDIFRX1 reset."]
        #[inline(always)]
        pub const fn spdifrx1rstc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "SPDIFRX1 reset."]
        #[inline(always)]
        pub fn set_spdifrx1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "USART2 reset."]
        #[inline(always)]
        pub const fn usart2rstc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "USART2 reset."]
        #[inline(always)]
        pub fn set_usart2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "USART3 reset."]
        #[inline(always)]
        pub const fn usart3rstc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "USART3 reset."]
        #[inline(always)]
        pub fn set_usart3rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "UART4 reset."]
        #[inline(always)]
        pub const fn uart4rstc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "UART4 reset."]
        #[inline(always)]
        pub fn set_uart4rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "UART5 reset."]
        #[inline(always)]
        pub const fn uart5rstc(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "UART5 reset."]
        #[inline(always)]
        pub fn set_uart5rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "I2C1 reset."]
        #[inline(always)]
        pub const fn i2c1rstc(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "I2C1 reset."]
        #[inline(always)]
        pub fn set_i2c1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "I2C2 reset."]
        #[inline(always)]
        pub const fn i2c2rstc(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "I2C2 reset."]
        #[inline(always)]
        pub fn set_i2c2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "I2C3 reset."]
        #[inline(always)]
        pub const fn i2c3rstc(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "I2C3 reset."]
        #[inline(always)]
        pub fn set_i2c3rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "I3C1 reset."]
        #[inline(always)]
        pub const fn i3c1rstc(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "I3C1 reset."]
        #[inline(always)]
        pub fn set_i3c1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "I3C2 reset."]
        #[inline(always)]
        pub const fn i3c2rstc(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "I3C2 reset."]
        #[inline(always)]
        pub fn set_i3c2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "UART7 reset."]
        #[inline(always)]
        pub const fn uart7rstc(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "UART7 reset."]
        #[inline(always)]
        pub fn set_uart7rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "UART8 reset."]
        #[inline(always)]
        pub const fn uart8rstc(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "UART8 reset."]
        #[inline(always)]
        pub fn set_uart8rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb1lrstcr {
        #[inline(always)]
        fn default() -> Apb1lrstcr {
            Apb1lrstcr(0)
        }
    }
    impl core::fmt::Debug for Apb1lrstcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1lrstcr")
                .field("tim2rstc", &self.tim2rstc())
                .field("tim3rstc", &self.tim3rstc())
                .field("tim4rstc", &self.tim4rstc())
                .field("tim5rstc", &self.tim5rstc())
                .field("tim6rstc", &self.tim6rstc())
                .field("tim7rstc", &self.tim7rstc())
                .field("tim12rstc", &self.tim12rstc())
                .field("tim13rstc", &self.tim13rstc())
                .field("tim14rstc", &self.tim14rstc())
                .field("lptim1rstc", &self.lptim1rstc())
                .field("wwdgrstc", &self.wwdgrstc())
                .field("tim10rstc", &self.tim10rstc())
                .field("tim11rstc", &self.tim11rstc())
                .field("spi2rstc", &self.spi2rstc())
                .field("spi3rstc", &self.spi3rstc())
                .field("spdifrx1rstc", &self.spdifrx1rstc())
                .field("usart2rstc", &self.usart2rstc())
                .field("usart3rstc", &self.usart3rstc())
                .field("uart4rstc", &self.uart4rstc())
                .field("uart5rstc", &self.uart5rstc())
                .field("i2c1rstc", &self.i2c1rstc())
                .field("i2c2rstc", &self.i2c2rstc())
                .field("i2c3rstc", &self.i2c3rstc())
                .field("i3c1rstc", &self.i3c1rstc())
                .field("i3c2rstc", &self.i3c2rstc())
                .field("uart7rstc", &self.uart7rstc())
                .field("uart8rstc", &self.uart8rstc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1lrstcr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb1lrstcr {{ tim2rstc: {=bool:?}, tim3rstc: {=bool:?}, tim4rstc: {=bool:?}, tim5rstc: {=bool:?}, tim6rstc: {=bool:?}, tim7rstc: {=bool:?}, tim12rstc: {=bool:?}, tim13rstc: {=bool:?}, tim14rstc: {=bool:?}, lptim1rstc: {=bool:?}, wwdgrstc: {=bool:?}, tim10rstc: {=bool:?}, tim11rstc: {=bool:?}, spi2rstc: {=bool:?}, spi3rstc: {=bool:?}, spdifrx1rstc: {=bool:?}, usart2rstc: {=bool:?}, usart3rstc: {=bool:?}, uart4rstc: {=bool:?}, uart5rstc: {=bool:?}, i2c1rstc: {=bool:?}, i2c2rstc: {=bool:?}, i2c3rstc: {=bool:?}, i3c1rstc: {=bool:?}, i3c2rstc: {=bool:?}, uart7rstc: {=bool:?}, uart8rstc: {=bool:?} }}" , self . tim2rstc () , self . tim3rstc () , self . tim4rstc () , self . tim5rstc () , self . tim6rstc () , self . tim7rstc () , self . tim12rstc () , self . tim13rstc () , self . tim14rstc () , self . lptim1rstc () , self . wwdgrstc () , self . tim10rstc () , self . tim11rstc () , self . spi2rstc () , self . spi3rstc () , self . spdifrx1rstc () , self . usart2rstc () , self . usart3rstc () , self . uart4rstc () , self . uart5rstc () , self . i2c1rstc () , self . i2c2rstc () , self . i2c3rstc () , self . i3c1rstc () , self . i3c2rstc () , self . uart7rstc () , self . uart8rstc ())
        }
    }
    #[doc = "RCC APB1L reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1lrstr(pub u32);
    impl Apb1lrstr {
        #[doc = "TIM2 reset."]
        #[inline(always)]
        pub const fn tim2rst(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM2 reset."]
        #[inline(always)]
        pub fn set_tim2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM3 reset."]
        #[inline(always)]
        pub const fn tim3rst(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM3 reset."]
        #[inline(always)]
        pub fn set_tim3rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "TIM4 reset."]
        #[inline(always)]
        pub const fn tim4rst(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "TIM4 reset."]
        #[inline(always)]
        pub fn set_tim4rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "TIM5 reset."]
        #[inline(always)]
        pub const fn tim5rst(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "TIM5 reset."]
        #[inline(always)]
        pub fn set_tim5rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "TIM6 reset."]
        #[inline(always)]
        pub const fn tim6rst(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "TIM6 reset."]
        #[inline(always)]
        pub fn set_tim6rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "TIM7 reset."]
        #[inline(always)]
        pub const fn tim7rst(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "TIM7 reset."]
        #[inline(always)]
        pub fn set_tim7rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "TIM12 reset."]
        #[inline(always)]
        pub const fn tim12rst(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "TIM12 reset."]
        #[inline(always)]
        pub fn set_tim12rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "TIM13 reset."]
        #[inline(always)]
        pub const fn tim13rst(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "TIM13 reset."]
        #[inline(always)]
        pub fn set_tim13rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "TIM14 reset."]
        #[inline(always)]
        pub const fn tim14rst(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "TIM14 reset."]
        #[inline(always)]
        pub fn set_tim14rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "LPTIM1 reset."]
        #[inline(always)]
        pub const fn lptim1rst(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM1 reset."]
        #[inline(always)]
        pub fn set_lptim1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "WWDG reset."]
        #[inline(always)]
        pub const fn wwdgrst(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "WWDG reset."]
        #[inline(always)]
        pub fn set_wwdgrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "TIM10 reset."]
        #[inline(always)]
        pub const fn tim10rst(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "TIM10 reset."]
        #[inline(always)]
        pub fn set_tim10rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "TIM11 reset."]
        #[inline(always)]
        pub const fn tim11rst(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "TIM11 reset."]
        #[inline(always)]
        pub fn set_tim11rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "SPI2 reset."]
        #[inline(always)]
        pub const fn spi2rst(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "SPI2 reset."]
        #[inline(always)]
        pub fn set_spi2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "SPI3 reset."]
        #[inline(always)]
        pub const fn spi3rst(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "SPI3 reset."]
        #[inline(always)]
        pub fn set_spi3rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "SPDIFRX1 reset."]
        #[inline(always)]
        pub const fn spdifrx1rst(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "SPDIFRX1 reset."]
        #[inline(always)]
        pub fn set_spdifrx1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "USART2 reset."]
        #[inline(always)]
        pub const fn usart2rst(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "USART2 reset."]
        #[inline(always)]
        pub fn set_usart2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "USART3 reset."]
        #[inline(always)]
        pub const fn usart3rst(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "USART3 reset."]
        #[inline(always)]
        pub fn set_usart3rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "UART4 reset."]
        #[inline(always)]
        pub const fn uart4rst(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "UART4 reset."]
        #[inline(always)]
        pub fn set_uart4rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "UART5 reset."]
        #[inline(always)]
        pub const fn uart5rst(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "UART5 reset."]
        #[inline(always)]
        pub fn set_uart5rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "I2C1 reset."]
        #[inline(always)]
        pub const fn i2c1rst(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "I2C1 reset."]
        #[inline(always)]
        pub fn set_i2c1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "I2C2 reset."]
        #[inline(always)]
        pub const fn i2c2rst(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "I2C2 reset."]
        #[inline(always)]
        pub fn set_i2c2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "I2C3 reset."]
        #[inline(always)]
        pub const fn i2c3rst(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "I2C3 reset."]
        #[inline(always)]
        pub fn set_i2c3rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "I3C1 reset."]
        #[inline(always)]
        pub const fn i3c1rst(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "I3C1 reset."]
        #[inline(always)]
        pub fn set_i3c1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "I3C2 reset."]
        #[inline(always)]
        pub const fn i3c2rst(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "I3C2 reset."]
        #[inline(always)]
        pub fn set_i3c2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "UART7 reset."]
        #[inline(always)]
        pub const fn uart7rst(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "UART7 reset."]
        #[inline(always)]
        pub fn set_uart7rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "UART8 reset."]
        #[inline(always)]
        pub const fn uart8rst(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "UART8 reset."]
        #[inline(always)]
        pub fn set_uart8rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb1lrstr {
        #[inline(always)]
        fn default() -> Apb1lrstr {
            Apb1lrstr(0)
        }
    }
    impl core::fmt::Debug for Apb1lrstr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1lrstr")
                .field("tim2rst", &self.tim2rst())
                .field("tim3rst", &self.tim3rst())
                .field("tim4rst", &self.tim4rst())
                .field("tim5rst", &self.tim5rst())
                .field("tim6rst", &self.tim6rst())
                .field("tim7rst", &self.tim7rst())
                .field("tim12rst", &self.tim12rst())
                .field("tim13rst", &self.tim13rst())
                .field("tim14rst", &self.tim14rst())
                .field("lptim1rst", &self.lptim1rst())
                .field("wwdgrst", &self.wwdgrst())
                .field("tim10rst", &self.tim10rst())
                .field("tim11rst", &self.tim11rst())
                .field("spi2rst", &self.spi2rst())
                .field("spi3rst", &self.spi3rst())
                .field("spdifrx1rst", &self.spdifrx1rst())
                .field("usart2rst", &self.usart2rst())
                .field("usart3rst", &self.usart3rst())
                .field("uart4rst", &self.uart4rst())
                .field("uart5rst", &self.uart5rst())
                .field("i2c1rst", &self.i2c1rst())
                .field("i2c2rst", &self.i2c2rst())
                .field("i2c3rst", &self.i2c3rst())
                .field("i3c1rst", &self.i3c1rst())
                .field("i3c2rst", &self.i3c2rst())
                .field("uart7rst", &self.uart7rst())
                .field("uart8rst", &self.uart8rst())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1lrstr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb1lrstr {{ tim2rst: {=bool:?}, tim3rst: {=bool:?}, tim4rst: {=bool:?}, tim5rst: {=bool:?}, tim6rst: {=bool:?}, tim7rst: {=bool:?}, tim12rst: {=bool:?}, tim13rst: {=bool:?}, tim14rst: {=bool:?}, lptim1rst: {=bool:?}, wwdgrst: {=bool:?}, tim10rst: {=bool:?}, tim11rst: {=bool:?}, spi2rst: {=bool:?}, spi3rst: {=bool:?}, spdifrx1rst: {=bool:?}, usart2rst: {=bool:?}, usart3rst: {=bool:?}, uart4rst: {=bool:?}, uart5rst: {=bool:?}, i2c1rst: {=bool:?}, i2c2rst: {=bool:?}, i2c3rst: {=bool:?}, i3c1rst: {=bool:?}, i3c2rst: {=bool:?}, uart7rst: {=bool:?}, uart8rst: {=bool:?} }}" , self . tim2rst () , self . tim3rst () , self . tim4rst () , self . tim5rst () , self . tim6rst () , self . tim7rst () , self . tim12rst () , self . tim13rst () , self . tim14rst () , self . lptim1rst () , self . wwdgrst () , self . tim10rst () , self . tim11rst () , self . spi2rst () , self . spi3rst () , self . spdifrx1rst () , self . usart2rst () , self . usart3rst () , self . uart4rst () , self . uart5rst () , self . i2c1rst () , self . i2c2rst () , self . i2c3rst () , self . i3c1rst () , self . i3c2rst () , self . uart7rst () , self . uart8rst ())
        }
    }
    #[doc = "RCC APB1L reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb1lrstsr(pub u32);
    impl Apb1lrstsr {
        #[doc = "TIM2 reset."]
        #[inline(always)]
        pub const fn tim2rsts(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM2 reset."]
        #[inline(always)]
        pub fn set_tim2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM3 reset."]
        #[inline(always)]
        pub const fn tim3rsts(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM3 reset."]
        #[inline(always)]
        pub fn set_tim3rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "TIM4 reset."]
        #[inline(always)]
        pub const fn tim4rsts(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "TIM4 reset."]
        #[inline(always)]
        pub fn set_tim4rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "TIM5 reset."]
        #[inline(always)]
        pub const fn tim5rsts(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "TIM5 reset."]
        #[inline(always)]
        pub fn set_tim5rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "TIM6 reset."]
        #[inline(always)]
        pub const fn tim6rsts(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "TIM6 reset."]
        #[inline(always)]
        pub fn set_tim6rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "TIM7 reset."]
        #[inline(always)]
        pub const fn tim7rsts(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "TIM7 reset."]
        #[inline(always)]
        pub fn set_tim7rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "TIM12 reset."]
        #[inline(always)]
        pub const fn tim12rsts(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "TIM12 reset."]
        #[inline(always)]
        pub fn set_tim12rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "TIM13 reset."]
        #[inline(always)]
        pub const fn tim13rsts(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "TIM13 reset."]
        #[inline(always)]
        pub fn set_tim13rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "TIM14 reset."]
        #[inline(always)]
        pub const fn tim14rsts(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "TIM14 reset."]
        #[inline(always)]
        pub fn set_tim14rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "LPTIM1 reset."]
        #[inline(always)]
        pub const fn lptim1rsts(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM1 reset."]
        #[inline(always)]
        pub fn set_lptim1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "WWDG reset."]
        #[inline(always)]
        pub const fn wwdgrsts(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "WWDG reset."]
        #[inline(always)]
        pub fn set_wwdgrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "TIM10 reset."]
        #[inline(always)]
        pub const fn tim10rsts(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "TIM10 reset."]
        #[inline(always)]
        pub fn set_tim10rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "TIM11 reset."]
        #[inline(always)]
        pub const fn tim11rsts(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "TIM11 reset."]
        #[inline(always)]
        pub fn set_tim11rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "SPI2 reset."]
        #[inline(always)]
        pub const fn spi2rsts(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "SPI2 reset."]
        #[inline(always)]
        pub fn set_spi2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "SPI3 reset."]
        #[inline(always)]
        pub const fn spi3rsts(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "SPI3 reset."]
        #[inline(always)]
        pub fn set_spi3rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "SPDIFRX1 reset."]
        #[inline(always)]
        pub const fn spdifrx1rsts(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "SPDIFRX1 reset."]
        #[inline(always)]
        pub fn set_spdifrx1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "USART2 reset."]
        #[inline(always)]
        pub const fn usart2rsts(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "USART2 reset."]
        #[inline(always)]
        pub fn set_usart2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "USART3 reset."]
        #[inline(always)]
        pub const fn usart3rsts(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "USART3 reset."]
        #[inline(always)]
        pub fn set_usart3rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "UART4 reset."]
        #[inline(always)]
        pub const fn uart4rsts(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "UART4 reset."]
        #[inline(always)]
        pub fn set_uart4rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "UART5 reset."]
        #[inline(always)]
        pub const fn uart5rsts(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "UART5 reset."]
        #[inline(always)]
        pub fn set_uart5rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "I2C1 reset."]
        #[inline(always)]
        pub const fn i2c1rsts(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "I2C1 reset."]
        #[inline(always)]
        pub fn set_i2c1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "I2C2 reset."]
        #[inline(always)]
        pub const fn i2c2rsts(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "I2C2 reset."]
        #[inline(always)]
        pub fn set_i2c2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "I2C3 reset."]
        #[inline(always)]
        pub const fn i2c3rsts(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "I2C3 reset."]
        #[inline(always)]
        pub fn set_i2c3rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "I3C1 reset."]
        #[inline(always)]
        pub const fn i3c1rsts(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "I3C1 reset."]
        #[inline(always)]
        pub fn set_i3c1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "I3C2 reset."]
        #[inline(always)]
        pub const fn i3c2rsts(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "I3C2 reset."]
        #[inline(always)]
        pub fn set_i3c2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "UART7 reset."]
        #[inline(always)]
        pub const fn uart7rsts(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "UART7 reset."]
        #[inline(always)]
        pub fn set_uart7rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "UART8 reset."]
        #[inline(always)]
        pub const fn uart8rsts(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "UART8 reset."]
        #[inline(always)]
        pub fn set_uart8rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb1lrstsr {
        #[inline(always)]
        fn default() -> Apb1lrstsr {
            Apb1lrstsr(0)
        }
    }
    impl core::fmt::Debug for Apb1lrstsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb1lrstsr")
                .field("tim2rsts", &self.tim2rsts())
                .field("tim3rsts", &self.tim3rsts())
                .field("tim4rsts", &self.tim4rsts())
                .field("tim5rsts", &self.tim5rsts())
                .field("tim6rsts", &self.tim6rsts())
                .field("tim7rsts", &self.tim7rsts())
                .field("tim12rsts", &self.tim12rsts())
                .field("tim13rsts", &self.tim13rsts())
                .field("tim14rsts", &self.tim14rsts())
                .field("lptim1rsts", &self.lptim1rsts())
                .field("wwdgrsts", &self.wwdgrsts())
                .field("tim10rsts", &self.tim10rsts())
                .field("tim11rsts", &self.tim11rsts())
                .field("spi2rsts", &self.spi2rsts())
                .field("spi3rsts", &self.spi3rsts())
                .field("spdifrx1rsts", &self.spdifrx1rsts())
                .field("usart2rsts", &self.usart2rsts())
                .field("usart3rsts", &self.usart3rsts())
                .field("uart4rsts", &self.uart4rsts())
                .field("uart5rsts", &self.uart5rsts())
                .field("i2c1rsts", &self.i2c1rsts())
                .field("i2c2rsts", &self.i2c2rsts())
                .field("i2c3rsts", &self.i2c3rsts())
                .field("i3c1rsts", &self.i3c1rsts())
                .field("i3c2rsts", &self.i3c2rsts())
                .field("uart7rsts", &self.uart7rsts())
                .field("uart8rsts", &self.uart8rsts())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb1lrstsr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb1lrstsr {{ tim2rsts: {=bool:?}, tim3rsts: {=bool:?}, tim4rsts: {=bool:?}, tim5rsts: {=bool:?}, tim6rsts: {=bool:?}, tim7rsts: {=bool:?}, tim12rsts: {=bool:?}, tim13rsts: {=bool:?}, tim14rsts: {=bool:?}, lptim1rsts: {=bool:?}, wwdgrsts: {=bool:?}, tim10rsts: {=bool:?}, tim11rsts: {=bool:?}, spi2rsts: {=bool:?}, spi3rsts: {=bool:?}, spdifrx1rsts: {=bool:?}, usart2rsts: {=bool:?}, usart3rsts: {=bool:?}, uart4rsts: {=bool:?}, uart5rsts: {=bool:?}, i2c1rsts: {=bool:?}, i2c2rsts: {=bool:?}, i2c3rsts: {=bool:?}, i3c1rsts: {=bool:?}, i3c2rsts: {=bool:?}, uart7rsts: {=bool:?}, uart8rsts: {=bool:?} }}" , self . tim2rsts () , self . tim3rsts () , self . tim4rsts () , self . tim5rsts () , self . tim6rsts () , self . tim7rsts () , self . tim12rsts () , self . tim13rsts () , self . tim14rsts () , self . lptim1rsts () , self . wwdgrsts () , self . tim10rsts () , self . tim11rsts () , self . spi2rsts () , self . spi3rsts () , self . spdifrx1rsts () , self . usart2rsts () , self . usart3rsts () , self . uart4rsts () , self . uart5rsts () , self . i2c1rsts () , self . i2c2rsts () , self . i2c3rsts () , self . i3c1rsts () , self . i3c2rsts () , self . uart7rsts () , self . uart8rsts ())
        }
    }
    #[doc = "RCC APB2 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb2encr(pub u32);
    impl Apb2encr {
        #[doc = "TIM1 enable."]
        #[inline(always)]
        pub const fn tim1enc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM1 enable."]
        #[inline(always)]
        pub fn set_tim1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM8 enable."]
        #[inline(always)]
        pub const fn tim8enc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM8 enable."]
        #[inline(always)]
        pub fn set_tim8enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "USART1 enable."]
        #[inline(always)]
        pub const fn usart1enc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "USART1 enable."]
        #[inline(always)]
        pub fn set_usart1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "USART6 enable."]
        #[inline(always)]
        pub const fn usart6enc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "USART6 enable."]
        #[inline(always)]
        pub fn set_usart6enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "UART9 enable."]
        #[inline(always)]
        pub const fn uart9enc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "UART9 enable."]
        #[inline(always)]
        pub fn set_uart9enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "USART10 enable."]
        #[inline(always)]
        pub const fn usart10enc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "USART10 enable."]
        #[inline(always)]
        pub fn set_usart10enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SPI1 enable."]
        #[inline(always)]
        pub const fn spi1enc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "SPI1 enable."]
        #[inline(always)]
        pub fn set_spi1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "SPI4 enable."]
        #[inline(always)]
        pub const fn spi4enc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "SPI4 enable."]
        #[inline(always)]
        pub fn set_spi4enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "TIM18 enable."]
        #[inline(always)]
        pub const fn tim18enc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "TIM18 enable."]
        #[inline(always)]
        pub fn set_tim18enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "TIM15 enable."]
        #[inline(always)]
        pub const fn tim15enc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "TIM15 enable."]
        #[inline(always)]
        pub fn set_tim15enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "TIM16 enable."]
        #[inline(always)]
        pub const fn tim16enc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "TIM16 enable."]
        #[inline(always)]
        pub fn set_tim16enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "TIM17 enable."]
        #[inline(always)]
        pub const fn tim17enc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "TIM17 enable."]
        #[inline(always)]
        pub fn set_tim17enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "TIM9 enable."]
        #[inline(always)]
        pub const fn tim9enc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "TIM9 enable."]
        #[inline(always)]
        pub fn set_tim9enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "SPI5 enable."]
        #[inline(always)]
        pub const fn spi5enc(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "SPI5 enable."]
        #[inline(always)]
        pub fn set_spi5enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "SAI1 enable."]
        #[inline(always)]
        pub const fn sai1enc(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "SAI1 enable."]
        #[inline(always)]
        pub fn set_sai1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "SAI2 enable."]
        #[inline(always)]
        pub const fn sai2enc(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "SAI2 enable."]
        #[inline(always)]
        pub fn set_sai2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
    }
    impl Default for Apb2encr {
        #[inline(always)]
        fn default() -> Apb2encr {
            Apb2encr(0)
        }
    }
    impl core::fmt::Debug for Apb2encr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb2encr")
                .field("tim1enc", &self.tim1enc())
                .field("tim8enc", &self.tim8enc())
                .field("usart1enc", &self.usart1enc())
                .field("usart6enc", &self.usart6enc())
                .field("uart9enc", &self.uart9enc())
                .field("usart10enc", &self.usart10enc())
                .field("spi1enc", &self.spi1enc())
                .field("spi4enc", &self.spi4enc())
                .field("tim18enc", &self.tim18enc())
                .field("tim15enc", &self.tim15enc())
                .field("tim16enc", &self.tim16enc())
                .field("tim17enc", &self.tim17enc())
                .field("tim9enc", &self.tim9enc())
                .field("spi5enc", &self.spi5enc())
                .field("sai1enc", &self.sai1enc())
                .field("sai2enc", &self.sai2enc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb2encr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb2encr {{ tim1enc: {=bool:?}, tim8enc: {=bool:?}, usart1enc: {=bool:?}, usart6enc: {=bool:?}, uart9enc: {=bool:?}, usart10enc: {=bool:?}, spi1enc: {=bool:?}, spi4enc: {=bool:?}, tim18enc: {=bool:?}, tim15enc: {=bool:?}, tim16enc: {=bool:?}, tim17enc: {=bool:?}, tim9enc: {=bool:?}, spi5enc: {=bool:?}, sai1enc: {=bool:?}, sai2enc: {=bool:?} }}" , self . tim1enc () , self . tim8enc () , self . usart1enc () , self . usart6enc () , self . uart9enc () , self . usart10enc () , self . spi1enc () , self . spi4enc () , self . tim18enc () , self . tim15enc () , self . tim16enc () , self . tim17enc () , self . tim9enc () , self . spi5enc () , self . sai1enc () , self . sai2enc ())
        }
    }
    #[doc = "RCC APB2 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb2enr(pub u32);
    impl Apb2enr {
        #[doc = "TIM1 enable."]
        #[inline(always)]
        pub const fn tim1en(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM1 enable."]
        #[inline(always)]
        pub fn set_tim1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM8 enable."]
        #[inline(always)]
        pub const fn tim8en(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM8 enable."]
        #[inline(always)]
        pub fn set_tim8en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "USART1 enable."]
        #[inline(always)]
        pub const fn usart1en(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "USART1 enable."]
        #[inline(always)]
        pub fn set_usart1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "USART6 enable."]
        #[inline(always)]
        pub const fn usart6en(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "USART6 enable."]
        #[inline(always)]
        pub fn set_usart6en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "UART9 enable."]
        #[inline(always)]
        pub const fn uart9en(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "UART9 enable."]
        #[inline(always)]
        pub fn set_uart9en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "USART10 enable."]
        #[inline(always)]
        pub const fn usart10en(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "USART10 enable."]
        #[inline(always)]
        pub fn set_usart10en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SPI1 enable."]
        #[inline(always)]
        pub const fn spi1en(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "SPI1 enable."]
        #[inline(always)]
        pub fn set_spi1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "SPI4 enable."]
        #[inline(always)]
        pub const fn spi4en(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "SPI4 enable."]
        #[inline(always)]
        pub fn set_spi4en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "TIM18 enable."]
        #[inline(always)]
        pub const fn tim18en(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "TIM18 enable."]
        #[inline(always)]
        pub fn set_tim18en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "TIM15 enable."]
        #[inline(always)]
        pub const fn tim15en(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "TIM15 enable."]
        #[inline(always)]
        pub fn set_tim15en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "TIM16 enable."]
        #[inline(always)]
        pub const fn tim16en(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "TIM16 enable."]
        #[inline(always)]
        pub fn set_tim16en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "TIM17 enable."]
        #[inline(always)]
        pub const fn tim17en(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "TIM17 enable."]
        #[inline(always)]
        pub fn set_tim17en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "TIM9 enable."]
        #[inline(always)]
        pub const fn tim9en(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "TIM9 enable."]
        #[inline(always)]
        pub fn set_tim9en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "SPI5 enable."]
        #[inline(always)]
        pub const fn spi5en(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "SPI5 enable."]
        #[inline(always)]
        pub fn set_spi5en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "SAI1 enable."]
        #[inline(always)]
        pub const fn sai1en(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "SAI1 enable."]
        #[inline(always)]
        pub fn set_sai1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "SAI2 enable."]
        #[inline(always)]
        pub const fn sai2en(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "SAI2 enable."]
        #[inline(always)]
        pub fn set_sai2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
    }
    impl Default for Apb2enr {
        #[inline(always)]
        fn default() -> Apb2enr {
            Apb2enr(0)
        }
    }
    impl core::fmt::Debug for Apb2enr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb2enr")
                .field("tim1en", &self.tim1en())
                .field("tim8en", &self.tim8en())
                .field("usart1en", &self.usart1en())
                .field("usart6en", &self.usart6en())
                .field("uart9en", &self.uart9en())
                .field("usart10en", &self.usart10en())
                .field("spi1en", &self.spi1en())
                .field("spi4en", &self.spi4en())
                .field("tim18en", &self.tim18en())
                .field("tim15en", &self.tim15en())
                .field("tim16en", &self.tim16en())
                .field("tim17en", &self.tim17en())
                .field("tim9en", &self.tim9en())
                .field("spi5en", &self.spi5en())
                .field("sai1en", &self.sai1en())
                .field("sai2en", &self.sai2en())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb2enr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb2enr {{ tim1en: {=bool:?}, tim8en: {=bool:?}, usart1en: {=bool:?}, usart6en: {=bool:?}, uart9en: {=bool:?}, usart10en: {=bool:?}, spi1en: {=bool:?}, spi4en: {=bool:?}, tim18en: {=bool:?}, tim15en: {=bool:?}, tim16en: {=bool:?}, tim17en: {=bool:?}, tim9en: {=bool:?}, spi5en: {=bool:?}, sai1en: {=bool:?}, sai2en: {=bool:?} }}" , self . tim1en () , self . tim8en () , self . usart1en () , self . usart6en () , self . uart9en () , self . usart10en () , self . spi1en () , self . spi4en () , self . tim18en () , self . tim15en () , self . tim16en () , self . tim17en () , self . tim9en () , self . spi5en () , self . sai1en () , self . sai2en ())
        }
    }
    #[doc = "RCC APB2 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb2ensr(pub u32);
    impl Apb2ensr {
        #[doc = "TIM1 enable."]
        #[inline(always)]
        pub const fn tim1ens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM1 enable."]
        #[inline(always)]
        pub fn set_tim1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM8 enable."]
        #[inline(always)]
        pub const fn tim8ens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM8 enable."]
        #[inline(always)]
        pub fn set_tim8ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "USART1 enable."]
        #[inline(always)]
        pub const fn usart1ens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "USART1 enable."]
        #[inline(always)]
        pub fn set_usart1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "USART6 enable."]
        #[inline(always)]
        pub const fn usart6ens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "USART6 enable."]
        #[inline(always)]
        pub fn set_usart6ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "UART9 enable."]
        #[inline(always)]
        pub const fn uart9ens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "UART9 enable."]
        #[inline(always)]
        pub fn set_uart9ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "USART10 enable."]
        #[inline(always)]
        pub const fn usart10ens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "USART10 enable."]
        #[inline(always)]
        pub fn set_usart10ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SPI1 enable."]
        #[inline(always)]
        pub const fn spi1ens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "SPI1 enable."]
        #[inline(always)]
        pub fn set_spi1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "SPI4 enable."]
        #[inline(always)]
        pub const fn spi4ens(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "SPI4 enable."]
        #[inline(always)]
        pub fn set_spi4ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "TIM18 enable."]
        #[inline(always)]
        pub const fn tim18ens(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "TIM18 enable."]
        #[inline(always)]
        pub fn set_tim18ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "TIM15 enable."]
        #[inline(always)]
        pub const fn tim15ens(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "TIM15 enable."]
        #[inline(always)]
        pub fn set_tim15ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "TIM16 enable."]
        #[inline(always)]
        pub const fn tim16ens(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "TIM16 enable."]
        #[inline(always)]
        pub fn set_tim16ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "TIM17 enable."]
        #[inline(always)]
        pub const fn tim17ens(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "TIM17 enable."]
        #[inline(always)]
        pub fn set_tim17ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "TIM9 enable."]
        #[inline(always)]
        pub const fn tim9ens(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "TIM9 enable."]
        #[inline(always)]
        pub fn set_tim9ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "SPI5 enable."]
        #[inline(always)]
        pub const fn spi5ens(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "SPI5 enable."]
        #[inline(always)]
        pub fn set_spi5ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "SAI1 enable."]
        #[inline(always)]
        pub const fn sai1ens(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "SAI1 enable."]
        #[inline(always)]
        pub fn set_sai1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "SAI2 enable."]
        #[inline(always)]
        pub const fn sai2ens(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "SAI2 enable."]
        #[inline(always)]
        pub fn set_sai2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
    }
    impl Default for Apb2ensr {
        #[inline(always)]
        fn default() -> Apb2ensr {
            Apb2ensr(0)
        }
    }
    impl core::fmt::Debug for Apb2ensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb2ensr")
                .field("tim1ens", &self.tim1ens())
                .field("tim8ens", &self.tim8ens())
                .field("usart1ens", &self.usart1ens())
                .field("usart6ens", &self.usart6ens())
                .field("uart9ens", &self.uart9ens())
                .field("usart10ens", &self.usart10ens())
                .field("spi1ens", &self.spi1ens())
                .field("spi4ens", &self.spi4ens())
                .field("tim18ens", &self.tim18ens())
                .field("tim15ens", &self.tim15ens())
                .field("tim16ens", &self.tim16ens())
                .field("tim17ens", &self.tim17ens())
                .field("tim9ens", &self.tim9ens())
                .field("spi5ens", &self.spi5ens())
                .field("sai1ens", &self.sai1ens())
                .field("sai2ens", &self.sai2ens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb2ensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb2ensr {{ tim1ens: {=bool:?}, tim8ens: {=bool:?}, usart1ens: {=bool:?}, usart6ens: {=bool:?}, uart9ens: {=bool:?}, usart10ens: {=bool:?}, spi1ens: {=bool:?}, spi4ens: {=bool:?}, tim18ens: {=bool:?}, tim15ens: {=bool:?}, tim16ens: {=bool:?}, tim17ens: {=bool:?}, tim9ens: {=bool:?}, spi5ens: {=bool:?}, sai1ens: {=bool:?}, sai2ens: {=bool:?} }}" , self . tim1ens () , self . tim8ens () , self . usart1ens () , self . usart6ens () , self . uart9ens () , self . usart10ens () , self . spi1ens () , self . spi4ens () , self . tim18ens () , self . tim15ens () , self . tim16ens () , self . tim17ens () , self . tim9ens () , self . spi5ens () , self . sai1ens () , self . sai2ens ())
        }
    }
    #[doc = "RCC APB2 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb2lpencr(pub u32);
    impl Apb2lpencr {
        #[doc = "TIM1 sleep enable."]
        #[inline(always)]
        pub const fn tim1lpenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM1 sleep enable."]
        #[inline(always)]
        pub fn set_tim1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM8 sleep enable."]
        #[inline(always)]
        pub const fn tim8lpenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM8 sleep enable."]
        #[inline(always)]
        pub fn set_tim8lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "USART1 sleep enable."]
        #[inline(always)]
        pub const fn usart1lpenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "USART1 sleep enable."]
        #[inline(always)]
        pub fn set_usart1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "USART6 sleep enable."]
        #[inline(always)]
        pub const fn usart6lpenc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "USART6 sleep enable."]
        #[inline(always)]
        pub fn set_usart6lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "UART9 sleep enable."]
        #[inline(always)]
        pub const fn uart9lpenc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "UART9 sleep enable."]
        #[inline(always)]
        pub fn set_uart9lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "USART10 sleep enable."]
        #[inline(always)]
        pub const fn usart10lpenc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "USART10 sleep enable."]
        #[inline(always)]
        pub fn set_usart10lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SPI1 sleep enable."]
        #[inline(always)]
        pub const fn spi1lpenc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "SPI1 sleep enable."]
        #[inline(always)]
        pub fn set_spi1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "SPI4 sleep enable."]
        #[inline(always)]
        pub const fn spi4lpenc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "SPI4 sleep enable."]
        #[inline(always)]
        pub fn set_spi4lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "TIM18 sleep enable."]
        #[inline(always)]
        pub const fn tim18lpenc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "TIM18 sleep enable."]
        #[inline(always)]
        pub fn set_tim18lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "TIM15 sleep enable."]
        #[inline(always)]
        pub const fn tim15lpenc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "TIM15 sleep enable."]
        #[inline(always)]
        pub fn set_tim15lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "TIM16 sleep enable."]
        #[inline(always)]
        pub const fn tim16lpenc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "TIM16 sleep enable."]
        #[inline(always)]
        pub fn set_tim16lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "TIM17 sleep enable."]
        #[inline(always)]
        pub const fn tim17lpenc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "TIM17 sleep enable."]
        #[inline(always)]
        pub fn set_tim17lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "TIM9 sleep enable."]
        #[inline(always)]
        pub const fn tim9lpenc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "TIM9 sleep enable."]
        #[inline(always)]
        pub fn set_tim9lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "SPI5 sleep enable."]
        #[inline(always)]
        pub const fn spi5lpenc(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "SPI5 sleep enable."]
        #[inline(always)]
        pub fn set_spi5lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "SAI1 sleep enable."]
        #[inline(always)]
        pub const fn sai1lpenc(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "SAI1 sleep enable."]
        #[inline(always)]
        pub fn set_sai1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "SAI2 sleep enable."]
        #[inline(always)]
        pub const fn sai2lpenc(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "SAI2 sleep enable."]
        #[inline(always)]
        pub fn set_sai2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
    }
    impl Default for Apb2lpencr {
        #[inline(always)]
        fn default() -> Apb2lpencr {
            Apb2lpencr(0)
        }
    }
    impl core::fmt::Debug for Apb2lpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb2lpencr")
                .field("tim1lpenc", &self.tim1lpenc())
                .field("tim8lpenc", &self.tim8lpenc())
                .field("usart1lpenc", &self.usart1lpenc())
                .field("usart6lpenc", &self.usart6lpenc())
                .field("uart9lpenc", &self.uart9lpenc())
                .field("usart10lpenc", &self.usart10lpenc())
                .field("spi1lpenc", &self.spi1lpenc())
                .field("spi4lpenc", &self.spi4lpenc())
                .field("tim18lpenc", &self.tim18lpenc())
                .field("tim15lpenc", &self.tim15lpenc())
                .field("tim16lpenc", &self.tim16lpenc())
                .field("tim17lpenc", &self.tim17lpenc())
                .field("tim9lpenc", &self.tim9lpenc())
                .field("spi5lpenc", &self.spi5lpenc())
                .field("sai1lpenc", &self.sai1lpenc())
                .field("sai2lpenc", &self.sai2lpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb2lpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb2lpencr {{ tim1lpenc: {=bool:?}, tim8lpenc: {=bool:?}, usart1lpenc: {=bool:?}, usart6lpenc: {=bool:?}, uart9lpenc: {=bool:?}, usart10lpenc: {=bool:?}, spi1lpenc: {=bool:?}, spi4lpenc: {=bool:?}, tim18lpenc: {=bool:?}, tim15lpenc: {=bool:?}, tim16lpenc: {=bool:?}, tim17lpenc: {=bool:?}, tim9lpenc: {=bool:?}, spi5lpenc: {=bool:?}, sai1lpenc: {=bool:?}, sai2lpenc: {=bool:?} }}" , self . tim1lpenc () , self . tim8lpenc () , self . usart1lpenc () , self . usart6lpenc () , self . uart9lpenc () , self . usart10lpenc () , self . spi1lpenc () , self . spi4lpenc () , self . tim18lpenc () , self . tim15lpenc () , self . tim16lpenc () , self . tim17lpenc () , self . tim9lpenc () , self . spi5lpenc () , self . sai1lpenc () , self . sai2lpenc ())
        }
    }
    #[doc = "RCC APB2 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb2lpenr(pub u32);
    impl Apb2lpenr {
        #[doc = "TIM1 sleep enable."]
        #[inline(always)]
        pub const fn tim1lpen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM1 sleep enable."]
        #[inline(always)]
        pub fn set_tim1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM8 sleep enable."]
        #[inline(always)]
        pub const fn tim8lpen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM8 sleep enable."]
        #[inline(always)]
        pub fn set_tim8lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "USART1 sleep enable."]
        #[inline(always)]
        pub const fn usart1lpen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "USART1 sleep enable."]
        #[inline(always)]
        pub fn set_usart1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "USART6 sleep enable."]
        #[inline(always)]
        pub const fn usart6lpen(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "USART6 sleep enable."]
        #[inline(always)]
        pub fn set_usart6lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "UART9 sleep enable."]
        #[inline(always)]
        pub const fn uart9lpen(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "UART9 sleep enable."]
        #[inline(always)]
        pub fn set_uart9lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "USART10 sleep enable."]
        #[inline(always)]
        pub const fn usart10lpen(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "USART10 sleep enable."]
        #[inline(always)]
        pub fn set_usart10lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SPI1 sleep enable."]
        #[inline(always)]
        pub const fn spi1lpen(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "SPI1 sleep enable."]
        #[inline(always)]
        pub fn set_spi1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "SPI4 sleep enable."]
        #[inline(always)]
        pub const fn spi4lpen(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "SPI4 sleep enable."]
        #[inline(always)]
        pub fn set_spi4lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "TIM18 sleep enable."]
        #[inline(always)]
        pub const fn tim18lpen(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "TIM18 sleep enable."]
        #[inline(always)]
        pub fn set_tim18lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "TIM15 sleep enable."]
        #[inline(always)]
        pub const fn tim15lpen(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "TIM15 sleep enable."]
        #[inline(always)]
        pub fn set_tim15lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "TIM16 sleep enable."]
        #[inline(always)]
        pub const fn tim16lpen(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "TIM16 sleep enable."]
        #[inline(always)]
        pub fn set_tim16lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "TIM17 sleep enable."]
        #[inline(always)]
        pub const fn tim17lpen(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "TIM17 sleep enable."]
        #[inline(always)]
        pub fn set_tim17lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "TIM9 sleep enable."]
        #[inline(always)]
        pub const fn tim9lpen(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "TIM9 sleep enable."]
        #[inline(always)]
        pub fn set_tim9lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "SPI5 sleep enable."]
        #[inline(always)]
        pub const fn spi5lpen(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "SPI5 sleep enable."]
        #[inline(always)]
        pub fn set_spi5lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "SAI1 sleep enable."]
        #[inline(always)]
        pub const fn sai1lpen(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "SAI1 sleep enable."]
        #[inline(always)]
        pub fn set_sai1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "SAI2 sleep enable."]
        #[inline(always)]
        pub const fn sai2lpen(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "SAI2 sleep enable."]
        #[inline(always)]
        pub fn set_sai2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
    }
    impl Default for Apb2lpenr {
        #[inline(always)]
        fn default() -> Apb2lpenr {
            Apb2lpenr(0)
        }
    }
    impl core::fmt::Debug for Apb2lpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb2lpenr")
                .field("tim1lpen", &self.tim1lpen())
                .field("tim8lpen", &self.tim8lpen())
                .field("usart1lpen", &self.usart1lpen())
                .field("usart6lpen", &self.usart6lpen())
                .field("uart9lpen", &self.uart9lpen())
                .field("usart10lpen", &self.usart10lpen())
                .field("spi1lpen", &self.spi1lpen())
                .field("spi4lpen", &self.spi4lpen())
                .field("tim18lpen", &self.tim18lpen())
                .field("tim15lpen", &self.tim15lpen())
                .field("tim16lpen", &self.tim16lpen())
                .field("tim17lpen", &self.tim17lpen())
                .field("tim9lpen", &self.tim9lpen())
                .field("spi5lpen", &self.spi5lpen())
                .field("sai1lpen", &self.sai1lpen())
                .field("sai2lpen", &self.sai2lpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb2lpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb2lpenr {{ tim1lpen: {=bool:?}, tim8lpen: {=bool:?}, usart1lpen: {=bool:?}, usart6lpen: {=bool:?}, uart9lpen: {=bool:?}, usart10lpen: {=bool:?}, spi1lpen: {=bool:?}, spi4lpen: {=bool:?}, tim18lpen: {=bool:?}, tim15lpen: {=bool:?}, tim16lpen: {=bool:?}, tim17lpen: {=bool:?}, tim9lpen: {=bool:?}, spi5lpen: {=bool:?}, sai1lpen: {=bool:?}, sai2lpen: {=bool:?} }}" , self . tim1lpen () , self . tim8lpen () , self . usart1lpen () , self . usart6lpen () , self . uart9lpen () , self . usart10lpen () , self . spi1lpen () , self . spi4lpen () , self . tim18lpen () , self . tim15lpen () , self . tim16lpen () , self . tim17lpen () , self . tim9lpen () , self . spi5lpen () , self . sai1lpen () , self . sai2lpen ())
        }
    }
    #[doc = "RCC APB2 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb2lpensr(pub u32);
    impl Apb2lpensr {
        #[doc = "TIM1 sleep enable."]
        #[inline(always)]
        pub const fn tim1lpens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM1 sleep enable."]
        #[inline(always)]
        pub fn set_tim1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM8 sleep enable."]
        #[inline(always)]
        pub const fn tim8lpens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM8 sleep enable."]
        #[inline(always)]
        pub fn set_tim8lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "USART1 sleep enable."]
        #[inline(always)]
        pub const fn usart1lpens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "USART1 sleep enable."]
        #[inline(always)]
        pub fn set_usart1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "USART6 sleep enable."]
        #[inline(always)]
        pub const fn usart6lpens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "USART6 sleep enable."]
        #[inline(always)]
        pub fn set_usart6lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "UART9 sleep enable."]
        #[inline(always)]
        pub const fn uart9lpens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "UART9 sleep enable."]
        #[inline(always)]
        pub fn set_uart9lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "USART10 sleep enable."]
        #[inline(always)]
        pub const fn usart10lpens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "USART10 sleep enable."]
        #[inline(always)]
        pub fn set_usart10lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SPI1 sleep enable."]
        #[inline(always)]
        pub const fn spi1lpens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "SPI1 sleep enable."]
        #[inline(always)]
        pub fn set_spi1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "SPI4 sleep enable."]
        #[inline(always)]
        pub const fn spi4lpens(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "SPI4 sleep enable."]
        #[inline(always)]
        pub fn set_spi4lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "TIM18 sleep enable."]
        #[inline(always)]
        pub const fn tim18lpens(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "TIM18 sleep enable."]
        #[inline(always)]
        pub fn set_tim18lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "TIM15 sleep enable."]
        #[inline(always)]
        pub const fn tim15lpens(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "TIM15 sleep enable."]
        #[inline(always)]
        pub fn set_tim15lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "TIM16 sleep enable."]
        #[inline(always)]
        pub const fn tim16lpens(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "TIM16 sleep enable."]
        #[inline(always)]
        pub fn set_tim16lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "TIM17 sleep enable."]
        #[inline(always)]
        pub const fn tim17lpens(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "TIM17 sleep enable."]
        #[inline(always)]
        pub fn set_tim17lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "TIM9 sleep enable."]
        #[inline(always)]
        pub const fn tim9lpens(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "TIM9 sleep enable."]
        #[inline(always)]
        pub fn set_tim9lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "SPI5 sleep enable."]
        #[inline(always)]
        pub const fn spi5lpens(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "SPI5 sleep enable."]
        #[inline(always)]
        pub fn set_spi5lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "SAI1 sleep enable."]
        #[inline(always)]
        pub const fn sai1lpens(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "SAI1 sleep enable."]
        #[inline(always)]
        pub fn set_sai1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "SAI2 sleep enable."]
        #[inline(always)]
        pub const fn sai2lpens(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "SAI2 sleep enable."]
        #[inline(always)]
        pub fn set_sai2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
    }
    impl Default for Apb2lpensr {
        #[inline(always)]
        fn default() -> Apb2lpensr {
            Apb2lpensr(0)
        }
    }
    impl core::fmt::Debug for Apb2lpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb2lpensr")
                .field("tim1lpens", &self.tim1lpens())
                .field("tim8lpens", &self.tim8lpens())
                .field("usart1lpens", &self.usart1lpens())
                .field("usart6lpens", &self.usart6lpens())
                .field("uart9lpens", &self.uart9lpens())
                .field("usart10lpens", &self.usart10lpens())
                .field("spi1lpens", &self.spi1lpens())
                .field("spi4lpens", &self.spi4lpens())
                .field("tim18lpens", &self.tim18lpens())
                .field("tim15lpens", &self.tim15lpens())
                .field("tim16lpens", &self.tim16lpens())
                .field("tim17lpens", &self.tim17lpens())
                .field("tim9lpens", &self.tim9lpens())
                .field("spi5lpens", &self.spi5lpens())
                .field("sai1lpens", &self.sai1lpens())
                .field("sai2lpens", &self.sai2lpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb2lpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb2lpensr {{ tim1lpens: {=bool:?}, tim8lpens: {=bool:?}, usart1lpens: {=bool:?}, usart6lpens: {=bool:?}, uart9lpens: {=bool:?}, usart10lpens: {=bool:?}, spi1lpens: {=bool:?}, spi4lpens: {=bool:?}, tim18lpens: {=bool:?}, tim15lpens: {=bool:?}, tim16lpens: {=bool:?}, tim17lpens: {=bool:?}, tim9lpens: {=bool:?}, spi5lpens: {=bool:?}, sai1lpens: {=bool:?}, sai2lpens: {=bool:?} }}" , self . tim1lpens () , self . tim8lpens () , self . usart1lpens () , self . usart6lpens () , self . uart9lpens () , self . usart10lpens () , self . spi1lpens () , self . spi4lpens () , self . tim18lpens () , self . tim15lpens () , self . tim16lpens () , self . tim17lpens () , self . tim9lpens () , self . spi5lpens () , self . sai1lpens () , self . sai2lpens ())
        }
    }
    #[doc = "RCC APB2 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb2rstcr(pub u32);
    impl Apb2rstcr {
        #[doc = "TIM1 reset."]
        #[inline(always)]
        pub const fn tim1rstc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM1 reset."]
        #[inline(always)]
        pub fn set_tim1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM8 reset."]
        #[inline(always)]
        pub const fn tim8rstc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM8 reset."]
        #[inline(always)]
        pub fn set_tim8rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "USART1 reset."]
        #[inline(always)]
        pub const fn usart1rstc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "USART1 reset."]
        #[inline(always)]
        pub fn set_usart1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "USART6 reset."]
        #[inline(always)]
        pub const fn usart6rstc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "USART6 reset."]
        #[inline(always)]
        pub fn set_usart6rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "UART9 reset."]
        #[inline(always)]
        pub const fn uart9rstc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "UART9 reset."]
        #[inline(always)]
        pub fn set_uart9rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "USART10 reset."]
        #[inline(always)]
        pub const fn usart10rstc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "USART10 reset."]
        #[inline(always)]
        pub fn set_usart10rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SPI1 reset."]
        #[inline(always)]
        pub const fn spi1rstc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "SPI1 reset."]
        #[inline(always)]
        pub fn set_spi1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "SPI4 reset."]
        #[inline(always)]
        pub const fn spi4rstc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "SPI4 reset."]
        #[inline(always)]
        pub fn set_spi4rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "TIM18 reset."]
        #[inline(always)]
        pub const fn tim18rstc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "TIM18 reset."]
        #[inline(always)]
        pub fn set_tim18rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "TIM15 reset."]
        #[inline(always)]
        pub const fn tim15rstc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "TIM15 reset."]
        #[inline(always)]
        pub fn set_tim15rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "TIM16 reset."]
        #[inline(always)]
        pub const fn tim16rstc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "TIM16 reset."]
        #[inline(always)]
        pub fn set_tim16rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "TIM17 reset."]
        #[inline(always)]
        pub const fn tim17rstc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "TIM17 reset."]
        #[inline(always)]
        pub fn set_tim17rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "TIM9 reset."]
        #[inline(always)]
        pub const fn tim9rstc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "TIM9 reset."]
        #[inline(always)]
        pub fn set_tim9rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "SPI5 reset."]
        #[inline(always)]
        pub const fn spi5rstc(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "SPI5 reset."]
        #[inline(always)]
        pub fn set_spi5rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "SAI1 reset."]
        #[inline(always)]
        pub const fn sai1rstc(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "SAI1 reset."]
        #[inline(always)]
        pub fn set_sai1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "SAI2 reset."]
        #[inline(always)]
        pub const fn sai2rstc(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "SAI2 reset."]
        #[inline(always)]
        pub fn set_sai2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
    }
    impl Default for Apb2rstcr {
        #[inline(always)]
        fn default() -> Apb2rstcr {
            Apb2rstcr(0)
        }
    }
    impl core::fmt::Debug for Apb2rstcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb2rstcr")
                .field("tim1rstc", &self.tim1rstc())
                .field("tim8rstc", &self.tim8rstc())
                .field("usart1rstc", &self.usart1rstc())
                .field("usart6rstc", &self.usart6rstc())
                .field("uart9rstc", &self.uart9rstc())
                .field("usart10rstc", &self.usart10rstc())
                .field("spi1rstc", &self.spi1rstc())
                .field("spi4rstc", &self.spi4rstc())
                .field("tim18rstc", &self.tim18rstc())
                .field("tim15rstc", &self.tim15rstc())
                .field("tim16rstc", &self.tim16rstc())
                .field("tim17rstc", &self.tim17rstc())
                .field("tim9rstc", &self.tim9rstc())
                .field("spi5rstc", &self.spi5rstc())
                .field("sai1rstc", &self.sai1rstc())
                .field("sai2rstc", &self.sai2rstc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb2rstcr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb2rstcr {{ tim1rstc: {=bool:?}, tim8rstc: {=bool:?}, usart1rstc: {=bool:?}, usart6rstc: {=bool:?}, uart9rstc: {=bool:?}, usart10rstc: {=bool:?}, spi1rstc: {=bool:?}, spi4rstc: {=bool:?}, tim18rstc: {=bool:?}, tim15rstc: {=bool:?}, tim16rstc: {=bool:?}, tim17rstc: {=bool:?}, tim9rstc: {=bool:?}, spi5rstc: {=bool:?}, sai1rstc: {=bool:?}, sai2rstc: {=bool:?} }}" , self . tim1rstc () , self . tim8rstc () , self . usart1rstc () , self . usart6rstc () , self . uart9rstc () , self . usart10rstc () , self . spi1rstc () , self . spi4rstc () , self . tim18rstc () , self . tim15rstc () , self . tim16rstc () , self . tim17rstc () , self . tim9rstc () , self . spi5rstc () , self . sai1rstc () , self . sai2rstc ())
        }
    }
    #[doc = "RCC APB2 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb2rstr(pub u32);
    impl Apb2rstr {
        #[doc = "TIM1 reset."]
        #[inline(always)]
        pub const fn tim1rst(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM1 reset."]
        #[inline(always)]
        pub fn set_tim1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM8 reset."]
        #[inline(always)]
        pub const fn tim8rst(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM8 reset."]
        #[inline(always)]
        pub fn set_tim8rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "USART1 reset."]
        #[inline(always)]
        pub const fn usart1rst(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "USART1 reset."]
        #[inline(always)]
        pub fn set_usart1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "USART6 reset."]
        #[inline(always)]
        pub const fn usart6rst(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "USART6 reset."]
        #[inline(always)]
        pub fn set_usart6rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "UART9 reset."]
        #[inline(always)]
        pub const fn uart9rst(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "UART9 reset."]
        #[inline(always)]
        pub fn set_uart9rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "USART10 reset."]
        #[inline(always)]
        pub const fn usart10rst(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "USART10 reset."]
        #[inline(always)]
        pub fn set_usart10rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SPI1 reset."]
        #[inline(always)]
        pub const fn spi1rst(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "SPI1 reset."]
        #[inline(always)]
        pub fn set_spi1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "SPI4 reset."]
        #[inline(always)]
        pub const fn spi4rst(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "SPI4 reset."]
        #[inline(always)]
        pub fn set_spi4rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "TIM18 reset."]
        #[inline(always)]
        pub const fn tim18rst(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "TIM18 reset."]
        #[inline(always)]
        pub fn set_tim18rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "TIM15 reset."]
        #[inline(always)]
        pub const fn tim15rst(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "TIM15 reset."]
        #[inline(always)]
        pub fn set_tim15rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "TIM16 reset."]
        #[inline(always)]
        pub const fn tim16rst(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "TIM16 reset."]
        #[inline(always)]
        pub fn set_tim16rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "TIM17 reset."]
        #[inline(always)]
        pub const fn tim17rst(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "TIM17 reset."]
        #[inline(always)]
        pub fn set_tim17rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "TIM9 reset."]
        #[inline(always)]
        pub const fn tim9rst(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "TIM9 reset."]
        #[inline(always)]
        pub fn set_tim9rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "SPI5 reset."]
        #[inline(always)]
        pub const fn spi5rst(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "SPI5 reset."]
        #[inline(always)]
        pub fn set_spi5rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "SAI1 reset."]
        #[inline(always)]
        pub const fn sai1rst(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "SAI1 reset."]
        #[inline(always)]
        pub fn set_sai1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "SAI2 reset."]
        #[inline(always)]
        pub const fn sai2rst(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "SAI2 reset."]
        #[inline(always)]
        pub fn set_sai2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
    }
    impl Default for Apb2rstr {
        #[inline(always)]
        fn default() -> Apb2rstr {
            Apb2rstr(0)
        }
    }
    impl core::fmt::Debug for Apb2rstr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb2rstr")
                .field("tim1rst", &self.tim1rst())
                .field("tim8rst", &self.tim8rst())
                .field("usart1rst", &self.usart1rst())
                .field("usart6rst", &self.usart6rst())
                .field("uart9rst", &self.uart9rst())
                .field("usart10rst", &self.usart10rst())
                .field("spi1rst", &self.spi1rst())
                .field("spi4rst", &self.spi4rst())
                .field("tim18rst", &self.tim18rst())
                .field("tim15rst", &self.tim15rst())
                .field("tim16rst", &self.tim16rst())
                .field("tim17rst", &self.tim17rst())
                .field("tim9rst", &self.tim9rst())
                .field("spi5rst", &self.spi5rst())
                .field("sai1rst", &self.sai1rst())
                .field("sai2rst", &self.sai2rst())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb2rstr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb2rstr {{ tim1rst: {=bool:?}, tim8rst: {=bool:?}, usart1rst: {=bool:?}, usart6rst: {=bool:?}, uart9rst: {=bool:?}, usart10rst: {=bool:?}, spi1rst: {=bool:?}, spi4rst: {=bool:?}, tim18rst: {=bool:?}, tim15rst: {=bool:?}, tim16rst: {=bool:?}, tim17rst: {=bool:?}, tim9rst: {=bool:?}, spi5rst: {=bool:?}, sai1rst: {=bool:?}, sai2rst: {=bool:?} }}" , self . tim1rst () , self . tim8rst () , self . usart1rst () , self . usart6rst () , self . uart9rst () , self . usart10rst () , self . spi1rst () , self . spi4rst () , self . tim18rst () , self . tim15rst () , self . tim16rst () , self . tim17rst () , self . tim9rst () , self . spi5rst () , self . sai1rst () , self . sai2rst ())
        }
    }
    #[doc = "RCC APB2 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb2rstsr(pub u32);
    impl Apb2rstsr {
        #[doc = "TIM1 reset."]
        #[inline(always)]
        pub const fn tim1rsts(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "TIM1 reset."]
        #[inline(always)]
        pub fn set_tim1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "TIM8 reset."]
        #[inline(always)]
        pub const fn tim8rsts(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "TIM8 reset."]
        #[inline(always)]
        pub fn set_tim8rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "USART1 reset."]
        #[inline(always)]
        pub const fn usart1rsts(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "USART1 reset."]
        #[inline(always)]
        pub fn set_usart1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "USART6 reset."]
        #[inline(always)]
        pub const fn usart6rsts(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "USART6 reset."]
        #[inline(always)]
        pub fn set_usart6rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "UART9 reset."]
        #[inline(always)]
        pub const fn uart9rsts(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "UART9 reset."]
        #[inline(always)]
        pub fn set_uart9rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "USART10 reset."]
        #[inline(always)]
        pub const fn usart10rsts(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "USART10 reset."]
        #[inline(always)]
        pub fn set_usart10rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SPI1 reset."]
        #[inline(always)]
        pub const fn spi1rsts(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "SPI1 reset."]
        #[inline(always)]
        pub fn set_spi1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "SPI4 reset."]
        #[inline(always)]
        pub const fn spi4rsts(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "SPI4 reset."]
        #[inline(always)]
        pub fn set_spi4rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "TIM18 reset."]
        #[inline(always)]
        pub const fn tim18rsts(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "TIM18 reset."]
        #[inline(always)]
        pub fn set_tim18rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "TIM15 reset."]
        #[inline(always)]
        pub const fn tim15rsts(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "TIM15 reset."]
        #[inline(always)]
        pub fn set_tim15rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "TIM16 reset."]
        #[inline(always)]
        pub const fn tim16rsts(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "TIM16 reset."]
        #[inline(always)]
        pub fn set_tim16rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "TIM17 reset."]
        #[inline(always)]
        pub const fn tim17rsts(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "TIM17 reset."]
        #[inline(always)]
        pub fn set_tim17rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "TIM9 reset."]
        #[inline(always)]
        pub const fn tim9rsts(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "TIM9 reset."]
        #[inline(always)]
        pub fn set_tim9rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "SPI5 reset."]
        #[inline(always)]
        pub const fn spi5rsts(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "SPI5 reset."]
        #[inline(always)]
        pub fn set_spi5rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "SAI1 reset."]
        #[inline(always)]
        pub const fn sai1rsts(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "SAI1 reset."]
        #[inline(always)]
        pub fn set_sai1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "SAI2 reset."]
        #[inline(always)]
        pub const fn sai2rsts(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "SAI2 reset."]
        #[inline(always)]
        pub fn set_sai2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
    }
    impl Default for Apb2rstsr {
        #[inline(always)]
        fn default() -> Apb2rstsr {
            Apb2rstsr(0)
        }
    }
    impl core::fmt::Debug for Apb2rstsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb2rstsr")
                .field("tim1rsts", &self.tim1rsts())
                .field("tim8rsts", &self.tim8rsts())
                .field("usart1rsts", &self.usart1rsts())
                .field("usart6rsts", &self.usart6rsts())
                .field("uart9rsts", &self.uart9rsts())
                .field("usart10rsts", &self.usart10rsts())
                .field("spi1rsts", &self.spi1rsts())
                .field("spi4rsts", &self.spi4rsts())
                .field("tim18rsts", &self.tim18rsts())
                .field("tim15rsts", &self.tim15rsts())
                .field("tim16rsts", &self.tim16rsts())
                .field("tim17rsts", &self.tim17rsts())
                .field("tim9rsts", &self.tim9rsts())
                .field("spi5rsts", &self.spi5rsts())
                .field("sai1rsts", &self.sai1rsts())
                .field("sai2rsts", &self.sai2rsts())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb2rstsr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb2rstsr {{ tim1rsts: {=bool:?}, tim8rsts: {=bool:?}, usart1rsts: {=bool:?}, usart6rsts: {=bool:?}, uart9rsts: {=bool:?}, usart10rsts: {=bool:?}, spi1rsts: {=bool:?}, spi4rsts: {=bool:?}, tim18rsts: {=bool:?}, tim15rsts: {=bool:?}, tim16rsts: {=bool:?}, tim17rsts: {=bool:?}, tim9rsts: {=bool:?}, spi5rsts: {=bool:?}, sai1rsts: {=bool:?}, sai2rsts: {=bool:?} }}" , self . tim1rsts () , self . tim8rsts () , self . usart1rsts () , self . usart6rsts () , self . uart9rsts () , self . usart10rsts () , self . spi1rsts () , self . spi4rsts () , self . tim18rsts () , self . tim15rsts () , self . tim16rsts () , self . tim17rsts () , self . tim9rsts () , self . spi5rsts () , self . sai1rsts () , self . sai2rsts ())
        }
    }
    #[doc = "RCC APB3 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb3encr(pub u32);
    impl Apb3encr {
        #[doc = "DFT enable."]
        #[inline(always)]
        pub const fn dftenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DFT enable."]
        #[inline(always)]
        pub fn set_dftenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
    }
    impl Default for Apb3encr {
        #[inline(always)]
        fn default() -> Apb3encr {
            Apb3encr(0)
        }
    }
    impl core::fmt::Debug for Apb3encr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb3encr").field("dftenc", &self.dftenc()).finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb3encr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(f, "Apb3encr {{ dftenc: {=bool:?} }}", self.dftenc())
        }
    }
    #[doc = "RCC APB3 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb3enr(pub u32);
    impl Apb3enr {
        #[doc = "DFT enable."]
        #[inline(always)]
        pub const fn dften(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DFT enable."]
        #[inline(always)]
        pub fn set_dften(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
    }
    impl Default for Apb3enr {
        #[inline(always)]
        fn default() -> Apb3enr {
            Apb3enr(0)
        }
    }
    impl core::fmt::Debug for Apb3enr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb3enr").field("dften", &self.dften()).finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb3enr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(f, "Apb3enr {{ dften: {=bool:?} }}", self.dften())
        }
    }
    #[doc = "RCC APB3 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb3ensr(pub u32);
    impl Apb3ensr {
        #[doc = "DFT enable."]
        #[inline(always)]
        pub const fn dftens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DFT enable."]
        #[inline(always)]
        pub fn set_dftens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
    }
    impl Default for Apb3ensr {
        #[inline(always)]
        fn default() -> Apb3ensr {
            Apb3ensr(0)
        }
    }
    impl core::fmt::Debug for Apb3ensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb3ensr").field("dftens", &self.dftens()).finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb3ensr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(f, "Apb3ensr {{ dftens: {=bool:?} }}", self.dftens())
        }
    }
    #[doc = "RCC APB3 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb3lpencr(pub u32);
    impl Apb3lpencr {
        #[doc = "DFT sleep enable."]
        #[inline(always)]
        pub const fn dftlpenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DFT sleep enable."]
        #[inline(always)]
        pub fn set_dftlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
    }
    impl Default for Apb3lpencr {
        #[inline(always)]
        fn default() -> Apb3lpencr {
            Apb3lpencr(0)
        }
    }
    impl core::fmt::Debug for Apb3lpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb3lpencr")
                .field("dftlpenc", &self.dftlpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb3lpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(f, "Apb3lpencr {{ dftlpenc: {=bool:?} }}", self.dftlpenc())
        }
    }
    #[doc = "RCC APB3 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb3lpenr(pub u32);
    impl Apb3lpenr {
        #[doc = "DFT sleep enable."]
        #[inline(always)]
        pub const fn dftlpen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DFT sleep enable."]
        #[inline(always)]
        pub fn set_dftlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
    }
    impl Default for Apb3lpenr {
        #[inline(always)]
        fn default() -> Apb3lpenr {
            Apb3lpenr(0)
        }
    }
    impl core::fmt::Debug for Apb3lpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb3lpenr").field("dftlpen", &self.dftlpen()).finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb3lpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(f, "Apb3lpenr {{ dftlpen: {=bool:?} }}", self.dftlpen())
        }
    }
    #[doc = "RCC APB3 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb3lpensr(pub u32);
    impl Apb3lpensr {
        #[doc = "DFT sleep enable."]
        #[inline(always)]
        pub const fn dftlpens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DFT sleep enable."]
        #[inline(always)]
        pub fn set_dftlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
    }
    impl Default for Apb3lpensr {
        #[inline(always)]
        fn default() -> Apb3lpensr {
            Apb3lpensr(0)
        }
    }
    impl core::fmt::Debug for Apb3lpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb3lpensr")
                .field("dftlpens", &self.dftlpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb3lpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(f, "Apb3lpensr {{ dftlpens: {=bool:?} }}", self.dftlpens())
        }
    }
    #[doc = "RCC APB4H enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4hencr(pub u32);
    impl Apb4hencr {
        #[doc = "SYSCFG enable."]
        #[inline(always)]
        pub const fn syscfgenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFG enable."]
        #[inline(always)]
        pub fn set_syscfgenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "BSEC enable."]
        #[inline(always)]
        pub const fn bsecenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "BSEC enable."]
        #[inline(always)]
        pub fn set_bsecenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DTS enable."]
        #[inline(always)]
        pub const fn dtsenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DTS enable."]
        #[inline(always)]
        pub fn set_dtsenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "BUSPERFM enable."]
        #[inline(always)]
        pub const fn busperfmenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "BUSPERFM enable."]
        #[inline(always)]
        pub fn set_busperfmenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Apb4hencr {
        #[inline(always)]
        fn default() -> Apb4hencr {
            Apb4hencr(0)
        }
    }
    impl core::fmt::Debug for Apb4hencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4hencr")
                .field("syscfgenc", &self.syscfgenc())
                .field("bsecenc", &self.bsecenc())
                .field("dtsenc", &self.dtsenc())
                .field("busperfmenc", &self.busperfmenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4hencr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb4hencr {{ syscfgenc: {=bool:?}, bsecenc: {=bool:?}, dtsenc: {=bool:?}, busperfmenc: {=bool:?} }}",
                self.syscfgenc(),
                self.bsecenc(),
                self.dtsenc(),
                self.busperfmenc()
            )
        }
    }
    #[doc = "RCC APB4H enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4henr(pub u32);
    impl Apb4henr {
        #[doc = "SYSCFG enable."]
        #[inline(always)]
        pub const fn syscfgen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFG enable."]
        #[inline(always)]
        pub fn set_syscfgen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "BSEC enable."]
        #[inline(always)]
        pub const fn bsecen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "BSEC enable."]
        #[inline(always)]
        pub fn set_bsecen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DTS enable."]
        #[inline(always)]
        pub const fn dtsen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DTS enable."]
        #[inline(always)]
        pub fn set_dtsen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "BUSPERFM enable."]
        #[inline(always)]
        pub const fn busperfmen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "BUSPERFM enable."]
        #[inline(always)]
        pub fn set_busperfmen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Apb4henr {
        #[inline(always)]
        fn default() -> Apb4henr {
            Apb4henr(0)
        }
    }
    impl core::fmt::Debug for Apb4henr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4henr")
                .field("syscfgen", &self.syscfgen())
                .field("bsecen", &self.bsecen())
                .field("dtsen", &self.dtsen())
                .field("busperfmen", &self.busperfmen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4henr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb4henr {{ syscfgen: {=bool:?}, bsecen: {=bool:?}, dtsen: {=bool:?}, busperfmen: {=bool:?} }}",
                self.syscfgen(),
                self.bsecen(),
                self.dtsen(),
                self.busperfmen()
            )
        }
    }
    #[doc = "RCC APB4H enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4hensr(pub u32);
    impl Apb4hensr {
        #[doc = "SYSCFG enable."]
        #[inline(always)]
        pub const fn syscfgens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFG enable."]
        #[inline(always)]
        pub fn set_syscfgens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "BSEC enable."]
        #[inline(always)]
        pub const fn bsecens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "BSEC enable."]
        #[inline(always)]
        pub fn set_bsecens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DTS enable."]
        #[inline(always)]
        pub const fn dtsens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DTS enable."]
        #[inline(always)]
        pub fn set_dtsens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "BUSPERFM enable."]
        #[inline(always)]
        pub const fn busperfmens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "BUSPERFM enable."]
        #[inline(always)]
        pub fn set_busperfmens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Apb4hensr {
        #[inline(always)]
        fn default() -> Apb4hensr {
            Apb4hensr(0)
        }
    }
    impl core::fmt::Debug for Apb4hensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4hensr")
                .field("syscfgens", &self.syscfgens())
                .field("bsecens", &self.bsecens())
                .field("dtsens", &self.dtsens())
                .field("busperfmens", &self.busperfmens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4hensr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb4hensr {{ syscfgens: {=bool:?}, bsecens: {=bool:?}, dtsens: {=bool:?}, busperfmens: {=bool:?} }}",
                self.syscfgens(),
                self.bsecens(),
                self.dtsens(),
                self.busperfmens()
            )
        }
    }
    #[doc = "RCC APB4H Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4hlpencr(pub u32);
    impl Apb4hlpencr {
        #[doc = "SYSCFG sleep enable."]
        #[inline(always)]
        pub const fn syscfglpenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFG sleep enable."]
        #[inline(always)]
        pub fn set_syscfglpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "BSEC sleep enable."]
        #[inline(always)]
        pub const fn bseclpenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "BSEC sleep enable."]
        #[inline(always)]
        pub fn set_bseclpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DTS sleep enable."]
        #[inline(always)]
        pub const fn dtslpenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DTS sleep enable."]
        #[inline(always)]
        pub fn set_dtslpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "BUSPERFM sleep enable."]
        #[inline(always)]
        pub const fn busperfmlpenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "BUSPERFM sleep enable."]
        #[inline(always)]
        pub fn set_busperfmlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Apb4hlpencr {
        #[inline(always)]
        fn default() -> Apb4hlpencr {
            Apb4hlpencr(0)
        }
    }
    impl core::fmt::Debug for Apb4hlpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4hlpencr")
                .field("syscfglpenc", &self.syscfglpenc())
                .field("bseclpenc", &self.bseclpenc())
                .field("dtslpenc", &self.dtslpenc())
                .field("busperfmlpenc", &self.busperfmlpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4hlpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb4hlpencr {{ syscfglpenc: {=bool:?}, bseclpenc: {=bool:?}, dtslpenc: {=bool:?}, busperfmlpenc: {=bool:?} }}" , self . syscfglpenc () , self . bseclpenc () , self . dtslpenc () , self . busperfmlpenc ())
        }
    }
    #[doc = "RCC APB4H Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4hlpenr(pub u32);
    impl Apb4hlpenr {
        #[doc = "SYSCFG sleep enable."]
        #[inline(always)]
        pub const fn syscfglpen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFG sleep enable."]
        #[inline(always)]
        pub fn set_syscfglpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "BSEC sleep enable."]
        #[inline(always)]
        pub const fn bseclpen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "BSEC sleep enable."]
        #[inline(always)]
        pub fn set_bseclpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DTS sleep enable."]
        #[inline(always)]
        pub const fn dtslpen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DTS sleep enable."]
        #[inline(always)]
        pub fn set_dtslpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "BUSPERFM sleep enable."]
        #[inline(always)]
        pub const fn busperfmlpen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "BUSPERFM sleep enable."]
        #[inline(always)]
        pub fn set_busperfmlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Apb4hlpenr {
        #[inline(always)]
        fn default() -> Apb4hlpenr {
            Apb4hlpenr(0)
        }
    }
    impl core::fmt::Debug for Apb4hlpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4hlpenr")
                .field("syscfglpen", &self.syscfglpen())
                .field("bseclpen", &self.bseclpen())
                .field("dtslpen", &self.dtslpen())
                .field("busperfmlpen", &self.busperfmlpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4hlpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb4hlpenr {{ syscfglpen: {=bool:?}, bseclpen: {=bool:?}, dtslpen: {=bool:?}, busperfmlpen: {=bool:?} }}" , self . syscfglpen () , self . bseclpen () , self . dtslpen () , self . busperfmlpen ())
        }
    }
    #[doc = "RCC APB4H Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4hlpensr(pub u32);
    impl Apb4hlpensr {
        #[doc = "SYSCFG sleep enable."]
        #[inline(always)]
        pub const fn syscfglpens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFG sleep enable."]
        #[inline(always)]
        pub fn set_syscfglpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "BSEC sleep enable."]
        #[inline(always)]
        pub const fn bseclpens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "BSEC sleep enable."]
        #[inline(always)]
        pub fn set_bseclpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DTS sleep enable."]
        #[inline(always)]
        pub const fn dtslpens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DTS sleep enable."]
        #[inline(always)]
        pub fn set_dtslpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "BUSPERFM sleep enable."]
        #[inline(always)]
        pub const fn busperfmlpens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "BUSPERFM sleep enable."]
        #[inline(always)]
        pub fn set_busperfmlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Apb4hlpensr {
        #[inline(always)]
        fn default() -> Apb4hlpensr {
            Apb4hlpensr(0)
        }
    }
    impl core::fmt::Debug for Apb4hlpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4hlpensr")
                .field("syscfglpens", &self.syscfglpens())
                .field("bseclpens", &self.bseclpens())
                .field("dtslpens", &self.dtslpens())
                .field("busperfmlpens", &self.busperfmlpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4hlpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb4hlpensr {{ syscfglpens: {=bool:?}, bseclpens: {=bool:?}, dtslpens: {=bool:?}, busperfmlpens: {=bool:?} }}" , self . syscfglpens () , self . bseclpens () , self . dtslpens () , self . busperfmlpens ())
        }
    }
    #[doc = "RCC APB4H reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4hrstcr(pub u32);
    impl Apb4hrstcr {
        #[doc = "SYSCFG reset."]
        #[inline(always)]
        pub const fn syscfgrstc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFG reset."]
        #[inline(always)]
        pub fn set_syscfgrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "DTS reset."]
        #[inline(always)]
        pub const fn dtsrstc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DTS reset."]
        #[inline(always)]
        pub fn set_dtsrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "BUSPERFM reset."]
        #[inline(always)]
        pub const fn busperfmrstc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "BUSPERFM reset."]
        #[inline(always)]
        pub fn set_busperfmrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Apb4hrstcr {
        #[inline(always)]
        fn default() -> Apb4hrstcr {
            Apb4hrstcr(0)
        }
    }
    impl core::fmt::Debug for Apb4hrstcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4hrstcr")
                .field("syscfgrstc", &self.syscfgrstc())
                .field("dtsrstc", &self.dtsrstc())
                .field("busperfmrstc", &self.busperfmrstc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4hrstcr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb4hrstcr {{ syscfgrstc: {=bool:?}, dtsrstc: {=bool:?}, busperfmrstc: {=bool:?} }}",
                self.syscfgrstc(),
                self.dtsrstc(),
                self.busperfmrstc()
            )
        }
    }
    #[doc = "RCC APB4H reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4hrstr(pub u32);
    impl Apb4hrstr {
        #[doc = "SYSCFG reset."]
        #[inline(always)]
        pub const fn syscfgrst(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFG reset."]
        #[inline(always)]
        pub fn set_syscfgrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "DTS reset."]
        #[inline(always)]
        pub const fn dtsrst(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DTS reset."]
        #[inline(always)]
        pub fn set_dtsrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "BUSPERFM reset."]
        #[inline(always)]
        pub const fn busperfmrst(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "BUSPERFM reset."]
        #[inline(always)]
        pub fn set_busperfmrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Apb4hrstr {
        #[inline(always)]
        fn default() -> Apb4hrstr {
            Apb4hrstr(0)
        }
    }
    impl core::fmt::Debug for Apb4hrstr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4hrstr")
                .field("syscfgrst", &self.syscfgrst())
                .field("dtsrst", &self.dtsrst())
                .field("busperfmrst", &self.busperfmrst())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4hrstr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb4hrstr {{ syscfgrst: {=bool:?}, dtsrst: {=bool:?}, busperfmrst: {=bool:?} }}",
                self.syscfgrst(),
                self.dtsrst(),
                self.busperfmrst()
            )
        }
    }
    #[doc = "RCC APB4H reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4hrstsr(pub u32);
    impl Apb4hrstsr {
        #[doc = "SYSCFG reset."]
        #[inline(always)]
        pub const fn syscfgrsts(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "SYSCFG reset."]
        #[inline(always)]
        pub fn set_syscfgrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "DTS reset."]
        #[inline(always)]
        pub const fn dtsrsts(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DTS reset."]
        #[inline(always)]
        pub fn set_dtsrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "BUSPERFM reset."]
        #[inline(always)]
        pub const fn busperfmrsts(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "BUSPERFM reset."]
        #[inline(always)]
        pub fn set_busperfmrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Apb4hrstsr {
        #[inline(always)]
        fn default() -> Apb4hrstsr {
            Apb4hrstsr(0)
        }
    }
    impl core::fmt::Debug for Apb4hrstsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4hrstsr")
                .field("syscfgrsts", &self.syscfgrsts())
                .field("dtsrsts", &self.dtsrsts())
                .field("busperfmrsts", &self.busperfmrsts())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4hrstsr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Apb4hrstsr {{ syscfgrsts: {=bool:?}, dtsrsts: {=bool:?}, busperfmrsts: {=bool:?} }}",
                self.syscfgrsts(),
                self.dtsrsts(),
                self.busperfmrsts()
            )
        }
    }
    #[doc = "RCC APB4L enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4lencr(pub u32);
    impl Apb4lencr {
        #[doc = "HDP enable."]
        #[inline(always)]
        pub const fn hdpenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "HDP enable."]
        #[inline(always)]
        pub fn set_hdpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "LPUART1 enable."]
        #[inline(always)]
        pub const fn lpuart1enc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "LPUART1 enable."]
        #[inline(always)]
        pub fn set_lpuart1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "SPI6 enable."]
        #[inline(always)]
        pub const fn spi6enc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "SPI6 enable."]
        #[inline(always)]
        pub fn set_spi6enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "I2C4 enable."]
        #[inline(always)]
        pub const fn i2c4enc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "I2C4 enable."]
        #[inline(always)]
        pub fn set_i2c4enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "LPTIM2 enable."]
        #[inline(always)]
        pub const fn lptim2enc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM2 enable."]
        #[inline(always)]
        pub fn set_lptim2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "LPTIM3 enable."]
        #[inline(always)]
        pub const fn lptim3enc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM3 enable."]
        #[inline(always)]
        pub fn set_lptim3enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "LPTIM4 enable."]
        #[inline(always)]
        pub const fn lptim4enc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM4 enable."]
        #[inline(always)]
        pub fn set_lptim4enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "LPTIM5 enable."]
        #[inline(always)]
        pub const fn lptim5enc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM5 enable."]
        #[inline(always)]
        pub fn set_lptim5enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "VREFBUF enable."]
        #[inline(always)]
        pub const fn vrefbufenc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "VREFBUF enable."]
        #[inline(always)]
        pub fn set_vrefbufenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "RTC enable."]
        #[inline(always)]
        pub const fn rtcenc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "RTC enable."]
        #[inline(always)]
        pub fn set_rtcenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "R2GRET enable."]
        #[inline(always)]
        pub const fn r2gretenc(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "R2GRET enable."]
        #[inline(always)]
        pub fn set_r2gretenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "R2GNPU enable."]
        #[inline(always)]
        pub const fn r2gnpuenc(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "R2GNPU enable."]
        #[inline(always)]
        pub fn set_r2gnpuenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "SERF enable."]
        #[inline(always)]
        pub const fn serfenc(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "SERF enable."]
        #[inline(always)]
        pub fn set_serfenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb4lencr {
        #[inline(always)]
        fn default() -> Apb4lencr {
            Apb4lencr(0)
        }
    }
    impl core::fmt::Debug for Apb4lencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4lencr")
                .field("hdpenc", &self.hdpenc())
                .field("lpuart1enc", &self.lpuart1enc())
                .field("spi6enc", &self.spi6enc())
                .field("i2c4enc", &self.i2c4enc())
                .field("lptim2enc", &self.lptim2enc())
                .field("lptim3enc", &self.lptim3enc())
                .field("lptim4enc", &self.lptim4enc())
                .field("lptim5enc", &self.lptim5enc())
                .field("vrefbufenc", &self.vrefbufenc())
                .field("rtcenc", &self.rtcenc())
                .field("r2gretenc", &self.r2gretenc())
                .field("r2gnpuenc", &self.r2gnpuenc())
                .field("serfenc", &self.serfenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4lencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb4lencr {{ hdpenc: {=bool:?}, lpuart1enc: {=bool:?}, spi6enc: {=bool:?}, i2c4enc: {=bool:?}, lptim2enc: {=bool:?}, lptim3enc: {=bool:?}, lptim4enc: {=bool:?}, lptim5enc: {=bool:?}, vrefbufenc: {=bool:?}, rtcenc: {=bool:?}, r2gretenc: {=bool:?}, r2gnpuenc: {=bool:?}, serfenc: {=bool:?} }}" , self . hdpenc () , self . lpuart1enc () , self . spi6enc () , self . i2c4enc () , self . lptim2enc () , self . lptim3enc () , self . lptim4enc () , self . lptim5enc () , self . vrefbufenc () , self . rtcenc () , self . r2gretenc () , self . r2gnpuenc () , self . serfenc ())
        }
    }
    #[doc = "RCC APB4L enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4lenr(pub u32);
    impl Apb4lenr {
        #[doc = "HDP enable."]
        #[inline(always)]
        pub const fn hdpen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "HDP enable."]
        #[inline(always)]
        pub fn set_hdpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "LPUART1 enable."]
        #[inline(always)]
        pub const fn lpuart1en(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "LPUART1 enable."]
        #[inline(always)]
        pub fn set_lpuart1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "SPI6 enable."]
        #[inline(always)]
        pub const fn spi6en(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "SPI6 enable."]
        #[inline(always)]
        pub fn set_spi6en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "I2C4 enable."]
        #[inline(always)]
        pub const fn i2c4en(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "I2C4 enable."]
        #[inline(always)]
        pub fn set_i2c4en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "LPTIM2 enable."]
        #[inline(always)]
        pub const fn lptim2en(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM2 enable."]
        #[inline(always)]
        pub fn set_lptim2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "LPTIM3 enable."]
        #[inline(always)]
        pub const fn lptim3en(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM3 enable."]
        #[inline(always)]
        pub fn set_lptim3en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "LPTIM4 enable."]
        #[inline(always)]
        pub const fn lptim4en(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM4 enable."]
        #[inline(always)]
        pub fn set_lptim4en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "LPTIM5 enable."]
        #[inline(always)]
        pub const fn lptim5en(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM5 enable."]
        #[inline(always)]
        pub fn set_lptim5en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "VREFBUF enable."]
        #[inline(always)]
        pub const fn vrefbufen(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "VREFBUF enable."]
        #[inline(always)]
        pub fn set_vrefbufen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "RTC enable."]
        #[inline(always)]
        pub const fn rtcen(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "RTC enable."]
        #[inline(always)]
        pub fn set_rtcen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "R2GRET enable."]
        #[inline(always)]
        pub const fn r2greten(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "R2GRET enable."]
        #[inline(always)]
        pub fn set_r2greten(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "R2GNPU enable."]
        #[inline(always)]
        pub const fn r2gnpuen(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "R2GNPU enable."]
        #[inline(always)]
        pub fn set_r2gnpuen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "SERF enable."]
        #[inline(always)]
        pub const fn serfen(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "SERF enable."]
        #[inline(always)]
        pub fn set_serfen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb4lenr {
        #[inline(always)]
        fn default() -> Apb4lenr {
            Apb4lenr(0)
        }
    }
    impl core::fmt::Debug for Apb4lenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4lenr")
                .field("hdpen", &self.hdpen())
                .field("lpuart1en", &self.lpuart1en())
                .field("spi6en", &self.spi6en())
                .field("i2c4en", &self.i2c4en())
                .field("lptim2en", &self.lptim2en())
                .field("lptim3en", &self.lptim3en())
                .field("lptim4en", &self.lptim4en())
                .field("lptim5en", &self.lptim5en())
                .field("vrefbufen", &self.vrefbufen())
                .field("rtcen", &self.rtcen())
                .field("r2greten", &self.r2greten())
                .field("r2gnpuen", &self.r2gnpuen())
                .field("serfen", &self.serfen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4lenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb4lenr {{ hdpen: {=bool:?}, lpuart1en: {=bool:?}, spi6en: {=bool:?}, i2c4en: {=bool:?}, lptim2en: {=bool:?}, lptim3en: {=bool:?}, lptim4en: {=bool:?}, lptim5en: {=bool:?}, vrefbufen: {=bool:?}, rtcen: {=bool:?}, r2greten: {=bool:?}, r2gnpuen: {=bool:?}, serfen: {=bool:?} }}" , self . hdpen () , self . lpuart1en () , self . spi6en () , self . i2c4en () , self . lptim2en () , self . lptim3en () , self . lptim4en () , self . lptim5en () , self . vrefbufen () , self . rtcen () , self . r2greten () , self . r2gnpuen () , self . serfen ())
        }
    }
    #[doc = "RCC APB4L enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4lensr(pub u32);
    impl Apb4lensr {
        #[doc = "HDP enable."]
        #[inline(always)]
        pub const fn hdpens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "HDP enable."]
        #[inline(always)]
        pub fn set_hdpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "LPUART1 enable."]
        #[inline(always)]
        pub const fn lpuart1ens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "LPUART1 enable."]
        #[inline(always)]
        pub fn set_lpuart1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "SPI6 enable."]
        #[inline(always)]
        pub const fn spi6ens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "SPI6 enable."]
        #[inline(always)]
        pub fn set_spi6ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "I2C4 enable."]
        #[inline(always)]
        pub const fn i2c4ens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "I2C4 enable."]
        #[inline(always)]
        pub fn set_i2c4ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "LPTIM2 enable."]
        #[inline(always)]
        pub const fn lptim2ens(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM2 enable."]
        #[inline(always)]
        pub fn set_lptim2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "LPTIM3 enable."]
        #[inline(always)]
        pub const fn lptim3ens(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM3 enable."]
        #[inline(always)]
        pub fn set_lptim3ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "LPTIM4 enable."]
        #[inline(always)]
        pub const fn lptim4ens(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM4 enable."]
        #[inline(always)]
        pub fn set_lptim4ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "LPTIM5 enable."]
        #[inline(always)]
        pub const fn lptim5ens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM5 enable."]
        #[inline(always)]
        pub fn set_lptim5ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "VREFBUF enable."]
        #[inline(always)]
        pub const fn vrefbufens(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "VREFBUF enable."]
        #[inline(always)]
        pub fn set_vrefbufens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "RTC enable."]
        #[inline(always)]
        pub const fn rtcens(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "RTC enable."]
        #[inline(always)]
        pub fn set_rtcens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "R2GRET enable."]
        #[inline(always)]
        pub const fn r2gretens(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "R2GRET enable."]
        #[inline(always)]
        pub fn set_r2gretens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "R2GNPU enable."]
        #[inline(always)]
        pub const fn r2gnpuens(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "R2GNPU enable."]
        #[inline(always)]
        pub fn set_r2gnpuens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "SERF enable."]
        #[inline(always)]
        pub const fn serfens(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "SERF enable."]
        #[inline(always)]
        pub fn set_serfens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb4lensr {
        #[inline(always)]
        fn default() -> Apb4lensr {
            Apb4lensr(0)
        }
    }
    impl core::fmt::Debug for Apb4lensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4lensr")
                .field("hdpens", &self.hdpens())
                .field("lpuart1ens", &self.lpuart1ens())
                .field("spi6ens", &self.spi6ens())
                .field("i2c4ens", &self.i2c4ens())
                .field("lptim2ens", &self.lptim2ens())
                .field("lptim3ens", &self.lptim3ens())
                .field("lptim4ens", &self.lptim4ens())
                .field("lptim5ens", &self.lptim5ens())
                .field("vrefbufens", &self.vrefbufens())
                .field("rtcens", &self.rtcens())
                .field("r2gretens", &self.r2gretens())
                .field("r2gnpuens", &self.r2gnpuens())
                .field("serfens", &self.serfens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4lensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb4lensr {{ hdpens: {=bool:?}, lpuart1ens: {=bool:?}, spi6ens: {=bool:?}, i2c4ens: {=bool:?}, lptim2ens: {=bool:?}, lptim3ens: {=bool:?}, lptim4ens: {=bool:?}, lptim5ens: {=bool:?}, vrefbufens: {=bool:?}, rtcens: {=bool:?}, r2gretens: {=bool:?}, r2gnpuens: {=bool:?}, serfens: {=bool:?} }}" , self . hdpens () , self . lpuart1ens () , self . spi6ens () , self . i2c4ens () , self . lptim2ens () , self . lptim3ens () , self . lptim4ens () , self . lptim5ens () , self . vrefbufens () , self . rtcens () , self . r2gretens () , self . r2gnpuens () , self . serfens ())
        }
    }
    #[doc = "RCC APB4L Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4llpencr(pub u32);
    impl Apb4llpencr {
        #[doc = "HDP sleep enable."]
        #[inline(always)]
        pub const fn hdplpenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "HDP sleep enable."]
        #[inline(always)]
        pub fn set_hdplpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "LPUART1 sleep enable."]
        #[inline(always)]
        pub const fn lpuart1lpenc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "LPUART1 sleep enable."]
        #[inline(always)]
        pub fn set_lpuart1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "SPI6 sleep enable."]
        #[inline(always)]
        pub const fn spi6lpenc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "SPI6 sleep enable."]
        #[inline(always)]
        pub fn set_spi6lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "I2C4 sleep enable."]
        #[inline(always)]
        pub const fn i2c4lpenc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "I2C4 sleep enable."]
        #[inline(always)]
        pub fn set_i2c4lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "LPTIM2 sleep enable."]
        #[inline(always)]
        pub const fn lptim2lpenc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM2 sleep enable."]
        #[inline(always)]
        pub fn set_lptim2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "LPTIM3 sleep enable."]
        #[inline(always)]
        pub const fn lptim3lpenc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM3 sleep enable."]
        #[inline(always)]
        pub fn set_lptim3lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "LPTIM4 sleep enable."]
        #[inline(always)]
        pub const fn lptim4lpenc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM4 sleep enable."]
        #[inline(always)]
        pub fn set_lptim4lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "LPTIM5 sleep enable."]
        #[inline(always)]
        pub const fn lptim5lpenc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM5 sleep enable."]
        #[inline(always)]
        pub fn set_lptim5lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "VREFBUF sleep enable."]
        #[inline(always)]
        pub const fn vrefbuflpenc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "VREFBUF sleep enable."]
        #[inline(always)]
        pub fn set_vrefbuflpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "RTC sleep enable."]
        #[inline(always)]
        pub const fn rtclpenc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "RTC sleep enable."]
        #[inline(always)]
        pub fn set_rtclpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "RTCAPB sleep enable."]
        #[inline(always)]
        pub const fn rtcapblpenc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "RTCAPB sleep enable."]
        #[inline(always)]
        pub fn set_rtcapblpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "R2GRET sleep enable."]
        #[inline(always)]
        pub const fn r2gretlpenc(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "R2GRET sleep enable."]
        #[inline(always)]
        pub fn set_r2gretlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "R2GNPU sleep enable."]
        #[inline(always)]
        pub const fn r2gnpulpenc(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "R2GNPU sleep enable."]
        #[inline(always)]
        pub fn set_r2gnpulpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "SERF sleep enable."]
        #[inline(always)]
        pub const fn serflpenc(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "SERF sleep enable."]
        #[inline(always)]
        pub fn set_serflpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb4llpencr {
        #[inline(always)]
        fn default() -> Apb4llpencr {
            Apb4llpencr(0)
        }
    }
    impl core::fmt::Debug for Apb4llpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4llpencr")
                .field("hdplpenc", &self.hdplpenc())
                .field("lpuart1lpenc", &self.lpuart1lpenc())
                .field("spi6lpenc", &self.spi6lpenc())
                .field("i2c4lpenc", &self.i2c4lpenc())
                .field("lptim2lpenc", &self.lptim2lpenc())
                .field("lptim3lpenc", &self.lptim3lpenc())
                .field("lptim4lpenc", &self.lptim4lpenc())
                .field("lptim5lpenc", &self.lptim5lpenc())
                .field("vrefbuflpenc", &self.vrefbuflpenc())
                .field("rtclpenc", &self.rtclpenc())
                .field("rtcapblpenc", &self.rtcapblpenc())
                .field("r2gretlpenc", &self.r2gretlpenc())
                .field("r2gnpulpenc", &self.r2gnpulpenc())
                .field("serflpenc", &self.serflpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4llpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb4llpencr {{ hdplpenc: {=bool:?}, lpuart1lpenc: {=bool:?}, spi6lpenc: {=bool:?}, i2c4lpenc: {=bool:?}, lptim2lpenc: {=bool:?}, lptim3lpenc: {=bool:?}, lptim4lpenc: {=bool:?}, lptim5lpenc: {=bool:?}, vrefbuflpenc: {=bool:?}, rtclpenc: {=bool:?}, rtcapblpenc: {=bool:?}, r2gretlpenc: {=bool:?}, r2gnpulpenc: {=bool:?}, serflpenc: {=bool:?} }}" , self . hdplpenc () , self . lpuart1lpenc () , self . spi6lpenc () , self . i2c4lpenc () , self . lptim2lpenc () , self . lptim3lpenc () , self . lptim4lpenc () , self . lptim5lpenc () , self . vrefbuflpenc () , self . rtclpenc () , self . rtcapblpenc () , self . r2gretlpenc () , self . r2gnpulpenc () , self . serflpenc ())
        }
    }
    #[doc = "RCC APB4L Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4llpenr(pub u32);
    impl Apb4llpenr {
        #[doc = "HDP sleep enable."]
        #[inline(always)]
        pub const fn hdplpen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "HDP sleep enable."]
        #[inline(always)]
        pub fn set_hdplpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "LPUART1 sleep enable."]
        #[inline(always)]
        pub const fn lpuart1lpen(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "LPUART1 sleep enable."]
        #[inline(always)]
        pub fn set_lpuart1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "SPI6 sleep enable."]
        #[inline(always)]
        pub const fn spi6lpen(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "SPI6 sleep enable."]
        #[inline(always)]
        pub fn set_spi6lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "I2C4 sleep enable."]
        #[inline(always)]
        pub const fn i2c4lpen(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "I2C4 sleep enable."]
        #[inline(always)]
        pub fn set_i2c4lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "LPTIM2 sleep enable."]
        #[inline(always)]
        pub const fn lptim2lpen(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM2 sleep enable."]
        #[inline(always)]
        pub fn set_lptim2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "LPTIM3 sleep enable."]
        #[inline(always)]
        pub const fn lptim3lpen(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM3 sleep enable."]
        #[inline(always)]
        pub fn set_lptim3lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "LPTIM4 sleep enable."]
        #[inline(always)]
        pub const fn lptim4lpen(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM4 sleep enable."]
        #[inline(always)]
        pub fn set_lptim4lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "LPTIM5 sleep enable."]
        #[inline(always)]
        pub const fn lptim5lpen(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM5 sleep enable."]
        #[inline(always)]
        pub fn set_lptim5lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "VREFBUF sleep enable."]
        #[inline(always)]
        pub const fn vrefbuflpen(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "VREFBUF sleep enable."]
        #[inline(always)]
        pub fn set_vrefbuflpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "RTC sleep enable."]
        #[inline(always)]
        pub const fn rtclpen(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "RTC sleep enable."]
        #[inline(always)]
        pub fn set_rtclpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "RTCAPB sleep enable."]
        #[inline(always)]
        pub const fn rtcapblpen(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "RTCAPB sleep enable."]
        #[inline(always)]
        pub fn set_rtcapblpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "R2GRET sleep enable."]
        #[inline(always)]
        pub const fn r2gretlpen(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "R2GRET sleep enable."]
        #[inline(always)]
        pub fn set_r2gretlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "R2GNPU sleep enable."]
        #[inline(always)]
        pub const fn r2gnpulpen(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "R2GNPU sleep enable."]
        #[inline(always)]
        pub fn set_r2gnpulpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "SERF sleep enable."]
        #[inline(always)]
        pub const fn serflpen(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "SERF sleep enable."]
        #[inline(always)]
        pub fn set_serflpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb4llpenr {
        #[inline(always)]
        fn default() -> Apb4llpenr {
            Apb4llpenr(0)
        }
    }
    impl core::fmt::Debug for Apb4llpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4llpenr")
                .field("hdplpen", &self.hdplpen())
                .field("lpuart1lpen", &self.lpuart1lpen())
                .field("spi6lpen", &self.spi6lpen())
                .field("i2c4lpen", &self.i2c4lpen())
                .field("lptim2lpen", &self.lptim2lpen())
                .field("lptim3lpen", &self.lptim3lpen())
                .field("lptim4lpen", &self.lptim4lpen())
                .field("lptim5lpen", &self.lptim5lpen())
                .field("vrefbuflpen", &self.vrefbuflpen())
                .field("rtclpen", &self.rtclpen())
                .field("rtcapblpen", &self.rtcapblpen())
                .field("r2gretlpen", &self.r2gretlpen())
                .field("r2gnpulpen", &self.r2gnpulpen())
                .field("serflpen", &self.serflpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4llpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb4llpenr {{ hdplpen: {=bool:?}, lpuart1lpen: {=bool:?}, spi6lpen: {=bool:?}, i2c4lpen: {=bool:?}, lptim2lpen: {=bool:?}, lptim3lpen: {=bool:?}, lptim4lpen: {=bool:?}, lptim5lpen: {=bool:?}, vrefbuflpen: {=bool:?}, rtclpen: {=bool:?}, rtcapblpen: {=bool:?}, r2gretlpen: {=bool:?}, r2gnpulpen: {=bool:?}, serflpen: {=bool:?} }}" , self . hdplpen () , self . lpuart1lpen () , self . spi6lpen () , self . i2c4lpen () , self . lptim2lpen () , self . lptim3lpen () , self . lptim4lpen () , self . lptim5lpen () , self . vrefbuflpen () , self . rtclpen () , self . rtcapblpen () , self . r2gretlpen () , self . r2gnpulpen () , self . serflpen ())
        }
    }
    #[doc = "RCC APB4L Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4llpensr(pub u32);
    impl Apb4llpensr {
        #[doc = "HDP sleep enable."]
        #[inline(always)]
        pub const fn hdplpens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "HDP sleep enable."]
        #[inline(always)]
        pub fn set_hdplpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "LPUART1 sleep enable."]
        #[inline(always)]
        pub const fn lpuart1lpens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "LPUART1 sleep enable."]
        #[inline(always)]
        pub fn set_lpuart1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "SPI6 sleep enable."]
        #[inline(always)]
        pub const fn spi6lpens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "SPI6 sleep enable."]
        #[inline(always)]
        pub fn set_spi6lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "I2C4 sleep enable."]
        #[inline(always)]
        pub const fn i2c4lpens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "I2C4 sleep enable."]
        #[inline(always)]
        pub fn set_i2c4lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "LPTIM2 sleep enable."]
        #[inline(always)]
        pub const fn lptim2lpens(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM2 sleep enable."]
        #[inline(always)]
        pub fn set_lptim2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "LPTIM3 sleep enable."]
        #[inline(always)]
        pub const fn lptim3lpens(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM3 sleep enable."]
        #[inline(always)]
        pub fn set_lptim3lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "LPTIM4 sleep enable."]
        #[inline(always)]
        pub const fn lptim4lpens(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM4 sleep enable."]
        #[inline(always)]
        pub fn set_lptim4lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "LPTIM5 sleep enable."]
        #[inline(always)]
        pub const fn lptim5lpens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM5 sleep enable."]
        #[inline(always)]
        pub fn set_lptim5lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "VREFBUF sleep enable."]
        #[inline(always)]
        pub const fn vrefbuflpens(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "VREFBUF sleep enable."]
        #[inline(always)]
        pub fn set_vrefbuflpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "RTC sleep enable."]
        #[inline(always)]
        pub const fn rtclpens(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "RTC sleep enable."]
        #[inline(always)]
        pub fn set_rtclpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "RTCAPB sleep enable."]
        #[inline(always)]
        pub const fn rtcapblpens(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "RTCAPB sleep enable."]
        #[inline(always)]
        pub fn set_rtcapblpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "R2GRET sleep enable."]
        #[inline(always)]
        pub const fn r2gretlpens(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "R2GRET sleep enable."]
        #[inline(always)]
        pub fn set_r2gretlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "R2GNPU sleep enable."]
        #[inline(always)]
        pub const fn r2gnpulpens(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "R2GNPU sleep enable."]
        #[inline(always)]
        pub fn set_r2gnpulpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "SERF sleep enable."]
        #[inline(always)]
        pub const fn serflpens(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "SERF sleep enable."]
        #[inline(always)]
        pub fn set_serflpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb4llpensr {
        #[inline(always)]
        fn default() -> Apb4llpensr {
            Apb4llpensr(0)
        }
    }
    impl core::fmt::Debug for Apb4llpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4llpensr")
                .field("hdplpens", &self.hdplpens())
                .field("lpuart1lpens", &self.lpuart1lpens())
                .field("spi6lpens", &self.spi6lpens())
                .field("i2c4lpens", &self.i2c4lpens())
                .field("lptim2lpens", &self.lptim2lpens())
                .field("lptim3lpens", &self.lptim3lpens())
                .field("lptim4lpens", &self.lptim4lpens())
                .field("lptim5lpens", &self.lptim5lpens())
                .field("vrefbuflpens", &self.vrefbuflpens())
                .field("rtclpens", &self.rtclpens())
                .field("rtcapblpens", &self.rtcapblpens())
                .field("r2gretlpens", &self.r2gretlpens())
                .field("r2gnpulpens", &self.r2gnpulpens())
                .field("serflpens", &self.serflpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4llpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb4llpensr {{ hdplpens: {=bool:?}, lpuart1lpens: {=bool:?}, spi6lpens: {=bool:?}, i2c4lpens: {=bool:?}, lptim2lpens: {=bool:?}, lptim3lpens: {=bool:?}, lptim4lpens: {=bool:?}, lptim5lpens: {=bool:?}, vrefbuflpens: {=bool:?}, rtclpens: {=bool:?}, rtcapblpens: {=bool:?}, r2gretlpens: {=bool:?}, r2gnpulpens: {=bool:?}, serflpens: {=bool:?} }}" , self . hdplpens () , self . lpuart1lpens () , self . spi6lpens () , self . i2c4lpens () , self . lptim2lpens () , self . lptim3lpens () , self . lptim4lpens () , self . lptim5lpens () , self . vrefbuflpens () , self . rtclpens () , self . rtcapblpens () , self . r2gretlpens () , self . r2gnpulpens () , self . serflpens ())
        }
    }
    #[doc = "RCC APB4L reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4lrstcr(pub u32);
    impl Apb4lrstcr {
        #[doc = "HDP reset."]
        #[inline(always)]
        pub const fn hdprstc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "HDP reset."]
        #[inline(always)]
        pub fn set_hdprstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "LPUART1 reset."]
        #[inline(always)]
        pub const fn lpuart1rstc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "LPUART1 reset."]
        #[inline(always)]
        pub fn set_lpuart1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "SPI6 reset."]
        #[inline(always)]
        pub const fn spi6rstc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "SPI6 reset."]
        #[inline(always)]
        pub fn set_spi6rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "I2C4 reset."]
        #[inline(always)]
        pub const fn i2c4rstc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "I2C4 reset."]
        #[inline(always)]
        pub fn set_i2c4rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "LPTIM2 reset."]
        #[inline(always)]
        pub const fn lptim2rstc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM2 reset."]
        #[inline(always)]
        pub fn set_lptim2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "LPTIM3 reset."]
        #[inline(always)]
        pub const fn lptim3rstc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM3 reset."]
        #[inline(always)]
        pub fn set_lptim3rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "LPTIM4 reset."]
        #[inline(always)]
        pub const fn lptim4rstc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM4 reset."]
        #[inline(always)]
        pub fn set_lptim4rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "LPTIM5 reset."]
        #[inline(always)]
        pub const fn lptim5rstc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM5 reset."]
        #[inline(always)]
        pub fn set_lptim5rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "VREFBUF reset."]
        #[inline(always)]
        pub const fn vrefbufrstc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "VREFBUF reset."]
        #[inline(always)]
        pub fn set_vrefbufrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "RTC reset."]
        #[inline(always)]
        pub const fn rtcrstc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "RTC reset."]
        #[inline(always)]
        pub fn set_rtcrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "R2GRET reset."]
        #[inline(always)]
        pub const fn r2gretrstc(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "R2GRET reset."]
        #[inline(always)]
        pub fn set_r2gretrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "R2GNPU reset."]
        #[inline(always)]
        pub const fn r2gnpurstc(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "R2GNPU reset."]
        #[inline(always)]
        pub fn set_r2gnpurstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "SERF reset."]
        #[inline(always)]
        pub const fn serfrstc(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "SERF reset."]
        #[inline(always)]
        pub fn set_serfrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb4lrstcr {
        #[inline(always)]
        fn default() -> Apb4lrstcr {
            Apb4lrstcr(0)
        }
    }
    impl core::fmt::Debug for Apb4lrstcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4lrstcr")
                .field("hdprstc", &self.hdprstc())
                .field("lpuart1rstc", &self.lpuart1rstc())
                .field("spi6rstc", &self.spi6rstc())
                .field("i2c4rstc", &self.i2c4rstc())
                .field("lptim2rstc", &self.lptim2rstc())
                .field("lptim3rstc", &self.lptim3rstc())
                .field("lptim4rstc", &self.lptim4rstc())
                .field("lptim5rstc", &self.lptim5rstc())
                .field("vrefbufrstc", &self.vrefbufrstc())
                .field("rtcrstc", &self.rtcrstc())
                .field("r2gretrstc", &self.r2gretrstc())
                .field("r2gnpurstc", &self.r2gnpurstc())
                .field("serfrstc", &self.serfrstc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4lrstcr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb4lrstcr {{ hdprstc: {=bool:?}, lpuart1rstc: {=bool:?}, spi6rstc: {=bool:?}, i2c4rstc: {=bool:?}, lptim2rstc: {=bool:?}, lptim3rstc: {=bool:?}, lptim4rstc: {=bool:?}, lptim5rstc: {=bool:?}, vrefbufrstc: {=bool:?}, rtcrstc: {=bool:?}, r2gretrstc: {=bool:?}, r2gnpurstc: {=bool:?}, serfrstc: {=bool:?} }}" , self . hdprstc () , self . lpuart1rstc () , self . spi6rstc () , self . i2c4rstc () , self . lptim2rstc () , self . lptim3rstc () , self . lptim4rstc () , self . lptim5rstc () , self . vrefbufrstc () , self . rtcrstc () , self . r2gretrstc () , self . r2gnpurstc () , self . serfrstc ())
        }
    }
    #[doc = "RCC APB4L reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4lrstr(pub u32);
    impl Apb4lrstr {
        #[doc = "HDP reset."]
        #[inline(always)]
        pub const fn hdprst(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "HDP reset."]
        #[inline(always)]
        pub fn set_hdprst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "LPUART1 reset."]
        #[inline(always)]
        pub const fn lpuart1rst(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "LPUART1 reset."]
        #[inline(always)]
        pub fn set_lpuart1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "SPI6 reset."]
        #[inline(always)]
        pub const fn spi6rst(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "SPI6 reset."]
        #[inline(always)]
        pub fn set_spi6rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "I2C4 reset."]
        #[inline(always)]
        pub const fn i2c4rst(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "I2C4 reset."]
        #[inline(always)]
        pub fn set_i2c4rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "LPTIM2 reset."]
        #[inline(always)]
        pub const fn lptim2rst(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM2 reset."]
        #[inline(always)]
        pub fn set_lptim2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "LPTIM3 reset."]
        #[inline(always)]
        pub const fn lptim3rst(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM3 reset."]
        #[inline(always)]
        pub fn set_lptim3rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "LPTIM4 reset."]
        #[inline(always)]
        pub const fn lptim4rst(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM4 reset."]
        #[inline(always)]
        pub fn set_lptim4rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "LPTIM5 reset."]
        #[inline(always)]
        pub const fn lptim5rst(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM5 reset."]
        #[inline(always)]
        pub fn set_lptim5rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "VREFBUF reset."]
        #[inline(always)]
        pub const fn vrefbufrst(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "VREFBUF reset."]
        #[inline(always)]
        pub fn set_vrefbufrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "RTC reset."]
        #[inline(always)]
        pub const fn rtcrst(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "RTC reset."]
        #[inline(always)]
        pub fn set_rtcrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "R2GRET reset."]
        #[inline(always)]
        pub const fn r2gretrst(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "R2GRET reset."]
        #[inline(always)]
        pub fn set_r2gretrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "R2GNPU reset."]
        #[inline(always)]
        pub const fn r2gnpurst(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "R2GNPU reset."]
        #[inline(always)]
        pub fn set_r2gnpurst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "SERF reset."]
        #[inline(always)]
        pub const fn serfrst(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "SERF reset."]
        #[inline(always)]
        pub fn set_serfrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb4lrstr {
        #[inline(always)]
        fn default() -> Apb4lrstr {
            Apb4lrstr(0)
        }
    }
    impl core::fmt::Debug for Apb4lrstr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4lrstr")
                .field("hdprst", &self.hdprst())
                .field("lpuart1rst", &self.lpuart1rst())
                .field("spi6rst", &self.spi6rst())
                .field("i2c4rst", &self.i2c4rst())
                .field("lptim2rst", &self.lptim2rst())
                .field("lptim3rst", &self.lptim3rst())
                .field("lptim4rst", &self.lptim4rst())
                .field("lptim5rst", &self.lptim5rst())
                .field("vrefbufrst", &self.vrefbufrst())
                .field("rtcrst", &self.rtcrst())
                .field("r2gretrst", &self.r2gretrst())
                .field("r2gnpurst", &self.r2gnpurst())
                .field("serfrst", &self.serfrst())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4lrstr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb4lrstr {{ hdprst: {=bool:?}, lpuart1rst: {=bool:?}, spi6rst: {=bool:?}, i2c4rst: {=bool:?}, lptim2rst: {=bool:?}, lptim3rst: {=bool:?}, lptim4rst: {=bool:?}, lptim5rst: {=bool:?}, vrefbufrst: {=bool:?}, rtcrst: {=bool:?}, r2gretrst: {=bool:?}, r2gnpurst: {=bool:?}, serfrst: {=bool:?} }}" , self . hdprst () , self . lpuart1rst () , self . spi6rst () , self . i2c4rst () , self . lptim2rst () , self . lptim3rst () , self . lptim4rst () , self . lptim5rst () , self . vrefbufrst () , self . rtcrst () , self . r2gretrst () , self . r2gnpurst () , self . serfrst ())
        }
    }
    #[doc = "RCC APB4L reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb4lrstsr(pub u32);
    impl Apb4lrstsr {
        #[doc = "HDP reset."]
        #[inline(always)]
        pub const fn hdprsts(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "HDP reset."]
        #[inline(always)]
        pub fn set_hdprsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "LPUART1 reset."]
        #[inline(always)]
        pub const fn lpuart1rsts(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "LPUART1 reset."]
        #[inline(always)]
        pub fn set_lpuart1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "SPI6 reset."]
        #[inline(always)]
        pub const fn spi6rsts(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "SPI6 reset."]
        #[inline(always)]
        pub fn set_spi6rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "I2C4 reset."]
        #[inline(always)]
        pub const fn i2c4rsts(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "I2C4 reset."]
        #[inline(always)]
        pub fn set_i2c4rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "LPTIM2 reset."]
        #[inline(always)]
        pub const fn lptim2rsts(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM2 reset."]
        #[inline(always)]
        pub fn set_lptim2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "LPTIM3 reset."]
        #[inline(always)]
        pub const fn lptim3rsts(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM3 reset."]
        #[inline(always)]
        pub fn set_lptim3rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "LPTIM4 reset."]
        #[inline(always)]
        pub const fn lptim4rsts(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM4 reset."]
        #[inline(always)]
        pub fn set_lptim4rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "LPTIM5 reset."]
        #[inline(always)]
        pub const fn lptim5rsts(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "LPTIM5 reset."]
        #[inline(always)]
        pub fn set_lptim5rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "VREFBUF reset."]
        #[inline(always)]
        pub const fn vrefbufrsts(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "VREFBUF reset."]
        #[inline(always)]
        pub fn set_vrefbufrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "RTC reset."]
        #[inline(always)]
        pub const fn rtcrsts(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "RTC reset."]
        #[inline(always)]
        pub fn set_rtcrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "R2GRET reset."]
        #[inline(always)]
        pub const fn r2gretrsts(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "R2GRET reset."]
        #[inline(always)]
        pub fn set_r2gretrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "R2GNPU reset."]
        #[inline(always)]
        pub const fn r2gnpursts(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "R2GNPU reset."]
        #[inline(always)]
        pub fn set_r2gnpursts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "SERF reset."]
        #[inline(always)]
        pub const fn serfrsts(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "SERF reset."]
        #[inline(always)]
        pub fn set_serfrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Apb4lrstsr {
        #[inline(always)]
        fn default() -> Apb4lrstsr {
            Apb4lrstsr(0)
        }
    }
    impl core::fmt::Debug for Apb4lrstsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb4lrstsr")
                .field("hdprsts", &self.hdprsts())
                .field("lpuart1rsts", &self.lpuart1rsts())
                .field("spi6rsts", &self.spi6rsts())
                .field("i2c4rsts", &self.i2c4rsts())
                .field("lptim2rsts", &self.lptim2rsts())
                .field("lptim3rsts", &self.lptim3rsts())
                .field("lptim4rsts", &self.lptim4rsts())
                .field("lptim5rsts", &self.lptim5rsts())
                .field("vrefbufrsts", &self.vrefbufrsts())
                .field("rtcrsts", &self.rtcrsts())
                .field("r2gretrsts", &self.r2gretrsts())
                .field("r2gnpursts", &self.r2gnpursts())
                .field("serfrsts", &self.serfrsts())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb4lrstsr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb4lrstsr {{ hdprsts: {=bool:?}, lpuart1rsts: {=bool:?}, spi6rsts: {=bool:?}, i2c4rsts: {=bool:?}, lptim2rsts: {=bool:?}, lptim3rsts: {=bool:?}, lptim4rsts: {=bool:?}, lptim5rsts: {=bool:?}, vrefbufrsts: {=bool:?}, rtcrsts: {=bool:?}, r2gretrsts: {=bool:?}, r2gnpursts: {=bool:?}, serfrsts: {=bool:?} }}" , self . hdprsts () , self . lpuart1rsts () , self . spi6rsts () , self . i2c4rsts () , self . lptim2rsts () , self . lptim3rsts () , self . lptim4rsts () , self . lptim5rsts () , self . vrefbufrsts () , self . rtcrsts () , self . r2gretrsts () , self . r2gnpursts () , self . serfrsts ())
        }
    }
    #[doc = "RCC APB5 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb5encr(pub u32);
    impl Apb5encr {
        #[doc = "LTDC enable."]
        #[inline(always)]
        pub const fn ltdcenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "LTDC enable."]
        #[inline(always)]
        pub fn set_ltdcenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DCMIPP enable."]
        #[inline(always)]
        pub const fn dcmippenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DCMIPP enable."]
        #[inline(always)]
        pub fn set_dcmippenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GFXTIM enable."]
        #[inline(always)]
        pub const fn gfxtimenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GFXTIM enable."]
        #[inline(always)]
        pub fn set_gfxtimenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "VENC enable."]
        #[inline(always)]
        pub const fn vencenc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "VENC enable."]
        #[inline(always)]
        pub fn set_vencenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "CSI enable."]
        #[inline(always)]
        pub const fn csienc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "CSI enable."]
        #[inline(always)]
        pub fn set_csienc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Apb5encr {
        #[inline(always)]
        fn default() -> Apb5encr {
            Apb5encr(0)
        }
    }
    impl core::fmt::Debug for Apb5encr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb5encr")
                .field("ltdcenc", &self.ltdcenc())
                .field("dcmippenc", &self.dcmippenc())
                .field("gfxtimenc", &self.gfxtimenc())
                .field("vencenc", &self.vencenc())
                .field("csienc", &self.csienc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb5encr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb5encr {{ ltdcenc: {=bool:?}, dcmippenc: {=bool:?}, gfxtimenc: {=bool:?}, vencenc: {=bool:?}, csienc: {=bool:?} }}" , self . ltdcenc () , self . dcmippenc () , self . gfxtimenc () , self . vencenc () , self . csienc ())
        }
    }
    #[doc = "RCC APB5 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb5enr(pub u32);
    impl Apb5enr {
        #[doc = "LTDC enable."]
        #[inline(always)]
        pub const fn ltdcen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "LTDC enable."]
        #[inline(always)]
        pub fn set_ltdcen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DCMIPP enable."]
        #[inline(always)]
        pub const fn dcmippen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DCMIPP enable."]
        #[inline(always)]
        pub fn set_dcmippen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GFXTIM enable."]
        #[inline(always)]
        pub const fn gfxtimen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GFXTIM enable."]
        #[inline(always)]
        pub fn set_gfxtimen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "VENC enable."]
        #[inline(always)]
        pub const fn vencen(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "VENC enable."]
        #[inline(always)]
        pub fn set_vencen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "CSI enable."]
        #[inline(always)]
        pub const fn csien(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "CSI enable."]
        #[inline(always)]
        pub fn set_csien(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Apb5enr {
        #[inline(always)]
        fn default() -> Apb5enr {
            Apb5enr(0)
        }
    }
    impl core::fmt::Debug for Apb5enr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb5enr")
                .field("ltdcen", &self.ltdcen())
                .field("dcmippen", &self.dcmippen())
                .field("gfxtimen", &self.gfxtimen())
                .field("vencen", &self.vencen())
                .field("csien", &self.csien())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb5enr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb5enr {{ ltdcen: {=bool:?}, dcmippen: {=bool:?}, gfxtimen: {=bool:?}, vencen: {=bool:?}, csien: {=bool:?} }}" , self . ltdcen () , self . dcmippen () , self . gfxtimen () , self . vencen () , self . csien ())
        }
    }
    #[doc = "RCC APB5 enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb5ensr(pub u32);
    impl Apb5ensr {
        #[doc = "LTDC enable."]
        #[inline(always)]
        pub const fn ltdcens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "LTDC enable."]
        #[inline(always)]
        pub fn set_ltdcens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DCMIPP enable."]
        #[inline(always)]
        pub const fn dcmippens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DCMIPP enable."]
        #[inline(always)]
        pub fn set_dcmippens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GFXTIM enable."]
        #[inline(always)]
        pub const fn gfxtimens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GFXTIM enable."]
        #[inline(always)]
        pub fn set_gfxtimens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "VENC enable."]
        #[inline(always)]
        pub const fn vencens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "VENC enable."]
        #[inline(always)]
        pub fn set_vencens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "CSI enable."]
        #[inline(always)]
        pub const fn csiens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "CSI enable."]
        #[inline(always)]
        pub fn set_csiens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Apb5ensr {
        #[inline(always)]
        fn default() -> Apb5ensr {
            Apb5ensr(0)
        }
    }
    impl core::fmt::Debug for Apb5ensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb5ensr")
                .field("ltdcens", &self.ltdcens())
                .field("dcmippens", &self.dcmippens())
                .field("gfxtimens", &self.gfxtimens())
                .field("vencens", &self.vencens())
                .field("csiens", &self.csiens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb5ensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb5ensr {{ ltdcens: {=bool:?}, dcmippens: {=bool:?}, gfxtimens: {=bool:?}, vencens: {=bool:?}, csiens: {=bool:?} }}" , self . ltdcens () , self . dcmippens () , self . gfxtimens () , self . vencens () , self . csiens ())
        }
    }
    #[doc = "RCC APB5 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb5lpencr(pub u32);
    impl Apb5lpencr {
        #[doc = "LTDC sleep enable."]
        #[inline(always)]
        pub const fn ltdclpenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "LTDC sleep enable."]
        #[inline(always)]
        pub fn set_ltdclpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DCMIPP sleep enable."]
        #[inline(always)]
        pub const fn dcmipplpenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DCMIPP sleep enable."]
        #[inline(always)]
        pub fn set_dcmipplpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GFXTIM sleep enable."]
        #[inline(always)]
        pub const fn gfxtimlpenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GFXTIM sleep enable."]
        #[inline(always)]
        pub fn set_gfxtimlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "VENC sleep enable."]
        #[inline(always)]
        pub const fn venclpenc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "VENC sleep enable."]
        #[inline(always)]
        pub fn set_venclpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "CSI sleep enable."]
        #[inline(always)]
        pub const fn csilpenc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "CSI sleep enable."]
        #[inline(always)]
        pub fn set_csilpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Apb5lpencr {
        #[inline(always)]
        fn default() -> Apb5lpencr {
            Apb5lpencr(0)
        }
    }
    impl core::fmt::Debug for Apb5lpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb5lpencr")
                .field("ltdclpenc", &self.ltdclpenc())
                .field("dcmipplpenc", &self.dcmipplpenc())
                .field("gfxtimlpenc", &self.gfxtimlpenc())
                .field("venclpenc", &self.venclpenc())
                .field("csilpenc", &self.csilpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb5lpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb5lpencr {{ ltdclpenc: {=bool:?}, dcmipplpenc: {=bool:?}, gfxtimlpenc: {=bool:?}, venclpenc: {=bool:?}, csilpenc: {=bool:?} }}" , self . ltdclpenc () , self . dcmipplpenc () , self . gfxtimlpenc () , self . venclpenc () , self . csilpenc ())
        }
    }
    #[doc = "RCC APB5 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb5lpenr(pub u32);
    impl Apb5lpenr {
        #[doc = "LTDC sleep enable."]
        #[inline(always)]
        pub const fn ltdclpen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "LTDC sleep enable."]
        #[inline(always)]
        pub fn set_ltdclpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DCMIPP sleep enable."]
        #[inline(always)]
        pub const fn dcmipplpen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DCMIPP sleep enable."]
        #[inline(always)]
        pub fn set_dcmipplpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GFXTIM sleep enable."]
        #[inline(always)]
        pub const fn gfxtimlpen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GFXTIM sleep enable."]
        #[inline(always)]
        pub fn set_gfxtimlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "VENC sleep enable."]
        #[inline(always)]
        pub const fn venclpen(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "VENC sleep enable."]
        #[inline(always)]
        pub fn set_venclpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "CSI sleep enable."]
        #[inline(always)]
        pub const fn csilpen(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "CSI sleep enable."]
        #[inline(always)]
        pub fn set_csilpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Apb5lpenr {
        #[inline(always)]
        fn default() -> Apb5lpenr {
            Apb5lpenr(0)
        }
    }
    impl core::fmt::Debug for Apb5lpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb5lpenr")
                .field("ltdclpen", &self.ltdclpen())
                .field("dcmipplpen", &self.dcmipplpen())
                .field("gfxtimlpen", &self.gfxtimlpen())
                .field("venclpen", &self.venclpen())
                .field("csilpen", &self.csilpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb5lpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb5lpenr {{ ltdclpen: {=bool:?}, dcmipplpen: {=bool:?}, gfxtimlpen: {=bool:?}, venclpen: {=bool:?}, csilpen: {=bool:?} }}" , self . ltdclpen () , self . dcmipplpen () , self . gfxtimlpen () , self . venclpen () , self . csilpen ())
        }
    }
    #[doc = "RCC APB5 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb5lpensr(pub u32);
    impl Apb5lpensr {
        #[doc = "LTDC sleep enable."]
        #[inline(always)]
        pub const fn ltdclpens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "LTDC sleep enable."]
        #[inline(always)]
        pub fn set_ltdclpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DCMIPP sleep enable."]
        #[inline(always)]
        pub const fn dcmipplpens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DCMIPP sleep enable."]
        #[inline(always)]
        pub fn set_dcmipplpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GFXTIM sleep enable."]
        #[inline(always)]
        pub const fn gfxtimlpens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GFXTIM sleep enable."]
        #[inline(always)]
        pub fn set_gfxtimlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "VENC sleep enable."]
        #[inline(always)]
        pub const fn venclpens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "VENC sleep enable."]
        #[inline(always)]
        pub fn set_venclpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "CSI sleep enable."]
        #[inline(always)]
        pub const fn csilpens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "CSI sleep enable."]
        #[inline(always)]
        pub fn set_csilpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Apb5lpensr {
        #[inline(always)]
        fn default() -> Apb5lpensr {
            Apb5lpensr(0)
        }
    }
    impl core::fmt::Debug for Apb5lpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb5lpensr")
                .field("ltdclpens", &self.ltdclpens())
                .field("dcmipplpens", &self.dcmipplpens())
                .field("gfxtimlpens", &self.gfxtimlpens())
                .field("venclpens", &self.venclpens())
                .field("csilpens", &self.csilpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb5lpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb5lpensr {{ ltdclpens: {=bool:?}, dcmipplpens: {=bool:?}, gfxtimlpens: {=bool:?}, venclpens: {=bool:?}, csilpens: {=bool:?} }}" , self . ltdclpens () , self . dcmipplpens () , self . gfxtimlpens () , self . venclpens () , self . csilpens ())
        }
    }
    #[doc = "RCC APB5 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb5rstcr(pub u32);
    impl Apb5rstcr {
        #[doc = "LTDC reset."]
        #[inline(always)]
        pub const fn ltdcrstc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "LTDC reset."]
        #[inline(always)]
        pub fn set_ltdcrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DCMIPP reset."]
        #[inline(always)]
        pub const fn dcmipprstc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DCMIPP reset."]
        #[inline(always)]
        pub fn set_dcmipprstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GFXTIM reset."]
        #[inline(always)]
        pub const fn gfxtimrstc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GFXTIM reset."]
        #[inline(always)]
        pub fn set_gfxtimrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "VENC reset."]
        #[inline(always)]
        pub const fn vencrstc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "VENC reset."]
        #[inline(always)]
        pub fn set_vencrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "CSI reset."]
        #[inline(always)]
        pub const fn csirstc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "CSI reset."]
        #[inline(always)]
        pub fn set_csirstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Apb5rstcr {
        #[inline(always)]
        fn default() -> Apb5rstcr {
            Apb5rstcr(0)
        }
    }
    impl core::fmt::Debug for Apb5rstcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb5rstcr")
                .field("ltdcrstc", &self.ltdcrstc())
                .field("dcmipprstc", &self.dcmipprstc())
                .field("gfxtimrstc", &self.gfxtimrstc())
                .field("vencrstc", &self.vencrstc())
                .field("csirstc", &self.csirstc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb5rstcr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb5rstcr {{ ltdcrstc: {=bool:?}, dcmipprstc: {=bool:?}, gfxtimrstc: {=bool:?}, vencrstc: {=bool:?}, csirstc: {=bool:?} }}" , self . ltdcrstc () , self . dcmipprstc () , self . gfxtimrstc () , self . vencrstc () , self . csirstc ())
        }
    }
    #[doc = "RCC APB5 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb5rstr(pub u32);
    impl Apb5rstr {
        #[doc = "LTDC reset."]
        #[inline(always)]
        pub const fn ltdcrst(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "LTDC reset."]
        #[inline(always)]
        pub fn set_ltdcrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DCMIPP reset."]
        #[inline(always)]
        pub const fn dcmipprst(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DCMIPP reset."]
        #[inline(always)]
        pub fn set_dcmipprst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GFXTIM reset."]
        #[inline(always)]
        pub const fn gfxtimrst(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GFXTIM reset."]
        #[inline(always)]
        pub fn set_gfxtimrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "VENC reset."]
        #[inline(always)]
        pub const fn vencrst(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "VENC reset."]
        #[inline(always)]
        pub fn set_vencrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "CSI reset."]
        #[inline(always)]
        pub const fn csirst(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "CSI reset."]
        #[inline(always)]
        pub fn set_csirst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Apb5rstr {
        #[inline(always)]
        fn default() -> Apb5rstr {
            Apb5rstr(0)
        }
    }
    impl core::fmt::Debug for Apb5rstr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb5rstr")
                .field("ltdcrst", &self.ltdcrst())
                .field("dcmipprst", &self.dcmipprst())
                .field("gfxtimrst", &self.gfxtimrst())
                .field("vencrst", &self.vencrst())
                .field("csirst", &self.csirst())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb5rstr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb5rstr {{ ltdcrst: {=bool:?}, dcmipprst: {=bool:?}, gfxtimrst: {=bool:?}, vencrst: {=bool:?}, csirst: {=bool:?} }}" , self . ltdcrst () , self . dcmipprst () , self . gfxtimrst () , self . vencrst () , self . csirst ())
        }
    }
    #[doc = "RCC APB5 reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Apb5rstsr(pub u32);
    impl Apb5rstsr {
        #[doc = "LTDC reset."]
        #[inline(always)]
        pub const fn ltdcrsts(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "LTDC reset."]
        #[inline(always)]
        pub fn set_ltdcrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "DCMIPP reset."]
        #[inline(always)]
        pub const fn dcmipprsts(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "DCMIPP reset."]
        #[inline(always)]
        pub fn set_dcmipprsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "GFXTIM reset."]
        #[inline(always)]
        pub const fn gfxtimrsts(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "GFXTIM reset."]
        #[inline(always)]
        pub fn set_gfxtimrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "VENC reset."]
        #[inline(always)]
        pub const fn vencrsts(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "VENC reset."]
        #[inline(always)]
        pub fn set_vencrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "CSI reset."]
        #[inline(always)]
        pub const fn csirsts(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "CSI reset."]
        #[inline(always)]
        pub fn set_csirsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Apb5rstsr {
        #[inline(always)]
        fn default() -> Apb5rstsr {
            Apb5rstsr(0)
        }
    }
    impl core::fmt::Debug for Apb5rstsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Apb5rstsr")
                .field("ltdcrsts", &self.ltdcrsts())
                .field("dcmipprsts", &self.dcmipprsts())
                .field("gfxtimrsts", &self.gfxtimrsts())
                .field("vencrsts", &self.vencrsts())
                .field("csirsts", &self.csirsts())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Apb5rstsr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Apb5rstsr {{ ltdcrsts: {=bool:?}, dcmipprsts: {=bool:?}, gfxtimrsts: {=bool:?}, vencrsts: {=bool:?}, csirsts: {=bool:?} }}" , self . ltdcrsts () , self . dcmipprsts () , self . gfxtimrsts () , self . vencrsts () , self . csirsts ())
        }
    }
    #[doc = "RCC backup domain protection register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Bdcr(pub u32);
    impl Bdcr {
        #[doc = "VSW domain software reset."]
        #[inline(always)]
        pub const fn vswrst(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "VSW domain software reset."]
        #[inline(always)]
        pub fn set_vswrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Bdcr {
        #[inline(always)]
        fn default() -> Bdcr {
            Bdcr(0)
        }
    }
    impl core::fmt::Debug for Bdcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Bdcr").field("vswrst", &self.vswrst()).finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Bdcr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(f, "Bdcr {{ vswrst: {=bool:?} }}", self.vswrst())
        }
    }
    #[doc = "RCC bus enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Busencr(pub u32);
    impl Busencr {
        #[doc = "ACLKN enable."]
        #[inline(always)]
        pub const fn aclknenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKN enable."]
        #[inline(always)]
        pub fn set_aclknenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "ACLKNC enable."]
        #[inline(always)]
        pub const fn aclkncenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKNC enable."]
        #[inline(always)]
        pub fn set_aclkncenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AHBM enable."]
        #[inline(always)]
        pub const fn ahbmenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AHBM enable."]
        #[inline(always)]
        pub fn set_ahbmenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AHB1 enable."]
        #[inline(always)]
        pub const fn ahb1enc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AHB1 enable."]
        #[inline(always)]
        pub fn set_ahb1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHB2 enable."]
        #[inline(always)]
        pub const fn ahb2enc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHB2 enable."]
        #[inline(always)]
        pub fn set_ahb2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHB3 enable."]
        #[inline(always)]
        pub const fn ahb3enc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHB3 enable."]
        #[inline(always)]
        pub fn set_ahb3enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "AHB4 enable."]
        #[inline(always)]
        pub const fn ahb4enc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "AHB4 enable."]
        #[inline(always)]
        pub fn set_ahb4enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AHB5 enable."]
        #[inline(always)]
        pub const fn ahb5enc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AHB5 enable."]
        #[inline(always)]
        pub fn set_ahb5enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "APB1 enable."]
        #[inline(always)]
        pub const fn apb1enc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "APB1 enable."]
        #[inline(always)]
        pub fn set_apb1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "APB2 enable."]
        #[inline(always)]
        pub const fn apb2enc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "APB2 enable."]
        #[inline(always)]
        pub fn set_apb2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "APB3 enable."]
        #[inline(always)]
        pub const fn apb3enc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "APB3 enable."]
        #[inline(always)]
        pub fn set_apb3enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "APB4 enable."]
        #[inline(always)]
        pub const fn apb4enc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "APB4 enable."]
        #[inline(always)]
        pub fn set_apb4enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "APB5 enable."]
        #[inline(always)]
        pub const fn apb5enc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "APB5 enable."]
        #[inline(always)]
        pub fn set_apb5enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Busencr {
        #[inline(always)]
        fn default() -> Busencr {
            Busencr(0)
        }
    }
    impl core::fmt::Debug for Busencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Busencr")
                .field("aclknenc", &self.aclknenc())
                .field("aclkncenc", &self.aclkncenc())
                .field("ahbmenc", &self.ahbmenc())
                .field("ahb1enc", &self.ahb1enc())
                .field("ahb2enc", &self.ahb2enc())
                .field("ahb3enc", &self.ahb3enc())
                .field("ahb4enc", &self.ahb4enc())
                .field("ahb5enc", &self.ahb5enc())
                .field("apb1enc", &self.apb1enc())
                .field("apb2enc", &self.apb2enc())
                .field("apb3enc", &self.apb3enc())
                .field("apb4enc", &self.apb4enc())
                .field("apb5enc", &self.apb5enc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Busencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Busencr {{ aclknenc: {=bool:?}, aclkncenc: {=bool:?}, ahbmenc: {=bool:?}, ahb1enc: {=bool:?}, ahb2enc: {=bool:?}, ahb3enc: {=bool:?}, ahb4enc: {=bool:?}, ahb5enc: {=bool:?}, apb1enc: {=bool:?}, apb2enc: {=bool:?}, apb3enc: {=bool:?}, apb4enc: {=bool:?}, apb5enc: {=bool:?} }}" , self . aclknenc () , self . aclkncenc () , self . ahbmenc () , self . ahb1enc () , self . ahb2enc () , self . ahb3enc () , self . ahb4enc () , self . ahb5enc () , self . apb1enc () , self . apb2enc () , self . apb3enc () , self . apb4enc () , self . apb5enc ())
        }
    }
    #[doc = "RCC SoC buses enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Busenr(pub u32);
    impl Busenr {
        #[doc = "ACLKN enable."]
        #[inline(always)]
        pub const fn aclknen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKN enable."]
        #[inline(always)]
        pub fn set_aclknen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "ACLKNC enable."]
        #[inline(always)]
        pub const fn aclkncen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKNC enable."]
        #[inline(always)]
        pub fn set_aclkncen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AHBM enable."]
        #[inline(always)]
        pub const fn ahbmen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AHBM enable."]
        #[inline(always)]
        pub fn set_ahbmen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AHB1 enable."]
        #[inline(always)]
        pub const fn ahb1en(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AHB1 enable."]
        #[inline(always)]
        pub fn set_ahb1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHB2 enable."]
        #[inline(always)]
        pub const fn ahb2en(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHB2 enable."]
        #[inline(always)]
        pub fn set_ahb2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHB3 enable."]
        #[inline(always)]
        pub const fn ahb3en(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHB3 enable."]
        #[inline(always)]
        pub fn set_ahb3en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "AHB4 enable."]
        #[inline(always)]
        pub const fn ahb4en(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "AHB4 enable."]
        #[inline(always)]
        pub fn set_ahb4en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AHB5 enable."]
        #[inline(always)]
        pub const fn ahb5en(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AHB5 enable."]
        #[inline(always)]
        pub fn set_ahb5en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "APB1 enable."]
        #[inline(always)]
        pub const fn apb1en(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "APB1 enable."]
        #[inline(always)]
        pub fn set_apb1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "APB2 enable."]
        #[inline(always)]
        pub const fn apb2en(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "APB2 enable."]
        #[inline(always)]
        pub fn set_apb2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "APB3 enable."]
        #[inline(always)]
        pub const fn apb3en(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "APB3 enable."]
        #[inline(always)]
        pub fn set_apb3en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "APB4 enable."]
        #[inline(always)]
        pub const fn apb4en(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "APB4 enable."]
        #[inline(always)]
        pub fn set_apb4en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "APB5 enable."]
        #[inline(always)]
        pub const fn apb5en(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "APB5 enable."]
        #[inline(always)]
        pub fn set_apb5en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Busenr {
        #[inline(always)]
        fn default() -> Busenr {
            Busenr(0)
        }
    }
    impl core::fmt::Debug for Busenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Busenr")
                .field("aclknen", &self.aclknen())
                .field("aclkncen", &self.aclkncen())
                .field("ahbmen", &self.ahbmen())
                .field("ahb1en", &self.ahb1en())
                .field("ahb2en", &self.ahb2en())
                .field("ahb3en", &self.ahb3en())
                .field("ahb4en", &self.ahb4en())
                .field("ahb5en", &self.ahb5en())
                .field("apb1en", &self.apb1en())
                .field("apb2en", &self.apb2en())
                .field("apb3en", &self.apb3en())
                .field("apb4en", &self.apb4en())
                .field("apb5en", &self.apb5en())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Busenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Busenr {{ aclknen: {=bool:?}, aclkncen: {=bool:?}, ahbmen: {=bool:?}, ahb1en: {=bool:?}, ahb2en: {=bool:?}, ahb3en: {=bool:?}, ahb4en: {=bool:?}, ahb5en: {=bool:?}, apb1en: {=bool:?}, apb2en: {=bool:?}, apb3en: {=bool:?}, apb4en: {=bool:?}, apb5en: {=bool:?} }}" , self . aclknen () , self . aclkncen () , self . ahbmen () , self . ahb1en () , self . ahb2en () , self . ahb3en () , self . ahb4en () , self . ahb5en () , self . apb1en () , self . apb2en () , self . apb3en () , self . apb4en () , self . apb5en ())
        }
    }
    #[doc = "RCC bus enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Busensr(pub u32);
    impl Busensr {
        #[doc = "ACLKN enable."]
        #[inline(always)]
        pub const fn aclknens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKN enable."]
        #[inline(always)]
        pub fn set_aclknens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "ACLKNC enable."]
        #[inline(always)]
        pub const fn aclkncens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKNC enable."]
        #[inline(always)]
        pub fn set_aclkncens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AHBM enable."]
        #[inline(always)]
        pub const fn ahbmens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AHBM enable."]
        #[inline(always)]
        pub fn set_ahbmens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AHB1 enable."]
        #[inline(always)]
        pub const fn ahb1ens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AHB1 enable."]
        #[inline(always)]
        pub fn set_ahb1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHB2 enable."]
        #[inline(always)]
        pub const fn ahb2ens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHB2 enable."]
        #[inline(always)]
        pub fn set_ahb2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHB3 enable."]
        #[inline(always)]
        pub const fn ahb3ens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHB3 enable."]
        #[inline(always)]
        pub fn set_ahb3ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "AHB4 enable."]
        #[inline(always)]
        pub const fn ahb4ens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "AHB4 enable."]
        #[inline(always)]
        pub fn set_ahb4ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AHB5 enable."]
        #[inline(always)]
        pub const fn ahb5ens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AHB5 enable."]
        #[inline(always)]
        pub fn set_ahb5ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "APB1 enable."]
        #[inline(always)]
        pub const fn apb1ens(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "APB1 enable."]
        #[inline(always)]
        pub fn set_apb1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "APB2 enable."]
        #[inline(always)]
        pub const fn apb2ens(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "APB2 enable."]
        #[inline(always)]
        pub fn set_apb2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "APB3 enable."]
        #[inline(always)]
        pub const fn apb3ens(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "APB3 enable."]
        #[inline(always)]
        pub fn set_apb3ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "APB4 enable."]
        #[inline(always)]
        pub const fn apb4ens(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "APB4 enable."]
        #[inline(always)]
        pub fn set_apb4ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "APB5 enable."]
        #[inline(always)]
        pub const fn apb5ens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "APB5 enable."]
        #[inline(always)]
        pub fn set_apb5ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Busensr {
        #[inline(always)]
        fn default() -> Busensr {
            Busensr(0)
        }
    }
    impl core::fmt::Debug for Busensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Busensr")
                .field("aclknens", &self.aclknens())
                .field("aclkncens", &self.aclkncens())
                .field("ahbmens", &self.ahbmens())
                .field("ahb1ens", &self.ahb1ens())
                .field("ahb2ens", &self.ahb2ens())
                .field("ahb3ens", &self.ahb3ens())
                .field("ahb4ens", &self.ahb4ens())
                .field("ahb5ens", &self.ahb5ens())
                .field("apb1ens", &self.apb1ens())
                .field("apb2ens", &self.apb2ens())
                .field("apb3ens", &self.apb3ens())
                .field("apb4ens", &self.apb4ens())
                .field("apb5ens", &self.apb5ens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Busensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Busensr {{ aclknens: {=bool:?}, aclkncens: {=bool:?}, ahbmens: {=bool:?}, ahb1ens: {=bool:?}, ahb2ens: {=bool:?}, ahb3ens: {=bool:?}, ahb4ens: {=bool:?}, ahb5ens: {=bool:?}, apb1ens: {=bool:?}, apb2ens: {=bool:?}, apb3ens: {=bool:?}, apb4ens: {=bool:?}, apb5ens: {=bool:?} }}" , self . aclknens () , self . aclkncens () , self . ahbmens () , self . ahb1ens () , self . ahb2ens () , self . ahb3ens () , self . ahb4ens () , self . ahb5ens () , self . apb1ens () , self . apb2ens () , self . apb3ens () , self . apb4ens () , self . apb5ens ())
        }
    }
    #[doc = "RCC bus Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Buslpencr(pub u32);
    impl Buslpencr {
        #[doc = "ACLKN sleep enable."]
        #[inline(always)]
        pub const fn aclknlpenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKN sleep enable."]
        #[inline(always)]
        pub fn set_aclknlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "ACLKNC sleep enable."]
        #[inline(always)]
        pub const fn aclknclpenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKNC sleep enable."]
        #[inline(always)]
        pub fn set_aclknclpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AHBM sleep enable."]
        #[inline(always)]
        pub const fn ahbmlpenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AHBM sleep enable."]
        #[inline(always)]
        pub fn set_ahbmlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AHB1 sleep enable."]
        #[inline(always)]
        pub const fn ahb1lpenc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AHB1 sleep enable."]
        #[inline(always)]
        pub fn set_ahb1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHB2 sleep enable."]
        #[inline(always)]
        pub const fn ahb2lpenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHB2 sleep enable."]
        #[inline(always)]
        pub fn set_ahb2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHB3 sleep enable."]
        #[inline(always)]
        pub const fn ahb3lpenc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHB3 sleep enable."]
        #[inline(always)]
        pub fn set_ahb3lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "AHB4 sleep enable."]
        #[inline(always)]
        pub const fn ahb4lpenc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "AHB4 sleep enable."]
        #[inline(always)]
        pub fn set_ahb4lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AHB5 sleep enable."]
        #[inline(always)]
        pub const fn ahb5lpenc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AHB5 sleep enable."]
        #[inline(always)]
        pub fn set_ahb5lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "APB1 sleep enable."]
        #[inline(always)]
        pub const fn apb1lpenc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "APB1 sleep enable."]
        #[inline(always)]
        pub fn set_apb1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "APB2 sleep enable."]
        #[inline(always)]
        pub const fn apb2lpenc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "APB2 sleep enable."]
        #[inline(always)]
        pub fn set_apb2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "APB3 sleep enable."]
        #[inline(always)]
        pub const fn apb3lpenc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "APB3 sleep enable."]
        #[inline(always)]
        pub fn set_apb3lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "APB4 sleep enable."]
        #[inline(always)]
        pub const fn apb4lpenc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "APB4 sleep enable."]
        #[inline(always)]
        pub fn set_apb4lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "APB5 sleep enable."]
        #[inline(always)]
        pub const fn apb5lpenc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "APB5 sleep enable."]
        #[inline(always)]
        pub fn set_apb5lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Buslpencr {
        #[inline(always)]
        fn default() -> Buslpencr {
            Buslpencr(0)
        }
    }
    impl core::fmt::Debug for Buslpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Buslpencr")
                .field("aclknlpenc", &self.aclknlpenc())
                .field("aclknclpenc", &self.aclknclpenc())
                .field("ahbmlpenc", &self.ahbmlpenc())
                .field("ahb1lpenc", &self.ahb1lpenc())
                .field("ahb2lpenc", &self.ahb2lpenc())
                .field("ahb3lpenc", &self.ahb3lpenc())
                .field("ahb4lpenc", &self.ahb4lpenc())
                .field("ahb5lpenc", &self.ahb5lpenc())
                .field("apb1lpenc", &self.apb1lpenc())
                .field("apb2lpenc", &self.apb2lpenc())
                .field("apb3lpenc", &self.apb3lpenc())
                .field("apb4lpenc", &self.apb4lpenc())
                .field("apb5lpenc", &self.apb5lpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Buslpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Buslpencr {{ aclknlpenc: {=bool:?}, aclknclpenc: {=bool:?}, ahbmlpenc: {=bool:?}, ahb1lpenc: {=bool:?}, ahb2lpenc: {=bool:?}, ahb3lpenc: {=bool:?}, ahb4lpenc: {=bool:?}, ahb5lpenc: {=bool:?}, apb1lpenc: {=bool:?}, apb2lpenc: {=bool:?}, apb3lpenc: {=bool:?}, apb4lpenc: {=bool:?}, apb5lpenc: {=bool:?} }}" , self . aclknlpenc () , self . aclknclpenc () , self . ahbmlpenc () , self . ahb1lpenc () , self . ahb2lpenc () , self . ahb3lpenc () , self . ahb4lpenc () , self . ahb5lpenc () , self . apb1lpenc () , self . apb2lpenc () , self . apb3lpenc () , self . apb4lpenc () , self . apb5lpenc ())
        }
    }
    #[doc = "RCC SoC buses Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Buslpenr(pub u32);
    impl Buslpenr {
        #[doc = "ACLKN sleep enable."]
        #[inline(always)]
        pub const fn aclknlpen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKN sleep enable."]
        #[inline(always)]
        pub fn set_aclknlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "ACLKNC sleep enable."]
        #[inline(always)]
        pub const fn aclknclpen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKNC sleep enable."]
        #[inline(always)]
        pub fn set_aclknclpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AHBM sleep enable."]
        #[inline(always)]
        pub const fn ahbmlpen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AHBM sleep enable."]
        #[inline(always)]
        pub fn set_ahbmlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AHB1 sleep enable."]
        #[inline(always)]
        pub const fn ahb1lpen(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AHB1 sleep enable."]
        #[inline(always)]
        pub fn set_ahb1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHB2 sleep enable."]
        #[inline(always)]
        pub const fn ahb2lpen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHB2 sleep enable."]
        #[inline(always)]
        pub fn set_ahb2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHB3 sleep enable."]
        #[inline(always)]
        pub const fn ahb3lpen(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHB3 sleep enable."]
        #[inline(always)]
        pub fn set_ahb3lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "AHB4 sleep enable."]
        #[inline(always)]
        pub const fn ahb4lpen(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "AHB4 sleep enable."]
        #[inline(always)]
        pub fn set_ahb4lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AHB5 sleep enable."]
        #[inline(always)]
        pub const fn ahb5lpen(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AHB5 sleep enable."]
        #[inline(always)]
        pub fn set_ahb5lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "APB1 sleep enable."]
        #[inline(always)]
        pub const fn apb1lpen(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "APB1 sleep enable."]
        #[inline(always)]
        pub fn set_apb1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "APB2 sleep enable."]
        #[inline(always)]
        pub const fn apb2lpen(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "APB2 sleep enable."]
        #[inline(always)]
        pub fn set_apb2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "APB3 sleep enable."]
        #[inline(always)]
        pub const fn apb3lpen(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "APB3 sleep enable."]
        #[inline(always)]
        pub fn set_apb3lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "APB4 sleep enable."]
        #[inline(always)]
        pub const fn apb4lpen(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "APB4 sleep enable."]
        #[inline(always)]
        pub fn set_apb4lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "APB5 sleep enable."]
        #[inline(always)]
        pub const fn apb5lpen(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "APB5 sleep enable."]
        #[inline(always)]
        pub fn set_apb5lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Buslpenr {
        #[inline(always)]
        fn default() -> Buslpenr {
            Buslpenr(0)
        }
    }
    impl core::fmt::Debug for Buslpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Buslpenr")
                .field("aclknlpen", &self.aclknlpen())
                .field("aclknclpen", &self.aclknclpen())
                .field("ahbmlpen", &self.ahbmlpen())
                .field("ahb1lpen", &self.ahb1lpen())
                .field("ahb2lpen", &self.ahb2lpen())
                .field("ahb3lpen", &self.ahb3lpen())
                .field("ahb4lpen", &self.ahb4lpen())
                .field("ahb5lpen", &self.ahb5lpen())
                .field("apb1lpen", &self.apb1lpen())
                .field("apb2lpen", &self.apb2lpen())
                .field("apb3lpen", &self.apb3lpen())
                .field("apb4lpen", &self.apb4lpen())
                .field("apb5lpen", &self.apb5lpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Buslpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Buslpenr {{ aclknlpen: {=bool:?}, aclknclpen: {=bool:?}, ahbmlpen: {=bool:?}, ahb1lpen: {=bool:?}, ahb2lpen: {=bool:?}, ahb3lpen: {=bool:?}, ahb4lpen: {=bool:?}, ahb5lpen: {=bool:?}, apb1lpen: {=bool:?}, apb2lpen: {=bool:?}, apb3lpen: {=bool:?}, apb4lpen: {=bool:?}, apb5lpen: {=bool:?} }}" , self . aclknlpen () , self . aclknclpen () , self . ahbmlpen () , self . ahb1lpen () , self . ahb2lpen () , self . ahb3lpen () , self . ahb4lpen () , self . ahb5lpen () , self . apb1lpen () , self . apb2lpen () , self . apb3lpen () , self . apb4lpen () , self . apb5lpen ())
        }
    }
    #[doc = "RCC bus Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Buslpensr(pub u32);
    impl Buslpensr {
        #[doc = "ACLKN sleep enable."]
        #[inline(always)]
        pub const fn aclknlpens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKN sleep enable."]
        #[inline(always)]
        pub fn set_aclknlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "ACLKNC sleep enable."]
        #[inline(always)]
        pub const fn aclknclpens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKNC sleep enable."]
        #[inline(always)]
        pub fn set_aclknclpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AHBM sleep enable."]
        #[inline(always)]
        pub const fn ahbmlpens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AHBM sleep enable."]
        #[inline(always)]
        pub fn set_ahbmlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AHB1 sleep enable."]
        #[inline(always)]
        pub const fn ahb1lpens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AHB1 sleep enable."]
        #[inline(always)]
        pub fn set_ahb1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHB2 sleep enable."]
        #[inline(always)]
        pub const fn ahb2lpens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHB2 sleep enable."]
        #[inline(always)]
        pub fn set_ahb2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHB3 sleep enable."]
        #[inline(always)]
        pub const fn ahb3lpens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHB3 sleep enable."]
        #[inline(always)]
        pub fn set_ahb3lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "AHB4 sleep enable."]
        #[inline(always)]
        pub const fn ahb4lpens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "AHB4 sleep enable."]
        #[inline(always)]
        pub fn set_ahb4lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AHB5 sleep enable."]
        #[inline(always)]
        pub const fn ahb5lpens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AHB5 sleep enable."]
        #[inline(always)]
        pub fn set_ahb5lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "APB1 sleep enable."]
        #[inline(always)]
        pub const fn apb1lpens(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "APB1 sleep enable."]
        #[inline(always)]
        pub fn set_apb1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "APB2 sleep enable."]
        #[inline(always)]
        pub const fn apb2lpens(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "APB2 sleep enable."]
        #[inline(always)]
        pub fn set_apb2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "APB3 sleep enable."]
        #[inline(always)]
        pub const fn apb3lpens(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "APB3 sleep enable."]
        #[inline(always)]
        pub fn set_apb3lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "APB4 sleep enable."]
        #[inline(always)]
        pub const fn apb4lpens(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "APB4 sleep enable."]
        #[inline(always)]
        pub fn set_apb4lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "APB5 sleep enable."]
        #[inline(always)]
        pub const fn apb5lpens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "APB5 sleep enable."]
        #[inline(always)]
        pub fn set_apb5lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Buslpensr {
        #[inline(always)]
        fn default() -> Buslpensr {
            Buslpensr(0)
        }
    }
    impl core::fmt::Debug for Buslpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Buslpensr")
                .field("aclknlpens", &self.aclknlpens())
                .field("aclknclpens", &self.aclknclpens())
                .field("ahbmlpens", &self.ahbmlpens())
                .field("ahb1lpens", &self.ahb1lpens())
                .field("ahb2lpens", &self.ahb2lpens())
                .field("ahb3lpens", &self.ahb3lpens())
                .field("ahb4lpens", &self.ahb4lpens())
                .field("ahb5lpens", &self.ahb5lpens())
                .field("apb1lpens", &self.apb1lpens())
                .field("apb2lpens", &self.apb2lpens())
                .field("apb3lpens", &self.apb3lpens())
                .field("apb4lpens", &self.apb4lpens())
                .field("apb5lpens", &self.apb5lpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Buslpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Buslpensr {{ aclknlpens: {=bool:?}, aclknclpens: {=bool:?}, ahbmlpens: {=bool:?}, ahb1lpens: {=bool:?}, ahb2lpens: {=bool:?}, ahb3lpens: {=bool:?}, ahb4lpens: {=bool:?}, ahb5lpens: {=bool:?}, apb1lpens: {=bool:?}, apb2lpens: {=bool:?}, apb3lpens: {=bool:?}, apb4lpens: {=bool:?}, apb5lpens: {=bool:?} }}" , self . aclknlpens () , self . aclknclpens () , self . ahbmlpens () , self . ahb1lpens () , self . ahb2lpens () , self . ahb3lpens () , self . ahb4lpens () , self . ahb5lpens () , self . apb1lpens () , self . apb2lpens () , self . apb3lpens () , self . apb4lpens () , self . apb5lpens ())
        }
    }
    #[doc = "RCC bus reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Busrstcr(pub u32);
    impl Busrstcr {
        #[doc = "ACLKN reset."]
        #[inline(always)]
        pub const fn aclknrstc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKN reset."]
        #[inline(always)]
        pub fn set_aclknrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "AHBM reset."]
        #[inline(always)]
        pub const fn ahbmrstc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AHBM reset."]
        #[inline(always)]
        pub fn set_ahbmrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AHB1 reset."]
        #[inline(always)]
        pub const fn ahb1rstc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AHB1 reset."]
        #[inline(always)]
        pub fn set_ahb1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHB2 reset."]
        #[inline(always)]
        pub const fn ahb2rstc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHB2 reset."]
        #[inline(always)]
        pub fn set_ahb2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHB3 reset."]
        #[inline(always)]
        pub const fn ahb3rstc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHB3 reset."]
        #[inline(always)]
        pub fn set_ahb3rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "AHB4 reset."]
        #[inline(always)]
        pub const fn ahb4rstc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "AHB4 reset."]
        #[inline(always)]
        pub fn set_ahb4rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AHB5 reset."]
        #[inline(always)]
        pub const fn ahb5rstc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AHB5 reset."]
        #[inline(always)]
        pub fn set_ahb5rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "APB1 reset."]
        #[inline(always)]
        pub const fn apb1rstc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "APB1 reset."]
        #[inline(always)]
        pub fn set_apb1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "APB2 reset."]
        #[inline(always)]
        pub const fn apb2rstc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "APB2 reset."]
        #[inline(always)]
        pub fn set_apb2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "APB3 reset."]
        #[inline(always)]
        pub const fn apb3rstc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "APB3 reset."]
        #[inline(always)]
        pub fn set_apb3rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "APB4 reset."]
        #[inline(always)]
        pub const fn apb4rstc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "APB4 reset."]
        #[inline(always)]
        pub fn set_apb4rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "APB5 reset."]
        #[inline(always)]
        pub const fn apb5rstc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "APB5 reset."]
        #[inline(always)]
        pub fn set_apb5rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "NOC reset."]
        #[inline(always)]
        pub const fn nocrstc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "NOC reset."]
        #[inline(always)]
        pub fn set_nocrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
    }
    impl Default for Busrstcr {
        #[inline(always)]
        fn default() -> Busrstcr {
            Busrstcr(0)
        }
    }
    impl core::fmt::Debug for Busrstcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Busrstcr")
                .field("aclknrstc", &self.aclknrstc())
                .field("ahbmrstc", &self.ahbmrstc())
                .field("ahb1rstc", &self.ahb1rstc())
                .field("ahb2rstc", &self.ahb2rstc())
                .field("ahb3rstc", &self.ahb3rstc())
                .field("ahb4rstc", &self.ahb4rstc())
                .field("ahb5rstc", &self.ahb5rstc())
                .field("apb1rstc", &self.apb1rstc())
                .field("apb2rstc", &self.apb2rstc())
                .field("apb3rstc", &self.apb3rstc())
                .field("apb4rstc", &self.apb4rstc())
                .field("apb5rstc", &self.apb5rstc())
                .field("nocrstc", &self.nocrstc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Busrstcr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Busrstcr {{ aclknrstc: {=bool:?}, ahbmrstc: {=bool:?}, ahb1rstc: {=bool:?}, ahb2rstc: {=bool:?}, ahb3rstc: {=bool:?}, ahb4rstc: {=bool:?}, ahb5rstc: {=bool:?}, apb1rstc: {=bool:?}, apb2rstc: {=bool:?}, apb3rstc: {=bool:?}, apb4rstc: {=bool:?}, apb5rstc: {=bool:?}, nocrstc: {=bool:?} }}" , self . aclknrstc () , self . ahbmrstc () , self . ahb1rstc () , self . ahb2rstc () , self . ahb3rstc () , self . ahb4rstc () , self . ahb5rstc () , self . apb1rstc () , self . apb2rstc () , self . apb3rstc () , self . apb4rstc () , self . apb5rstc () , self . nocrstc ())
        }
    }
    #[doc = "RCC SoC buses reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Busrstr(pub u32);
    impl Busrstr {
        #[doc = "ACLKN reset."]
        #[inline(always)]
        pub const fn aclknrst(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKN reset."]
        #[inline(always)]
        pub fn set_aclknrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "AHBM reset."]
        #[inline(always)]
        pub const fn ahbmrst(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AHBM reset."]
        #[inline(always)]
        pub fn set_ahbmrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AHB1 reset."]
        #[inline(always)]
        pub const fn ahb1rst(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AHB1 reset."]
        #[inline(always)]
        pub fn set_ahb1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHB2 reset."]
        #[inline(always)]
        pub const fn ahb2rst(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHB2 reset."]
        #[inline(always)]
        pub fn set_ahb2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHB3 reset."]
        #[inline(always)]
        pub const fn ahb3rst(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHB3 reset."]
        #[inline(always)]
        pub fn set_ahb3rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "AHB4 reset."]
        #[inline(always)]
        pub const fn ahb4rst(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "AHB4 reset."]
        #[inline(always)]
        pub fn set_ahb4rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AHB5 reset."]
        #[inline(always)]
        pub const fn ahb5rst(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AHB5 reset."]
        #[inline(always)]
        pub fn set_ahb5rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "APB1 reset."]
        #[inline(always)]
        pub const fn apb1rst(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "APB1 reset."]
        #[inline(always)]
        pub fn set_apb1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "APB2 reset."]
        #[inline(always)]
        pub const fn apb2rst(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "APB2 reset."]
        #[inline(always)]
        pub fn set_apb2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "APB3 reset."]
        #[inline(always)]
        pub const fn apb3rst(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "APB3 reset."]
        #[inline(always)]
        pub fn set_apb3rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "APB4 reset."]
        #[inline(always)]
        pub const fn apb4rst(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "APB4 reset."]
        #[inline(always)]
        pub fn set_apb4rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "APB5 reset."]
        #[inline(always)]
        pub const fn apb5rst(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "APB5 reset."]
        #[inline(always)]
        pub fn set_apb5rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "NOC reset."]
        #[inline(always)]
        pub const fn nocrst(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "NOC reset."]
        #[inline(always)]
        pub fn set_nocrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
    }
    impl Default for Busrstr {
        #[inline(always)]
        fn default() -> Busrstr {
            Busrstr(0)
        }
    }
    impl core::fmt::Debug for Busrstr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Busrstr")
                .field("aclknrst", &self.aclknrst())
                .field("ahbmrst", &self.ahbmrst())
                .field("ahb1rst", &self.ahb1rst())
                .field("ahb2rst", &self.ahb2rst())
                .field("ahb3rst", &self.ahb3rst())
                .field("ahb4rst", &self.ahb4rst())
                .field("ahb5rst", &self.ahb5rst())
                .field("apb1rst", &self.apb1rst())
                .field("apb2rst", &self.apb2rst())
                .field("apb3rst", &self.apb3rst())
                .field("apb4rst", &self.apb4rst())
                .field("apb5rst", &self.apb5rst())
                .field("nocrst", &self.nocrst())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Busrstr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Busrstr {{ aclknrst: {=bool:?}, ahbmrst: {=bool:?}, ahb1rst: {=bool:?}, ahb2rst: {=bool:?}, ahb3rst: {=bool:?}, ahb4rst: {=bool:?}, ahb5rst: {=bool:?}, apb1rst: {=bool:?}, apb2rst: {=bool:?}, apb3rst: {=bool:?}, apb4rst: {=bool:?}, apb5rst: {=bool:?}, nocrst: {=bool:?} }}" , self . aclknrst () , self . ahbmrst () , self . ahb1rst () , self . ahb2rst () , self . ahb3rst () , self . ahb4rst () , self . ahb5rst () , self . apb1rst () , self . apb2rst () , self . apb3rst () , self . apb4rst () , self . apb5rst () , self . nocrst ())
        }
    }
    #[doc = "RCC bus reset set register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Busrstsr(pub u32);
    impl Busrstsr {
        #[doc = "ACLKN reset."]
        #[inline(always)]
        pub const fn aclknrsts(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "ACLKN reset."]
        #[inline(always)]
        pub fn set_aclknrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "AHBM reset."]
        #[inline(always)]
        pub const fn ahbmrsts(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AHBM reset."]
        #[inline(always)]
        pub fn set_ahbmrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AHB1 reset."]
        #[inline(always)]
        pub const fn ahb1rsts(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AHB1 reset."]
        #[inline(always)]
        pub fn set_ahb1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHB2 reset."]
        #[inline(always)]
        pub const fn ahb2rsts(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHB2 reset."]
        #[inline(always)]
        pub fn set_ahb2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHB3 reset."]
        #[inline(always)]
        pub const fn ahb3rsts(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHB3 reset."]
        #[inline(always)]
        pub fn set_ahb3rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "AHB4 reset."]
        #[inline(always)]
        pub const fn ahb4rsts(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "AHB4 reset."]
        #[inline(always)]
        pub fn set_ahb4rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AHB5 reset."]
        #[inline(always)]
        pub const fn ahb5rsts(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AHB5 reset."]
        #[inline(always)]
        pub fn set_ahb5rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "APB1 reset."]
        #[inline(always)]
        pub const fn apb1rsts(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "APB1 reset."]
        #[inline(always)]
        pub fn set_apb1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "APB2 reset."]
        #[inline(always)]
        pub const fn apb2rsts(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "APB2 reset."]
        #[inline(always)]
        pub fn set_apb2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "APB3 reset."]
        #[inline(always)]
        pub const fn apb3rsts(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "APB3 reset."]
        #[inline(always)]
        pub fn set_apb3rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "APB4 reset."]
        #[inline(always)]
        pub const fn apb4rsts(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "APB4 reset."]
        #[inline(always)]
        pub fn set_apb4rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "APB5 reset."]
        #[inline(always)]
        pub const fn apb5rsts(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "APB5 reset."]
        #[inline(always)]
        pub fn set_apb5rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "NOC reset."]
        #[inline(always)]
        pub const fn nocrsts(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "NOC reset."]
        #[inline(always)]
        pub fn set_nocrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
    }
    impl Default for Busrstsr {
        #[inline(always)]
        fn default() -> Busrstsr {
            Busrstsr(0)
        }
    }
    impl core::fmt::Debug for Busrstsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Busrstsr")
                .field("aclknrsts", &self.aclknrsts())
                .field("ahbmrsts", &self.ahbmrsts())
                .field("ahb1rsts", &self.ahb1rsts())
                .field("ahb2rsts", &self.ahb2rsts())
                .field("ahb3rsts", &self.ahb3rsts())
                .field("ahb4rsts", &self.ahb4rsts())
                .field("ahb5rsts", &self.ahb5rsts())
                .field("apb1rsts", &self.apb1rsts())
                .field("apb2rsts", &self.apb2rsts())
                .field("apb3rsts", &self.apb3rsts())
                .field("apb4rsts", &self.apb4rsts())
                .field("apb5rsts", &self.apb5rsts())
                .field("nocrsts", &self.nocrsts())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Busrstsr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Busrstsr {{ aclknrsts: {=bool:?}, ahbmrsts: {=bool:?}, ahb1rsts: {=bool:?}, ahb2rsts: {=bool:?}, ahb3rsts: {=bool:?}, ahb4rsts: {=bool:?}, ahb5rsts: {=bool:?}, apb1rsts: {=bool:?}, apb2rsts: {=bool:?}, apb3rsts: {=bool:?}, apb4rsts: {=bool:?}, apb5rsts: {=bool:?}, nocrsts: {=bool:?} }}" , self . aclknrsts () , self . ahbmrsts () , self . ahb1rsts () , self . ahb2rsts () , self . ahb3rsts () , self . ahb4rsts () , self . ahb5rsts () , self . apb1rsts () , self . apb2rsts () , self . apb3rsts () , self . apb4rsts () , self . apb5rsts () , self . nocrsts ())
        }
    }
    #[doc = "RCC clock configuration for independent peripheral register1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccipr1(pub u32);
    impl Ccipr1 {
        #[doc = "Source selection for the ADF1 kernel clock."]
        #[inline(always)]
        pub const fn adf1sel(&self) -> super::vals::Adfsel {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Adfsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the ADF1 kernel clock."]
        #[inline(always)]
        pub fn set_adf1sel(&mut self, val: super::vals::Adfsel) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "Source selection for the ADC12 kernel clock."]
        #[inline(always)]
        pub const fn adc12sel(&self) -> super::vals::Adcsel {
            let val = (self.0 >> 4usize) & 0x07;
            super::vals::Adcsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the ADC12 kernel clock."]
        #[inline(always)]
        pub fn set_adc12sel(&mut self, val: super::vals::Adcsel) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
        }
        #[doc = "ADC12 Prog clock divider selection (for clock ck_icn_p_adf1)."]
        #[inline(always)]
        pub const fn adcpre(&self) -> super::vals::Adcpre {
            let val = (self.0 >> 8usize) & 0xff;
            super::vals::Adcpre::from_bits(val as u8)
        }
        #[doc = "ADC12 Prog clock divider selection (for clock ck_icn_p_adf1)."]
        #[inline(always)]
        pub fn set_adcpre(&mut self, val: super::vals::Adcpre) {
            self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u32) & 0xff) << 8usize);
        }
        #[doc = "Source selection for the DCMIPP kernel clock."]
        #[inline(always)]
        pub const fn dcmippsel(&self) -> super::vals::Dcmippsel {
            let val = (self.0 >> 20usize) & 0x03;
            super::vals::Dcmippsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the DCMIPP kernel clock."]
        #[inline(always)]
        pub fn set_dcmippsel(&mut self, val: super::vals::Dcmippsel) {
            self.0 = (self.0 & !(0x03 << 20usize)) | (((val.to_bits() as u32) & 0x03) << 20usize);
        }
    }
    impl Default for Ccipr1 {
        #[inline(always)]
        fn default() -> Ccipr1 {
            Ccipr1(0)
        }
    }
    impl core::fmt::Debug for Ccipr1 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ccipr1")
                .field("adf1sel", &self.adf1sel())
                .field("adc12sel", &self.adc12sel())
                .field("adcpre", &self.adcpre())
                .field("dcmippsel", &self.dcmippsel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ccipr1 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ccipr1 {{ adf1sel: {:?}, adc12sel: {:?}, adcpre: {:?}, dcmippsel: {:?} }}",
                self.adf1sel(),
                self.adc12sel(),
                self.adcpre(),
                self.dcmippsel()
            )
        }
    }
    #[doc = "RCC clock configuration for independent peripheral register12."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccipr12(pub u32);
    impl Ccipr12 {
        #[doc = "Source selection for the LPTIM1 kernel clock."]
        #[inline(always)]
        pub const fn lptim1sel(&self) -> super::vals::Lptimsel {
            let val = (self.0 >> 8usize) & 0x07;
            super::vals::Lptimsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the LPTIM1 kernel clock."]
        #[inline(always)]
        pub fn set_lptim1sel(&mut self, val: super::vals::Lptimsel) {
            self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
        }
        #[doc = "Source selection for the LPTIM2 kernel clock."]
        #[inline(always)]
        pub const fn lptim2sel(&self) -> super::vals::Lptimsel {
            let val = (self.0 >> 12usize) & 0x07;
            super::vals::Lptimsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the LPTIM2 kernel clock."]
        #[inline(always)]
        pub fn set_lptim2sel(&mut self, val: super::vals::Lptimsel) {
            self.0 = (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
        }
        #[doc = "Source selection for the LPTIM3 kernel clock."]
        #[inline(always)]
        pub const fn lptim3sel(&self) -> super::vals::Lptimsel {
            let val = (self.0 >> 16usize) & 0x07;
            super::vals::Lptimsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the LPTIM3 kernel clock."]
        #[inline(always)]
        pub fn set_lptim3sel(&mut self, val: super::vals::Lptimsel) {
            self.0 = (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
        }
        #[doc = "Source selection for the LPTIM4 kernel clock."]
        #[inline(always)]
        pub const fn lptim4sel(&self) -> super::vals::Lptimsel {
            let val = (self.0 >> 20usize) & 0x07;
            super::vals::Lptimsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the LPTIM4 kernel clock."]
        #[inline(always)]
        pub fn set_lptim4sel(&mut self, val: super::vals::Lptimsel) {
            self.0 = (self.0 & !(0x07 << 20usize)) | (((val.to_bits() as u32) & 0x07) << 20usize);
        }
        #[doc = "Source selection for the LPTIM5 kernel clock."]
        #[inline(always)]
        pub const fn lptim5sel(&self) -> super::vals::Lptimsel {
            let val = (self.0 >> 24usize) & 0x07;
            super::vals::Lptimsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the LPTIM5 kernel clock."]
        #[inline(always)]
        pub fn set_lptim5sel(&mut self, val: super::vals::Lptimsel) {
            self.0 = (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
        }
    }
    impl Default for Ccipr12 {
        #[inline(always)]
        fn default() -> Ccipr12 {
            Ccipr12(0)
        }
    }
    impl core::fmt::Debug for Ccipr12 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ccipr12")
                .field("lptim1sel", &self.lptim1sel())
                .field("lptim2sel", &self.lptim2sel())
                .field("lptim3sel", &self.lptim3sel())
                .field("lptim4sel", &self.lptim4sel())
                .field("lptim5sel", &self.lptim5sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ccipr12 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ccipr12 {{ lptim1sel: {:?}, lptim2sel: {:?}, lptim3sel: {:?}, lptim4sel: {:?}, lptim5sel: {:?} }}",
                self.lptim1sel(),
                self.lptim2sel(),
                self.lptim3sel(),
                self.lptim4sel(),
                self.lptim5sel()
            )
        }
    }
    #[doc = "RCC clock configuration for independent peripheral register13."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccipr13(pub u32);
    impl Ccipr13 {
        #[doc = "Source selection for the USART1 kernel clock."]
        #[inline(always)]
        pub const fn usart1sel(&self) -> super::vals::Usartsel {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Usartsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the USART1 kernel clock."]
        #[inline(always)]
        pub fn set_usart1sel(&mut self, val: super::vals::Usartsel) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "Source selection for the USART2 kernel clock."]
        #[inline(always)]
        pub const fn usart2sel(&self) -> super::vals::Usartsel {
            let val = (self.0 >> 4usize) & 0x07;
            super::vals::Usartsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the USART2 kernel clock."]
        #[inline(always)]
        pub fn set_usart2sel(&mut self, val: super::vals::Usartsel) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
        }
        #[doc = "Source selection for the USART3 kernel clock."]
        #[inline(always)]
        pub const fn usart3sel(&self) -> super::vals::Usartsel {
            let val = (self.0 >> 8usize) & 0x07;
            super::vals::Usartsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the USART3 kernel clock."]
        #[inline(always)]
        pub fn set_usart3sel(&mut self, val: super::vals::Usartsel) {
            self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
        }
        #[doc = "Source selection for the UART4 kernel clock."]
        #[inline(always)]
        pub const fn uart4sel(&self) -> super::vals::Uartsel {
            let val = (self.0 >> 12usize) & 0x07;
            super::vals::Uartsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the UART4 kernel clock."]
        #[inline(always)]
        pub fn set_uart4sel(&mut self, val: super::vals::Uartsel) {
            self.0 = (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
        }
        #[doc = "Source selection for the UART5 kernel clock."]
        #[inline(always)]
        pub const fn uart5sel(&self) -> super::vals::Uartsel {
            let val = (self.0 >> 16usize) & 0x07;
            super::vals::Uartsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the UART5 kernel clock."]
        #[inline(always)]
        pub fn set_uart5sel(&mut self, val: super::vals::Uartsel) {
            self.0 = (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
        }
        #[doc = "Source selection for the USART6 kernel clock."]
        #[inline(always)]
        pub const fn usart6sel(&self) -> super::vals::Usartsel {
            let val = (self.0 >> 20usize) & 0x07;
            super::vals::Usartsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the USART6 kernel clock."]
        #[inline(always)]
        pub fn set_usart6sel(&mut self, val: super::vals::Usartsel) {
            self.0 = (self.0 & !(0x07 << 20usize)) | (((val.to_bits() as u32) & 0x07) << 20usize);
        }
        #[doc = "Source selection for the UART7 kernel clock."]
        #[inline(always)]
        pub const fn uart7sel(&self) -> super::vals::Uartsel {
            let val = (self.0 >> 24usize) & 0x07;
            super::vals::Uartsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the UART7 kernel clock."]
        #[inline(always)]
        pub fn set_uart7sel(&mut self, val: super::vals::Uartsel) {
            self.0 = (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
        }
        #[doc = "Source selection for the UART8 kernel clock."]
        #[inline(always)]
        pub const fn uart8sel(&self) -> super::vals::Uartsel {
            let val = (self.0 >> 28usize) & 0x07;
            super::vals::Uartsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the UART8 kernel clock."]
        #[inline(always)]
        pub fn set_uart8sel(&mut self, val: super::vals::Uartsel) {
            self.0 = (self.0 & !(0x07 << 28usize)) | (((val.to_bits() as u32) & 0x07) << 28usize);
        }
    }
    impl Default for Ccipr13 {
        #[inline(always)]
        fn default() -> Ccipr13 {
            Ccipr13(0)
        }
    }
    impl core::fmt::Debug for Ccipr13 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ccipr13")
                .field("usart1sel", &self.usart1sel())
                .field("usart2sel", &self.usart2sel())
                .field("usart3sel", &self.usart3sel())
                .field("uart4sel", &self.uart4sel())
                .field("uart5sel", &self.uart5sel())
                .field("usart6sel", &self.usart6sel())
                .field("uart7sel", &self.uart7sel())
                .field("uart8sel", &self.uart8sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ccipr13 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ccipr13 {{ usart1sel: {:?}, usart2sel: {:?}, usart3sel: {:?}, uart4sel: {:?}, uart5sel: {:?}, usart6sel: {:?}, uart7sel: {:?}, uart8sel: {:?} }}" , self . usart1sel () , self . usart2sel () , self . usart3sel () , self . uart4sel () , self . uart5sel () , self . usart6sel () , self . uart7sel () , self . uart8sel ())
        }
    }
    #[doc = "RCC clock configuration for independent peripheral register14."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccipr14(pub u32);
    impl Ccipr14 {
        #[doc = "Source selection for the UART9 kernel clock."]
        #[inline(always)]
        pub const fn uart9sel(&self) -> super::vals::Uartsel {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Uartsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the UART9 kernel clock."]
        #[inline(always)]
        pub fn set_uart9sel(&mut self, val: super::vals::Uartsel) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "Source selection for the USART10 kernel clock."]
        #[inline(always)]
        pub const fn usart10sel(&self) -> super::vals::Usartsel {
            let val = (self.0 >> 4usize) & 0x07;
            super::vals::Usartsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the USART10 kernel clock."]
        #[inline(always)]
        pub fn set_usart10sel(&mut self, val: super::vals::Usartsel) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
        }
        #[doc = "Source selection for the LPUART1 kernel clock."]
        #[inline(always)]
        pub const fn lpuart1sel(&self) -> super::vals::Lpuartsel {
            let val = (self.0 >> 8usize) & 0x07;
            super::vals::Lpuartsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the LPUART1 kernel clock."]
        #[inline(always)]
        pub fn set_lpuart1sel(&mut self, val: super::vals::Lpuartsel) {
            self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
        }
    }
    impl Default for Ccipr14 {
        #[inline(always)]
        fn default() -> Ccipr14 {
            Ccipr14(0)
        }
    }
    impl core::fmt::Debug for Ccipr14 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ccipr14")
                .field("uart9sel", &self.uart9sel())
                .field("usart10sel", &self.usart10sel())
                .field("lpuart1sel", &self.lpuart1sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ccipr14 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ccipr14 {{ uart9sel: {:?}, usart10sel: {:?}, lpuart1sel: {:?} }}",
                self.uart9sel(),
                self.usart10sel(),
                self.lpuart1sel()
            )
        }
    }
    #[doc = "RCC clock configuration for independent peripheral register 2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccipr2(pub u32);
    impl Ccipr2 {
        #[doc = "Source selection for the ETH1 kernel clock."]
        #[inline(always)]
        pub const fn eth1ptpsel(&self) -> super::vals::Ethptpsel {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::Ethptpsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the ETH1 kernel clock."]
        #[inline(always)]
        pub fn set_eth1ptpsel(&mut self, val: super::vals::Ethptpsel) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "ETH1 Kernel clock divider selection (for clock ck_ker_eth1ptp)."]
        #[inline(always)]
        pub const fn eth1ptpdiv(&self) -> super::vals::Ethptpdiv {
            let val = (self.0 >> 4usize) & 0x0f;
            super::vals::Ethptpdiv::from_bits(val as u8)
        }
        #[doc = "ETH1 Kernel clock divider selection (for clock ck_ker_eth1ptp)."]
        #[inline(always)]
        pub fn set_eth1ptpdiv(&mut self, val: super::vals::Ethptpdiv) {
            self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
        }
        #[doc = "Set and reset by software."]
        #[inline(always)]
        pub const fn eth1pwrdownack(&self) -> super::vals::Ethpwrdownack {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Ethpwrdownack::from_bits(val as u8)
        }
        #[doc = "Set and reset by software."]
        #[inline(always)]
        pub fn set_eth1pwrdownack(&mut self, val: super::vals::Ethpwrdownack) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
        #[doc = "Source selection for the ETH1 kernel clock."]
        #[inline(always)]
        pub const fn eth1clksel(&self) -> super::vals::Ethclksel {
            let val = (self.0 >> 12usize) & 0x03;
            super::vals::Ethclksel::from_bits(val as u8)
        }
        #[doc = "Source selection for the ETH1 kernel clock."]
        #[inline(always)]
        pub fn set_eth1clksel(&mut self, val: super::vals::Ethclksel) {
            self.0 = (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
        }
        #[doc = "Set and reset by software."]
        #[inline(always)]
        pub const fn eth1sel(&self) -> u8 {
            let val = (self.0 >> 16usize) & 0x07;
            val as u8
        }
        #[doc = "Set and reset by software."]
        #[inline(always)]
        pub fn set_eth1sel(&mut self, val: u8) {
            self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
        }
        #[doc = "Set and reset by software."]
        #[inline(always)]
        pub const fn eth1refclksel(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "Set and reset by software."]
        #[inline(always)]
        pub fn set_eth1refclksel(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "Set and reset by software."]
        #[inline(always)]
        pub const fn eth1gtxclksel(&self) -> super::vals::Ethgtxclksel {
            let val = (self.0 >> 24usize) & 0x01;
            super::vals::Ethgtxclksel::from_bits(val as u8)
        }
        #[doc = "Set and reset by software."]
        #[inline(always)]
        pub fn set_eth1gtxclksel(&mut self, val: super::vals::Ethgtxclksel) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
        }
    }
    impl Default for Ccipr2 {
        #[inline(always)]
        fn default() -> Ccipr2 {
            Ccipr2(0)
        }
    }
    impl core::fmt::Debug for Ccipr2 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ccipr2")
                .field("eth1ptpsel", &self.eth1ptpsel())
                .field("eth1ptpdiv", &self.eth1ptpdiv())
                .field("eth1pwrdownack", &self.eth1pwrdownack())
                .field("eth1clksel", &self.eth1clksel())
                .field("eth1sel", &self.eth1sel())
                .field("eth1refclksel", &self.eth1refclksel())
                .field("eth1gtxclksel", &self.eth1gtxclksel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ccipr2 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ccipr2 {{ eth1ptpsel: {:?}, eth1ptpdiv: {:?}, eth1pwrdownack: {:?}, eth1clksel: {:?}, eth1sel: {=u8:?}, eth1refclksel: {=bool:?}, eth1gtxclksel: {:?} }}" , self . eth1ptpsel () , self . eth1ptpdiv () , self . eth1pwrdownack () , self . eth1clksel () , self . eth1sel () , self . eth1refclksel () , self . eth1gtxclksel ())
        }
    }
    #[doc = "RCC clock configuration for independent peripheral register3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccipr3(pub u32);
    impl Ccipr3 {
        #[doc = "Source selection for the FDCAN kernel clock."]
        #[inline(always)]
        pub const fn fdcansel(&self) -> super::vals::Fdcansel {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::Fdcansel::from_bits(val as u8)
        }
        #[doc = "Source selection for the FDCAN kernel clock."]
        #[inline(always)]
        pub fn set_fdcansel(&mut self, val: super::vals::Fdcansel) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "Source selection for the FMC kernel clock."]
        #[inline(always)]
        pub const fn fmcsel(&self) -> super::vals::Fmcsel {
            let val = (self.0 >> 4usize) & 0x03;
            super::vals::Fmcsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the FMC kernel clock."]
        #[inline(always)]
        pub fn set_fmcsel(&mut self, val: super::vals::Fmcsel) {
            self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
        }
        #[doc = "Source selection for the DFT kernel clock."]
        #[inline(always)]
        pub const fn dftsel(&self) -> super::vals::Dftsel {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Dftsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the DFT kernel clock."]
        #[inline(always)]
        pub fn set_dftsel(&mut self, val: super::vals::Dftsel) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
    }
    impl Default for Ccipr3 {
        #[inline(always)]
        fn default() -> Ccipr3 {
            Ccipr3(0)
        }
    }
    impl core::fmt::Debug for Ccipr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ccipr3")
                .field("fdcansel", &self.fdcansel())
                .field("fmcsel", &self.fmcsel())
                .field("dftsel", &self.dftsel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ccipr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ccipr3 {{ fdcansel: {:?}, fmcsel: {:?}, dftsel: {:?} }}",
                self.fdcansel(),
                self.fmcsel(),
                self.dftsel()
            )
        }
    }
    #[doc = "RCC clock configuration for independent peripheral register4."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccipr4(pub u32);
    impl Ccipr4 {
        #[doc = "Source selection for the I2C1 kernel clock."]
        #[inline(always)]
        pub const fn i2c1sel(&self) -> super::vals::I2c1sel {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::I2c1sel::from_bits(val as u8)
        }
        #[doc = "Source selection for the I2C1 kernel clock."]
        #[inline(always)]
        pub fn set_i2c1sel(&mut self, val: super::vals::I2c1sel) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "Source selection for the I2C2 kernel clock."]
        #[inline(always)]
        pub const fn i2c2sel(&self) -> super::vals::I2c2sel {
            let val = (self.0 >> 4usize) & 0x07;
            super::vals::I2c2sel::from_bits(val as u8)
        }
        #[doc = "Source selection for the I2C2 kernel clock."]
        #[inline(always)]
        pub fn set_i2c2sel(&mut self, val: super::vals::I2c2sel) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
        }
        #[doc = "Source selection for the I2C3 kernel clock."]
        #[inline(always)]
        pub const fn i2c3sel(&self) -> super::vals::I2c3sel {
            let val = (self.0 >> 8usize) & 0x07;
            super::vals::I2c3sel::from_bits(val as u8)
        }
        #[doc = "Source selection for the I2C3 kernel clock."]
        #[inline(always)]
        pub fn set_i2c3sel(&mut self, val: super::vals::I2c3sel) {
            self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
        }
        #[doc = "Source selection for the I2C4 kernel clock."]
        #[inline(always)]
        pub const fn i2c4sel(&self) -> super::vals::I2c4sel {
            let val = (self.0 >> 12usize) & 0x07;
            super::vals::I2c4sel::from_bits(val as u8)
        }
        #[doc = "Source selection for the I2C4 kernel clock."]
        #[inline(always)]
        pub fn set_i2c4sel(&mut self, val: super::vals::I2c4sel) {
            self.0 = (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
        }
        #[doc = "Source selection for the I3C1 kernel clock."]
        #[inline(always)]
        pub const fn i3c1sel(&self) -> super::vals::I3c1sel {
            let val = (self.0 >> 16usize) & 0x07;
            super::vals::I3c1sel::from_bits(val as u8)
        }
        #[doc = "Source selection for the I3C1 kernel clock."]
        #[inline(always)]
        pub fn set_i3c1sel(&mut self, val: super::vals::I3c1sel) {
            self.0 = (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
        }
        #[doc = "Source selection for the I3C2 kernel clock."]
        #[inline(always)]
        pub const fn i3c2sel(&self) -> super::vals::I3c2sel {
            let val = (self.0 >> 20usize) & 0x07;
            super::vals::I3c2sel::from_bits(val as u8)
        }
        #[doc = "Source selection for the I3C2 kernel clock."]
        #[inline(always)]
        pub fn set_i3c2sel(&mut self, val: super::vals::I3c2sel) {
            self.0 = (self.0 & !(0x07 << 20usize)) | (((val.to_bits() as u32) & 0x07) << 20usize);
        }
        #[doc = "Source selection for the LTDC kernel clock."]
        #[inline(always)]
        pub const fn ltdcsel(&self) -> super::vals::Ltdcsel {
            let val = (self.0 >> 24usize) & 0x03;
            super::vals::Ltdcsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the LTDC kernel clock."]
        #[inline(always)]
        pub fn set_ltdcsel(&mut self, val: super::vals::Ltdcsel) {
            self.0 = (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
        }
    }
    impl Default for Ccipr4 {
        #[inline(always)]
        fn default() -> Ccipr4 {
            Ccipr4(0)
        }
    }
    impl core::fmt::Debug for Ccipr4 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ccipr4")
                .field("i2c1sel", &self.i2c1sel())
                .field("i2c2sel", &self.i2c2sel())
                .field("i2c3sel", &self.i2c3sel())
                .field("i2c4sel", &self.i2c4sel())
                .field("i3c1sel", &self.i3c1sel())
                .field("i3c2sel", &self.i3c2sel())
                .field("ltdcsel", &self.ltdcsel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ccipr4 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ccipr4 {{ i2c1sel: {:?}, i2c2sel: {:?}, i2c3sel: {:?}, i2c4sel: {:?}, i3c1sel: {:?}, i3c2sel: {:?}, ltdcsel: {:?} }}" , self . i2c1sel () , self . i2c2sel () , self . i2c3sel () , self . i2c4sel () , self . i3c1sel () , self . i3c2sel () , self . ltdcsel ())
        }
    }
    #[doc = "RCC lock configuration for independent peripheral register5."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccipr5(pub u32);
    impl Ccipr5 {
        #[doc = "Source selection for the MCO1 kernel clock."]
        #[inline(always)]
        pub const fn mco1sel(&self) -> super::vals::Mcosel {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Mcosel::from_bits(val as u8)
        }
        #[doc = "Source selection for the MCO1 kernel clock."]
        #[inline(always)]
        pub fn set_mco1sel(&mut self, val: super::vals::Mcosel) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "MCO1 Prog clock divider selection (for clock ck_icn_p_mce3)."]
        #[inline(always)]
        pub const fn mco1pre(&self) -> super::vals::Mcopre {
            let val = (self.0 >> 4usize) & 0x0f;
            super::vals::Mcopre::from_bits(val as u8)
        }
        #[doc = "MCO1 Prog clock divider selection (for clock ck_icn_p_mce3)."]
        #[inline(always)]
        pub fn set_mco1pre(&mut self, val: super::vals::Mcopre) {
            self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
        }
        #[doc = "Source selection for the MCO2 kernel clock."]
        #[inline(always)]
        pub const fn mco2sel(&self) -> super::vals::Mcosel {
            let val = (self.0 >> 8usize) & 0x07;
            super::vals::Mcosel::from_bits(val as u8)
        }
        #[doc = "Source selection for the MCO2 kernel clock."]
        #[inline(always)]
        pub fn set_mco2sel(&mut self, val: super::vals::Mcosel) {
            self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
        }
        #[doc = "MCO2 Prog clock divider selection (for clock ck_icn_p_mce4)."]
        #[inline(always)]
        pub const fn mco2pre(&self) -> super::vals::Mcopre {
            let val = (self.0 >> 12usize) & 0x0f;
            super::vals::Mcopre::from_bits(val as u8)
        }
        #[doc = "MCO2 Prog clock divider selection (for clock ck_icn_p_mce4)."]
        #[inline(always)]
        pub fn set_mco2pre(&mut self, val: super::vals::Mcopre) {
            self.0 = (self.0 & !(0x0f << 12usize)) | (((val.to_bits() as u32) & 0x0f) << 12usize);
        }
        #[doc = "Source selection for the MDF1 kernel clock."]
        #[inline(always)]
        pub const fn mdf1sel(&self) -> super::vals::Mdfsel {
            let val = (self.0 >> 16usize) & 0x07;
            super::vals::Mdfsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the MDF1 kernel clock."]
        #[inline(always)]
        pub fn set_mdf1sel(&mut self, val: super::vals::Mdfsel) {
            self.0 = (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
        }
    }
    impl Default for Ccipr5 {
        #[inline(always)]
        fn default() -> Ccipr5 {
            Ccipr5(0)
        }
    }
    impl core::fmt::Debug for Ccipr5 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ccipr5")
                .field("mco1sel", &self.mco1sel())
                .field("mco1pre", &self.mco1pre())
                .field("mco2sel", &self.mco2sel())
                .field("mco2pre", &self.mco2pre())
                .field("mdf1sel", &self.mdf1sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ccipr5 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ccipr5 {{ mco1sel: {:?}, mco1pre: {:?}, mco2sel: {:?}, mco2pre: {:?}, mdf1sel: {:?} }}",
                self.mco1sel(),
                self.mco1pre(),
                self.mco2sel(),
                self.mco2pre(),
                self.mdf1sel()
            )
        }
    }
    #[doc = "RCC clock configuration for independent peripheral register6."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccipr6(pub u32);
    impl Ccipr6 {
        #[doc = "Source selection for the XSPI1 kernel clock."]
        #[inline(always)]
        pub const fn xspi1sel(&self) -> super::vals::Xspisel {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::Xspisel::from_bits(val as u8)
        }
        #[doc = "Source selection for the XSPI1 kernel clock."]
        #[inline(always)]
        pub fn set_xspi1sel(&mut self, val: super::vals::Xspisel) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "Source selection for the XSPI2 kernel clock."]
        #[inline(always)]
        pub const fn xspi2sel(&self) -> super::vals::Xspisel {
            let val = (self.0 >> 4usize) & 0x03;
            super::vals::Xspisel::from_bits(val as u8)
        }
        #[doc = "Source selection for the XSPI2 kernel clock."]
        #[inline(always)]
        pub fn set_xspi2sel(&mut self, val: super::vals::Xspisel) {
            self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
        }
        #[doc = "Source selection for the XSPI3 kernel clock."]
        #[inline(always)]
        pub const fn xspi3sel(&self) -> super::vals::Xspisel {
            let val = (self.0 >> 8usize) & 0x03;
            super::vals::Xspisel::from_bits(val as u8)
        }
        #[doc = "Source selection for the XSPI3 kernel clock."]
        #[inline(always)]
        pub fn set_xspi3sel(&mut self, val: super::vals::Xspisel) {
            self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
        }
        #[doc = "Source selection for the OTGPHY1 kernel clock."]
        #[inline(always)]
        pub const fn otgphy1sel(&self) -> super::vals::Otgphysel {
            let val = (self.0 >> 12usize) & 0x03;
            super::vals::Otgphysel::from_bits(val as u8)
        }
        #[doc = "Source selection for the OTGPHY1 kernel clock."]
        #[inline(always)]
        pub fn set_otgphy1sel(&mut self, val: super::vals::Otgphysel) {
            self.0 = (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
        }
        #[doc = "Set and reset by software."]
        #[inline(always)]
        pub const fn otgphy1ckrefsel(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "Set and reset by software."]
        #[inline(always)]
        pub fn set_otgphy1ckrefsel(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "Source selection for the OTGPHY2 kernel clock."]
        #[inline(always)]
        pub const fn otgphy2sel(&self) -> super::vals::Otgphysel {
            let val = (self.0 >> 20usize) & 0x03;
            super::vals::Otgphysel::from_bits(val as u8)
        }
        #[doc = "Source selection for the OTGPHY2 kernel clock."]
        #[inline(always)]
        pub fn set_otgphy2sel(&mut self, val: super::vals::Otgphysel) {
            self.0 = (self.0 & !(0x03 << 20usize)) | (((val.to_bits() as u32) & 0x03) << 20usize);
        }
        #[doc = "Set and reset by software."]
        #[inline(always)]
        pub const fn otgphy2ckrefsel(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "Set and reset by software."]
        #[inline(always)]
        pub fn set_otgphy2ckrefsel(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
    }
    impl Default for Ccipr6 {
        #[inline(always)]
        fn default() -> Ccipr6 {
            Ccipr6(0)
        }
    }
    impl core::fmt::Debug for Ccipr6 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ccipr6")
                .field("xspi1sel", &self.xspi1sel())
                .field("xspi2sel", &self.xspi2sel())
                .field("xspi3sel", &self.xspi3sel())
                .field("otgphy1sel", &self.otgphy1sel())
                .field("otgphy1ckrefsel", &self.otgphy1ckrefsel())
                .field("otgphy2sel", &self.otgphy2sel())
                .field("otgphy2ckrefsel", &self.otgphy2ckrefsel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ccipr6 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ccipr6 {{ xspi1sel: {:?}, xspi2sel: {:?}, xspi3sel: {:?}, otgphy1sel: {:?}, otgphy1ckrefsel: {=bool:?}, otgphy2sel: {:?}, otgphy2ckrefsel: {=bool:?} }}" , self . xspi1sel () , self . xspi2sel () , self . xspi3sel () , self . otgphy1sel () , self . otgphy1ckrefsel () , self . otgphy2sel () , self . otgphy2ckrefsel ())
        }
    }
    #[doc = "RCC clock configuration for independent peripheral register7."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccipr7(pub u32);
    impl Ccipr7 {
        #[doc = "Source selection for the PER kernel clock."]
        #[inline(always)]
        pub const fn persel(&self) -> super::vals::Persel {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Persel::from_bits(val as u8)
        }
        #[doc = "Source selection for the PER kernel clock."]
        #[inline(always)]
        pub fn set_persel(&mut self, val: super::vals::Persel) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "Source selection for the PSSI kernel clock."]
        #[inline(always)]
        pub const fn pssisel(&self) -> super::vals::Pssisel {
            let val = (self.0 >> 4usize) & 0x03;
            super::vals::Pssisel::from_bits(val as u8)
        }
        #[doc = "Source selection for the PSSI kernel clock."]
        #[inline(always)]
        pub fn set_pssisel(&mut self, val: super::vals::Pssisel) {
            self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
        }
        #[doc = "Source selection for the RTC kernel clock."]
        #[inline(always)]
        pub const fn rtcsel(&self) -> super::vals::Rtcsel {
            let val = (self.0 >> 8usize) & 0x03;
            super::vals::Rtcsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the RTC kernel clock."]
        #[inline(always)]
        pub fn set_rtcsel(&mut self, val: super::vals::Rtcsel) {
            self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
        }
        #[doc = "RTC Prog clock divider selection (for clock ck_icn_p_risaf)."]
        #[inline(always)]
        pub const fn rtcpre(&self) -> super::vals::Rtcpre {
            let val = (self.0 >> 12usize) & 0x3f;
            super::vals::Rtcpre::from_bits(val as u8)
        }
        #[doc = "RTC Prog clock divider selection (for clock ck_icn_p_risaf)."]
        #[inline(always)]
        pub fn set_rtcpre(&mut self, val: super::vals::Rtcpre) {
            self.0 = (self.0 & !(0x3f << 12usize)) | (((val.to_bits() as u32) & 0x3f) << 12usize);
        }
        #[doc = "Source selection for the SAI1 kernel clock."]
        #[inline(always)]
        pub const fn sai1sel(&self) -> super::vals::Saisel {
            let val = (self.0 >> 20usize) & 0x07;
            super::vals::Saisel::from_bits(val as u8)
        }
        #[doc = "Source selection for the SAI1 kernel clock."]
        #[inline(always)]
        pub fn set_sai1sel(&mut self, val: super::vals::Saisel) {
            self.0 = (self.0 & !(0x07 << 20usize)) | (((val.to_bits() as u32) & 0x07) << 20usize);
        }
        #[doc = "Source selection for the SAI2 kernel clock."]
        #[inline(always)]
        pub const fn sai2sel(&self) -> super::vals::Saisel {
            let val = (self.0 >> 24usize) & 0x07;
            super::vals::Saisel::from_bits(val as u8)
        }
        #[doc = "Source selection for the SAI2 kernel clock."]
        #[inline(always)]
        pub fn set_sai2sel(&mut self, val: super::vals::Saisel) {
            self.0 = (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
        }
    }
    impl Default for Ccipr7 {
        #[inline(always)]
        fn default() -> Ccipr7 {
            Ccipr7(0)
        }
    }
    impl core::fmt::Debug for Ccipr7 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ccipr7")
                .field("persel", &self.persel())
                .field("pssisel", &self.pssisel())
                .field("rtcsel", &self.rtcsel())
                .field("rtcpre", &self.rtcpre())
                .field("sai1sel", &self.sai1sel())
                .field("sai2sel", &self.sai2sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ccipr7 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ccipr7 {{ persel: {:?}, pssisel: {:?}, rtcsel: {:?}, rtcpre: {:?}, sai1sel: {:?}, sai2sel: {:?} }}",
                self.persel(),
                self.pssisel(),
                self.rtcsel(),
                self.rtcpre(),
                self.sai1sel(),
                self.sai2sel()
            )
        }
    }
    #[doc = "RCC clock configuration for independent peripheral register8."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccipr8(pub u32);
    impl Ccipr8 {
        #[doc = "Source selection for the SDMMC1 kernel clock."]
        #[inline(always)]
        pub const fn sdmmc1sel(&self) -> super::vals::Sdmmcsel {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::Sdmmcsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the SDMMC1 kernel clock."]
        #[inline(always)]
        pub fn set_sdmmc1sel(&mut self, val: super::vals::Sdmmcsel) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "Source selection for the SDMMC2 kernel clock."]
        #[inline(always)]
        pub const fn sdmmc2sel(&self) -> super::vals::Sdmmcsel {
            let val = (self.0 >> 4usize) & 0x03;
            super::vals::Sdmmcsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the SDMMC2 kernel clock."]
        #[inline(always)]
        pub fn set_sdmmc2sel(&mut self, val: super::vals::Sdmmcsel) {
            self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
        }
    }
    impl Default for Ccipr8 {
        #[inline(always)]
        fn default() -> Ccipr8 {
            Ccipr8(0)
        }
    }
    impl core::fmt::Debug for Ccipr8 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ccipr8")
                .field("sdmmc1sel", &self.sdmmc1sel())
                .field("sdmmc2sel", &self.sdmmc2sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ccipr8 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ccipr8 {{ sdmmc1sel: {:?}, sdmmc2sel: {:?} }}",
                self.sdmmc1sel(),
                self.sdmmc2sel()
            )
        }
    }
    #[doc = "RCC clock configuration for independent peripheral register9."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccipr9(pub u32);
    impl Ccipr9 {
        #[doc = "Source selection for the SPDIFRX1 kernel clock."]
        #[inline(always)]
        pub const fn spdifrx1sel(&self) -> super::vals::Spdifrxsel {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Spdifrxsel::from_bits(val as u8)
        }
        #[doc = "Source selection for the SPDIFRX1 kernel clock."]
        #[inline(always)]
        pub fn set_spdifrx1sel(&mut self, val: super::vals::Spdifrxsel) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "Source selection for the SPI1 kernel clock."]
        #[inline(always)]
        pub const fn spi1sel(&self) -> super::vals::Spisel1 {
            let val = (self.0 >> 4usize) & 0x07;
            super::vals::Spisel1::from_bits(val as u8)
        }
        #[doc = "Source selection for the SPI1 kernel clock."]
        #[inline(always)]
        pub fn set_spi1sel(&mut self, val: super::vals::Spisel1) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
        }
        #[doc = "Source selection for the SPI2 kernel clock."]
        #[inline(always)]
        pub const fn spi2sel(&self) -> super::vals::Spisel23 {
            let val = (self.0 >> 8usize) & 0x07;
            super::vals::Spisel23::from_bits(val as u8)
        }
        #[doc = "Source selection for the SPI2 kernel clock."]
        #[inline(always)]
        pub fn set_spi2sel(&mut self, val: super::vals::Spisel23) {
            self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
        }
        #[doc = "Source selection for the SPI3 kernel clock."]
        #[inline(always)]
        pub const fn spi3sel(&self) -> super::vals::Spisel23 {
            let val = (self.0 >> 12usize) & 0x07;
            super::vals::Spisel23::from_bits(val as u8)
        }
        #[doc = "Source selection for the SPI3 kernel clock."]
        #[inline(always)]
        pub fn set_spi3sel(&mut self, val: super::vals::Spisel23) {
            self.0 = (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
        }
        #[doc = "Source selection for the SPI4 kernel clock."]
        #[inline(always)]
        pub const fn spi4sel(&self) -> super::vals::Spisel45 {
            let val = (self.0 >> 16usize) & 0x07;
            super::vals::Spisel45::from_bits(val as u8)
        }
        #[doc = "Source selection for the SPI4 kernel clock."]
        #[inline(always)]
        pub fn set_spi4sel(&mut self, val: super::vals::Spisel45) {
            self.0 = (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
        }
        #[doc = "Source selection for the SPI5 kernel clock."]
        #[inline(always)]
        pub const fn spi5sel(&self) -> super::vals::Spisel45 {
            let val = (self.0 >> 20usize) & 0x07;
            super::vals::Spisel45::from_bits(val as u8)
        }
        #[doc = "Source selection for the SPI5 kernel clock."]
        #[inline(always)]
        pub fn set_spi5sel(&mut self, val: super::vals::Spisel45) {
            self.0 = (self.0 & !(0x07 << 20usize)) | (((val.to_bits() as u32) & 0x07) << 20usize);
        }
        #[doc = "Source selection for the SPI6 kernel clock."]
        #[inline(always)]
        pub const fn spi6sel(&self) -> super::vals::Spisel6 {
            let val = (self.0 >> 24usize) & 0x07;
            super::vals::Spisel6::from_bits(val as u8)
        }
        #[doc = "Source selection for the SPI6 kernel clock."]
        #[inline(always)]
        pub fn set_spi6sel(&mut self, val: super::vals::Spisel6) {
            self.0 = (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
        }
    }
    impl Default for Ccipr9 {
        #[inline(always)]
        fn default() -> Ccipr9 {
            Ccipr9(0)
        }
    }
    impl core::fmt::Debug for Ccipr9 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ccipr9")
                .field("spdifrx1sel", &self.spdifrx1sel())
                .field("spi1sel", &self.spi1sel())
                .field("spi2sel", &self.spi2sel())
                .field("spi3sel", &self.spi3sel())
                .field("spi4sel", &self.spi4sel())
                .field("spi5sel", &self.spi5sel())
                .field("spi6sel", &self.spi6sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ccipr9 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ccipr9 {{ spdifrx1sel: {:?}, spi1sel: {:?}, spi2sel: {:?}, spi3sel: {:?}, spi4sel: {:?}, spi5sel: {:?}, spi6sel: {:?} }}" , self . spdifrx1sel () , self . spi1sel () , self . spi2sel () , self . spi3sel () , self . spi4sel () , self . spi5sel () , self . spi6sel ())
        }
    }
    #[doc = "RCC control Clear register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccr(pub u32);
    impl Ccr {
        #[doc = "LSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn lsionc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "LSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_lsionc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "LSE oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn lseonc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "LSE oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_lseonc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "MSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn msionc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "MSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_msionc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "HSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn hsionc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "HSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_hsionc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "HSE oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn hseonc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "HSE oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_hseonc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "PLL1 oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn pllonc(&self, n: usize) -> bool {
            assert!(n < 4usize);
            let offs = 8usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL1 oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_pllonc(&mut self, n: usize, val: bool) {
            assert!(n < 4usize);
            let offs = 8usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Ccr {
        #[inline(always)]
        fn default() -> Ccr {
            Ccr(0)
        }
    }
    impl core::fmt::Debug for Ccr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ccr")
                .field("lsionc", &self.lsionc())
                .field("lseonc", &self.lseonc())
                .field("msionc", &self.msionc())
                .field("hsionc", &self.hsionc())
                .field("hseonc", &self.hseonc())
                .field("pllonc[0]", &self.pllonc(0usize))
                .field("pllonc[1]", &self.pllonc(1usize))
                .field("pllonc[2]", &self.pllonc(2usize))
                .field("pllonc[3]", &self.pllonc(3usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ccr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Ccr {{ lsionc: {=bool:?}, lseonc: {=bool:?}, msionc: {=bool:?}, hsionc: {=bool:?}, hseonc: {=bool:?}, pllonc[0]: {=bool:?}, pllonc[1]: {=bool:?}, pllonc[2]: {=bool:?}, pllonc[3]: {=bool:?} }}" , self . lsionc () , self . lseonc () , self . msionc () , self . hsionc () , self . hseonc () , self . pllonc (0usize) , self . pllonc (1usize) , self . pllonc (2usize) , self . pllonc (3usize))
        }
    }
    #[doc = "RCC configuration register 1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cfgr1(pub u32);
    impl Cfgr1 {
        #[doc = "System clock selection after a wake up from system Stop."]
        #[inline(always)]
        pub const fn stopwuck(&self) -> super::vals::Stopwuck {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Stopwuck::from_bits(val as u8)
        }
        #[doc = "System clock selection after a wake up from system Stop."]
        #[inline(always)]
        pub fn set_stopwuck(&mut self, val: super::vals::Stopwuck) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "CPU clock switch selection."]
        #[inline(always)]
        pub const fn cpusw(&self) -> super::vals::Cpusw {
            let val = (self.0 >> 16usize) & 0x03;
            super::vals::Cpusw::from_bits(val as u8)
        }
        #[doc = "CPU clock switch selection."]
        #[inline(always)]
        pub fn set_cpusw(&mut self, val: super::vals::Cpusw) {
            self.0 = (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
        }
        #[doc = "CPU clock switch status."]
        #[inline(always)]
        pub const fn cpusws(&self) -> super::vals::Cpusws {
            let val = (self.0 >> 20usize) & 0x03;
            super::vals::Cpusws::from_bits(val as u8)
        }
        #[doc = "CPU clock switch status."]
        #[inline(always)]
        pub fn set_cpusws(&mut self, val: super::vals::Cpusws) {
            self.0 = (self.0 & !(0x03 << 20usize)) | (((val.to_bits() as u32) & 0x03) << 20usize);
        }
        #[doc = "System clock switch selection."]
        #[inline(always)]
        pub const fn syssw(&self) -> super::vals::Syssw {
            let val = (self.0 >> 24usize) & 0x03;
            super::vals::Syssw::from_bits(val as u8)
        }
        #[doc = "System clock switch selection."]
        #[inline(always)]
        pub fn set_syssw(&mut self, val: super::vals::Syssw) {
            self.0 = (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
        }
        #[doc = "System clock switch status."]
        #[inline(always)]
        pub const fn syssws(&self) -> super::vals::Syssws {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Syssws::from_bits(val as u8)
        }
        #[doc = "System clock switch status."]
        #[inline(always)]
        pub fn set_syssws(&mut self, val: super::vals::Syssws) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Cfgr1 {
        #[inline(always)]
        fn default() -> Cfgr1 {
            Cfgr1(0)
        }
    }
    impl core::fmt::Debug for Cfgr1 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Cfgr1")
                .field("stopwuck", &self.stopwuck())
                .field("cpusw", &self.cpusw())
                .field("cpusws", &self.cpusws())
                .field("syssw", &self.syssw())
                .field("syssws", &self.syssws())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Cfgr1 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Cfgr1 {{ stopwuck: {:?}, cpusw: {:?}, cpusws: {:?}, syssw: {:?}, syssws: {:?} }}",
                self.stopwuck(),
                self.cpusw(),
                self.cpusws(),
                self.syssw(),
                self.syssws()
            )
        }
    }
    #[doc = "RCC configuration register 2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cfgr2(pub u32);
    impl Cfgr2 {
        #[doc = "CPU domain APB1 prescaler."]
        #[inline(always)]
        pub const fn ppre1(&self) -> super::vals::Ppre {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Ppre::from_bits(val as u8)
        }
        #[doc = "CPU domain APB1 prescaler."]
        #[inline(always)]
        pub fn set_ppre1(&mut self, val: super::vals::Ppre) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "CPU domain APB2 prescaler."]
        #[inline(always)]
        pub const fn ppre2(&self) -> super::vals::Ppre {
            let val = (self.0 >> 4usize) & 0x07;
            super::vals::Ppre::from_bits(val as u8)
        }
        #[doc = "CPU domain APB2 prescaler."]
        #[inline(always)]
        pub fn set_ppre2(&mut self, val: super::vals::Ppre) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
        }
        #[doc = "CPU domain APB4 prescaler."]
        #[inline(always)]
        pub const fn ppre4(&self) -> super::vals::Ppre {
            let val = (self.0 >> 12usize) & 0x07;
            super::vals::Ppre::from_bits(val as u8)
        }
        #[doc = "CPU domain APB4 prescaler."]
        #[inline(always)]
        pub fn set_ppre4(&mut self, val: super::vals::Ppre) {
            self.0 = (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
        }
        #[doc = "CPU domain APB5 prescaler."]
        #[inline(always)]
        pub const fn ppre5(&self) -> super::vals::Ppre {
            let val = (self.0 >> 16usize) & 0x07;
            super::vals::Ppre::from_bits(val as u8)
        }
        #[doc = "CPU domain APB5 prescaler."]
        #[inline(always)]
        pub fn set_ppre5(&mut self, val: super::vals::Ppre) {
            self.0 = (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
        }
        #[doc = "AHB clock prescaler."]
        #[inline(always)]
        pub const fn hpre(&self) -> super::vals::Hpre {
            let val = (self.0 >> 20usize) & 0x07;
            super::vals::Hpre::from_bits(val as u8)
        }
        #[doc = "AHB clock prescaler."]
        #[inline(always)]
        pub fn set_hpre(&mut self, val: super::vals::Hpre) {
            self.0 = (self.0 & !(0x07 << 20usize)) | (((val.to_bits() as u32) & 0x07) << 20usize);
        }
        #[doc = "Timers clocks prescaler selection."]
        #[inline(always)]
        pub const fn timpre(&self) -> super::vals::Timpre {
            let val = (self.0 >> 24usize) & 0x03;
            super::vals::Timpre::from_bits(val as u8)
        }
        #[doc = "Timers clocks prescaler selection."]
        #[inline(always)]
        pub fn set_timpre(&mut self, val: super::vals::Timpre) {
            self.0 = (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
        }
    }
    impl Default for Cfgr2 {
        #[inline(always)]
        fn default() -> Cfgr2 {
            Cfgr2(0)
        }
    }
    impl core::fmt::Debug for Cfgr2 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Cfgr2")
                .field("ppre1", &self.ppre1())
                .field("ppre2", &self.ppre2())
                .field("ppre4", &self.ppre4())
                .field("ppre5", &self.ppre5())
                .field("hpre", &self.hpre())
                .field("timpre", &self.timpre())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Cfgr2 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Cfgr2 {{ ppre1: {:?}, ppre2: {:?}, ppre4: {:?}, ppre5: {:?}, hpre: {:?}, timpre: {:?} }}",
                self.ppre1(),
                self.ppre2(),
                self.ppre4(),
                self.ppre5(),
                self.hpre(),
                self.timpre()
            )
        }
    }
    #[doc = "RCC clock-source interrupt Clear register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cicr(pub u32);
    impl Cicr {
        #[doc = "LSI ready interrupt clear."]
        #[inline(always)]
        pub const fn lsirdyc(&self) -> super::vals::Lsirdyc {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Lsirdyc::from_bits(val as u8)
        }
        #[doc = "LSI ready interrupt clear."]
        #[inline(always)]
        pub fn set_lsirdyc(&mut self, val: super::vals::Lsirdyc) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "LSE ready interrupt clear."]
        #[inline(always)]
        pub const fn lserdyc(&self) -> super::vals::Lserdyc {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Lserdyc::from_bits(val as u8)
        }
        #[doc = "LSE ready interrupt clear."]
        #[inline(always)]
        pub fn set_lserdyc(&mut self, val: super::vals::Lserdyc) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "MSI ready interrupt clear."]
        #[inline(always)]
        pub const fn msirdyc(&self) -> super::vals::Msirdyc {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Msirdyc::from_bits(val as u8)
        }
        #[doc = "MSI ready interrupt clear."]
        #[inline(always)]
        pub fn set_msirdyc(&mut self, val: super::vals::Msirdyc) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "HSI ready interrupt clear."]
        #[inline(always)]
        pub const fn hsirdyc(&self) -> super::vals::Hsirdyc {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Hsirdyc::from_bits(val as u8)
        }
        #[doc = "HSI ready interrupt clear."]
        #[inline(always)]
        pub fn set_hsirdyc(&mut self, val: super::vals::Hsirdyc) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "HSE ready interrupt clear."]
        #[inline(always)]
        pub const fn hserdyc(&self) -> super::vals::Hserdyc {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Hserdyc::from_bits(val as u8)
        }
        #[doc = "HSE ready interrupt clear."]
        #[inline(always)]
        pub fn set_hserdyc(&mut self, val: super::vals::Hserdyc) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "PLL1 ready interrupt clear."]
        #[inline(always)]
        pub const fn pllrdyc(&self, n: usize) -> super::vals::Pllrdyc {
            assert!(n < 4usize);
            let offs = 8usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllrdyc::from_bits(val as u8)
        }
        #[doc = "PLL1 ready interrupt clear."]
        #[inline(always)]
        pub fn set_pllrdyc(&mut self, n: usize, val: super::vals::Pllrdyc) {
            assert!(n < 4usize);
            let offs = 8usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "LSE ready interrupt clear."]
        #[inline(always)]
        pub const fn lsecssc(&self) -> super::vals::Lsecssc {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::Lsecssc::from_bits(val as u8)
        }
        #[doc = "LSE ready interrupt clear."]
        #[inline(always)]
        pub fn set_lsecssc(&mut self, val: super::vals::Lsecssc) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
        #[doc = "HSE ready interrupt clear."]
        #[inline(always)]
        pub const fn hsecssc(&self) -> super::vals::Hsecssc {
            let val = (self.0 >> 17usize) & 0x01;
            super::vals::Hsecssc::from_bits(val as u8)
        }
        #[doc = "HSE ready interrupt clear."]
        #[inline(always)]
        pub fn set_hsecssc(&mut self, val: super::vals::Hsecssc) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
        }
        #[doc = "CPU Wakeup ready interrupt clear."]
        #[inline(always)]
        pub const fn wkupfc(&self) -> super::vals::Wkupfc {
            let val = (self.0 >> 24usize) & 0x01;
            super::vals::Wkupfc::from_bits(val as u8)
        }
        #[doc = "CPU Wakeup ready interrupt clear."]
        #[inline(always)]
        pub fn set_wkupfc(&mut self, val: super::vals::Wkupfc) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
        }
    }
    impl Default for Cicr {
        #[inline(always)]
        fn default() -> Cicr {
            Cicr(0)
        }
    }
    impl core::fmt::Debug for Cicr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Cicr")
                .field("lsirdyc", &self.lsirdyc())
                .field("lserdyc", &self.lserdyc())
                .field("msirdyc", &self.msirdyc())
                .field("hsirdyc", &self.hsirdyc())
                .field("hserdyc", &self.hserdyc())
                .field("pllrdyc[0]", &self.pllrdyc(0usize))
                .field("pllrdyc[1]", &self.pllrdyc(1usize))
                .field("pllrdyc[2]", &self.pllrdyc(2usize))
                .field("pllrdyc[3]", &self.pllrdyc(3usize))
                .field("lsecssc", &self.lsecssc())
                .field("hsecssc", &self.hsecssc())
                .field("wkupfc", &self.wkupfc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Cicr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Cicr {{ lsirdyc: {:?}, lserdyc: {:?}, msirdyc: {:?}, hsirdyc: {:?}, hserdyc: {:?}, pllrdyc[0]: {:?}, pllrdyc[1]: {:?}, pllrdyc[2]: {:?}, pllrdyc[3]: {:?}, lsecssc: {:?}, hsecssc: {:?}, wkupfc: {:?} }}" , self . lsirdyc () , self . lserdyc () , self . msirdyc () , self . hsirdyc () , self . hserdyc () , self . pllrdyc (0usize) , self . pllrdyc (1usize) , self . pllrdyc (2usize) , self . pllrdyc (3usize) , self . lsecssc () , self . hsecssc () , self . wkupfc ())
        }
    }
    #[doc = "RCC clock-source interrupt enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cier(pub u32);
    impl Cier {
        #[doc = "LSI ready interrupt enable."]
        #[inline(always)]
        pub const fn lsirdyie(&self) -> super::vals::Lsirdyie {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Lsirdyie::from_bits(val as u8)
        }
        #[doc = "LSI ready interrupt enable."]
        #[inline(always)]
        pub fn set_lsirdyie(&mut self, val: super::vals::Lsirdyie) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "LSE ready interrupt enable."]
        #[inline(always)]
        pub const fn lserdyie(&self) -> super::vals::Lserdyie {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Lserdyie::from_bits(val as u8)
        }
        #[doc = "LSE ready interrupt enable."]
        #[inline(always)]
        pub fn set_lserdyie(&mut self, val: super::vals::Lserdyie) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "MSI ready interrupt enable."]
        #[inline(always)]
        pub const fn msirdyie(&self) -> super::vals::Msirdyie {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Msirdyie::from_bits(val as u8)
        }
        #[doc = "MSI ready interrupt enable."]
        #[inline(always)]
        pub fn set_msirdyie(&mut self, val: super::vals::Msirdyie) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "HSI ready interrupt enable."]
        #[inline(always)]
        pub const fn hsirdyie(&self) -> super::vals::Hsirdyie {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Hsirdyie::from_bits(val as u8)
        }
        #[doc = "HSI ready interrupt enable."]
        #[inline(always)]
        pub fn set_hsirdyie(&mut self, val: super::vals::Hsirdyie) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "HSE ready interrupt enable."]
        #[inline(always)]
        pub const fn hserdyie(&self) -> super::vals::Hserdyie {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Hserdyie::from_bits(val as u8)
        }
        #[doc = "HSE ready interrupt enable."]
        #[inline(always)]
        pub fn set_hserdyie(&mut self, val: super::vals::Hserdyie) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "PLL1 ready interrupt enable."]
        #[inline(always)]
        pub const fn pllrdyie(&self, n: usize) -> super::vals::Pllrdyie {
            assert!(n < 4usize);
            let offs = 8usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllrdyie::from_bits(val as u8)
        }
        #[doc = "PLL1 ready interrupt enable."]
        #[inline(always)]
        pub fn set_pllrdyie(&mut self, n: usize, val: super::vals::Pllrdyie) {
            assert!(n < 4usize);
            let offs = 8usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "LSE clock security system (CSS) interrupt enable."]
        #[inline(always)]
        pub const fn lsecssie(&self) -> super::vals::Lsecssie {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::Lsecssie::from_bits(val as u8)
        }
        #[doc = "LSE clock security system (CSS) interrupt enable."]
        #[inline(always)]
        pub fn set_lsecssie(&mut self, val: super::vals::Lsecssie) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
        #[doc = "HSE clock security system (CSS) interrupt enable."]
        #[inline(always)]
        pub const fn hsecssie(&self) -> super::vals::Hsecssie {
            let val = (self.0 >> 17usize) & 0x01;
            super::vals::Hsecssie::from_bits(val as u8)
        }
        #[doc = "HSE clock security system (CSS) interrupt enable."]
        #[inline(always)]
        pub fn set_hsecssie(&mut self, val: super::vals::Hsecssie) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
        }
        #[doc = "CPU wakeup from Stop interrupt enable."]
        #[inline(always)]
        pub const fn wkupie(&self) -> super::vals::Wkupie {
            let val = (self.0 >> 24usize) & 0x01;
            super::vals::Wkupie::from_bits(val as u8)
        }
        #[doc = "CPU wakeup from Stop interrupt enable."]
        #[inline(always)]
        pub fn set_wkupie(&mut self, val: super::vals::Wkupie) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
        }
    }
    impl Default for Cier {
        #[inline(always)]
        fn default() -> Cier {
            Cier(0)
        }
    }
    impl core::fmt::Debug for Cier {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Cier")
                .field("lsirdyie", &self.lsirdyie())
                .field("lserdyie", &self.lserdyie())
                .field("msirdyie", &self.msirdyie())
                .field("hsirdyie", &self.hsirdyie())
                .field("hserdyie", &self.hserdyie())
                .field("pllrdyie[0]", &self.pllrdyie(0usize))
                .field("pllrdyie[1]", &self.pllrdyie(1usize))
                .field("pllrdyie[2]", &self.pllrdyie(2usize))
                .field("pllrdyie[3]", &self.pllrdyie(3usize))
                .field("lsecssie", &self.lsecssie())
                .field("hsecssie", &self.hsecssie())
                .field("wkupie", &self.wkupie())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Cier {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Cier {{ lsirdyie: {:?}, lserdyie: {:?}, msirdyie: {:?}, hsirdyie: {:?}, hserdyie: {:?}, pllrdyie[0]: {:?}, pllrdyie[1]: {:?}, pllrdyie[2]: {:?}, pllrdyie[3]: {:?}, lsecssie: {:?}, hsecssie: {:?}, wkupie: {:?} }}" , self . lsirdyie () , self . lserdyie () , self . msirdyie () , self . hsirdyie () , self . hserdyie () , self . pllrdyie (0usize) , self . pllrdyie (1usize) , self . pllrdyie (2usize) , self . pllrdyie (3usize) , self . lsecssie () , self . hsecssie () , self . wkupie ())
        }
    }
    #[doc = "RCC clock-source interrupt flag register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cifr(pub u32);
    impl Cifr {
        #[doc = "LSI ready interrupt flag."]
        #[inline(always)]
        pub const fn lsirdyf(&self) -> super::vals::Lsirdyf {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Lsirdyf::from_bits(val as u8)
        }
        #[doc = "LSI ready interrupt flag."]
        #[inline(always)]
        pub fn set_lsirdyf(&mut self, val: super::vals::Lsirdyf) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "LSE ready interrupt flag."]
        #[inline(always)]
        pub const fn lserdyf(&self) -> super::vals::Lserdyf {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Lserdyf::from_bits(val as u8)
        }
        #[doc = "LSE ready interrupt flag."]
        #[inline(always)]
        pub fn set_lserdyf(&mut self, val: super::vals::Lserdyf) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "MSI ready interrupt flag."]
        #[inline(always)]
        pub const fn msirdyf(&self) -> super::vals::Msirdyf {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Msirdyf::from_bits(val as u8)
        }
        #[doc = "MSI ready interrupt flag."]
        #[inline(always)]
        pub fn set_msirdyf(&mut self, val: super::vals::Msirdyf) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "HSI ready interrupt flag."]
        #[inline(always)]
        pub const fn hsirdyf(&self) -> super::vals::Hsirdyf {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Hsirdyf::from_bits(val as u8)
        }
        #[doc = "HSI ready interrupt flag."]
        #[inline(always)]
        pub fn set_hsirdyf(&mut self, val: super::vals::Hsirdyf) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "HSE ready interrupt flag."]
        #[inline(always)]
        pub const fn hserdyf(&self) -> super::vals::Hserdyf {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Hserdyf::from_bits(val as u8)
        }
        #[doc = "HSE ready interrupt flag."]
        #[inline(always)]
        pub fn set_hserdyf(&mut self, val: super::vals::Hserdyf) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "PLL1 ready interrupt flag."]
        #[inline(always)]
        pub const fn pllrdyf(&self, n: usize) -> super::vals::Pllrdyf {
            assert!(n < 4usize);
            let offs = 8usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllrdyf::from_bits(val as u8)
        }
        #[doc = "PLL1 ready interrupt flag."]
        #[inline(always)]
        pub fn set_pllrdyf(&mut self, n: usize, val: super::vals::Pllrdyf) {
            assert!(n < 4usize);
            let offs = 8usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "LSE ready interrupt flag."]
        #[inline(always)]
        pub const fn lsecssf(&self) -> super::vals::Lsecssf {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::Lsecssf::from_bits(val as u8)
        }
        #[doc = "LSE ready interrupt flag."]
        #[inline(always)]
        pub fn set_lsecssf(&mut self, val: super::vals::Lsecssf) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
        #[doc = "HSE ready interrupt flag."]
        #[inline(always)]
        pub const fn hsecssf(&self) -> super::vals::Hsecssf {
            let val = (self.0 >> 17usize) & 0x01;
            super::vals::Hsecssf::from_bits(val as u8)
        }
        #[doc = "HSE ready interrupt flag."]
        #[inline(always)]
        pub fn set_hsecssf(&mut self, val: super::vals::Hsecssf) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
        }
        #[doc = "CPU wakeup from Stop interrupt flag."]
        #[inline(always)]
        pub const fn wkupf(&self) -> super::vals::Wkupf {
            let val = (self.0 >> 24usize) & 0x01;
            super::vals::Wkupf::from_bits(val as u8)
        }
        #[doc = "CPU wakeup from Stop interrupt flag."]
        #[inline(always)]
        pub fn set_wkupf(&mut self, val: super::vals::Wkupf) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
        }
    }
    impl Default for Cifr {
        #[inline(always)]
        fn default() -> Cifr {
            Cifr(0)
        }
    }
    impl core::fmt::Debug for Cifr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Cifr")
                .field("lsirdyf", &self.lsirdyf())
                .field("lserdyf", &self.lserdyf())
                .field("msirdyf", &self.msirdyf())
                .field("hsirdyf", &self.hsirdyf())
                .field("hserdyf", &self.hserdyf())
                .field("pllrdyf[0]", &self.pllrdyf(0usize))
                .field("pllrdyf[1]", &self.pllrdyf(1usize))
                .field("pllrdyf[2]", &self.pllrdyf(2usize))
                .field("pllrdyf[3]", &self.pllrdyf(3usize))
                .field("lsecssf", &self.lsecssf())
                .field("hsecssf", &self.hsecssf())
                .field("wkupf", &self.wkupf())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Cifr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Cifr {{ lsirdyf: {:?}, lserdyf: {:?}, msirdyf: {:?}, hsirdyf: {:?}, hserdyf: {:?}, pllrdyf[0]: {:?}, pllrdyf[1]: {:?}, pllrdyf[2]: {:?}, pllrdyf[3]: {:?}, lsecssf: {:?}, hsecssf: {:?}, wkupf: {:?} }}" , self . lsirdyf () , self . lserdyf () , self . msirdyf () , self . hsirdyf () , self . hserdyf () , self . pllrdyf (0usize) , self . pllrdyf (1usize) , self . pllrdyf (2usize) , self . pllrdyf (3usize) , self . lsecssf () , self . hsecssf () , self . wkupf ())
        }
    }
    #[doc = "RCC clock protection register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ckprotr(pub u32);
    impl Ckprotr {
        #[doc = "XSPI3 clock selection current status."]
        #[inline(always)]
        pub const fn xspi3sels(&self) -> super::vals::Xspisels {
            let val = (self.0 >> 16usize) & 0x03;
            super::vals::Xspisels::from_bits(val as u8)
        }
        #[doc = "XSPI3 clock selection current status."]
        #[inline(always)]
        pub fn set_xspi3sels(&mut self, val: super::vals::Xspisels) {
            self.0 = (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
        }
        #[doc = "XSPI2 clock selection current status."]
        #[inline(always)]
        pub const fn xspi2sels(&self) -> super::vals::Xspisels {
            let val = (self.0 >> 20usize) & 0x03;
            super::vals::Xspisels::from_bits(val as u8)
        }
        #[doc = "XSPI2 clock selection current status."]
        #[inline(always)]
        pub fn set_xspi2sels(&mut self, val: super::vals::Xspisels) {
            self.0 = (self.0 & !(0x03 << 20usize)) | (((val.to_bits() as u32) & 0x03) << 20usize);
        }
        #[doc = "XSPI1 clock selection current status."]
        #[inline(always)]
        pub const fn xspi1sels(&self) -> super::vals::Xspisels {
            let val = (self.0 >> 24usize) & 0x03;
            super::vals::Xspisels::from_bits(val as u8)
        }
        #[doc = "XSPI1 clock selection current status."]
        #[inline(always)]
        pub fn set_xspi1sels(&mut self, val: super::vals::Xspisels) {
            self.0 = (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
        }
        #[doc = "FMC clock selection current status."]
        #[inline(always)]
        pub const fn fmcsels(&self) -> super::vals::Fmcsels {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Fmcsels::from_bits(val as u8)
        }
        #[doc = "FMC clock selection current status."]
        #[inline(always)]
        pub fn set_fmcsels(&mut self, val: super::vals::Fmcsels) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ckprotr {
        #[inline(always)]
        fn default() -> Ckprotr {
            Ckprotr(0)
        }
    }
    impl core::fmt::Debug for Ckprotr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ckprotr")
                .field("xspi3sels", &self.xspi3sels())
                .field("xspi2sels", &self.xspi2sels())
                .field("xspi1sels", &self.xspi1sels())
                .field("fmcsels", &self.fmcsels())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ckprotr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ckprotr {{ xspi3sels: {:?}, xspi2sels: {:?}, xspi1sels: {:?}, fmcsels: {:?} }}",
                self.xspi3sels(),
                self.xspi2sels(),
                self.xspi1sels(),
                self.fmcsels()
            )
        }
    }
    #[doc = "RCC control register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cr(pub u32);
    impl Cr {
        #[doc = "LSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn lsion(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "LSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_lsion(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "LSE oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn lseon(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "LSE oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_lseon(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "MSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn msion(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "MSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_msion(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "HSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn hsion(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "HSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_hsion(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "HSE oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn hseon(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "HSE oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_hseon(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "PLL1 enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn pllon(&self, n: usize) -> bool {
            assert!(n < 4usize);
            let offs = 8usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL1 enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_pllon(&mut self, n: usize, val: bool) {
            assert!(n < 4usize);
            let offs = 8usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Cr {
        #[inline(always)]
        fn default() -> Cr {
            Cr(0)
        }
    }
    impl core::fmt::Debug for Cr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Cr")
                .field("lsion", &self.lsion())
                .field("lseon", &self.lseon())
                .field("msion", &self.msion())
                .field("hsion", &self.hsion())
                .field("hseon", &self.hseon())
                .field("pllon[0]", &self.pllon(0usize))
                .field("pllon[1]", &self.pllon(1usize))
                .field("pllon[2]", &self.pllon(2usize))
                .field("pllon[3]", &self.pllon(3usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Cr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Cr {{ lsion: {=bool:?}, lseon: {=bool:?}, msion: {=bool:?}, hsion: {=bool:?}, hseon: {=bool:?}, pllon[0]: {=bool:?}, pllon[1]: {=bool:?}, pllon[2]: {=bool:?}, pllon[3]: {=bool:?} }}" , self . lsion () , self . lseon () , self . msion () , self . hsion () , self . hseon () , self . pllon (0usize) , self . pllon (1usize) , self . pllon (2usize) , self . pllon (3usize))
        }
    }
    #[doc = "RCC control set register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Csr(pub u32);
    impl Csr {
        #[doc = "LSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn lsions(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "LSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_lsions(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "LSE oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn lseons(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "LSE oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_lseons(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "MSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn msions(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "MSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_msions(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "HSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn hsions(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "HSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_hsions(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "HSE oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn hseons(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "HSE oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_hseons(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "PLL1 oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn pllons(&self, n: usize) -> bool {
            assert!(n < 4usize);
            let offs = 8usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL1 oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_pllons(&mut self, n: usize, val: bool) {
            assert!(n < 4usize);
            let offs = 8usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Csr {
        #[inline(always)]
        fn default() -> Csr {
            Csr(0)
        }
    }
    impl core::fmt::Debug for Csr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Csr")
                .field("lsions", &self.lsions())
                .field("lseons", &self.lseons())
                .field("msions", &self.msions())
                .field("hsions", &self.hsions())
                .field("hseons", &self.hseons())
                .field("pllons[0]", &self.pllons(0usize))
                .field("pllons[1]", &self.pllons(1usize))
                .field("pllons[2]", &self.pllons(2usize))
                .field("pllons[3]", &self.pllons(3usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Csr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Csr {{ lsions: {=bool:?}, lseons: {=bool:?}, msions: {=bool:?}, hsions: {=bool:?}, hseons: {=bool:?}, pllons[0]: {=bool:?}, pllons[1]: {=bool:?}, pllons[2]: {=bool:?}, pllons[3]: {=bool:?} }}" , self . lsions () , self . lseons () , self . msions () , self . hsions () , self . hseons () , self . pllons (0usize) , self . pllons (1usize) , self . pllons (2usize) , self . pllons (3usize))
        }
    }
    #[doc = "RCC divider enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Divencr(pub u32);
    impl Divencr {
        #[doc = "IC1 enable."]
        #[inline(always)]
        pub const fn ic1enc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "IC1 enable."]
        #[inline(always)]
        pub fn set_ic1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "IC2 enable."]
        #[inline(always)]
        pub const fn ic2enc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "IC2 enable."]
        #[inline(always)]
        pub fn set_ic2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "IC3 enable."]
        #[inline(always)]
        pub const fn ic3enc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "IC3 enable."]
        #[inline(always)]
        pub fn set_ic3enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "IC4 enable."]
        #[inline(always)]
        pub const fn ic4enc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "IC4 enable."]
        #[inline(always)]
        pub fn set_ic4enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "IC5 enable."]
        #[inline(always)]
        pub const fn ic5enc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "IC5 enable."]
        #[inline(always)]
        pub fn set_ic5enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "IC6 enable."]
        #[inline(always)]
        pub const fn ic6enc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "IC6 enable."]
        #[inline(always)]
        pub fn set_ic6enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "IC7 enable."]
        #[inline(always)]
        pub const fn ic7enc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "IC7 enable."]
        #[inline(always)]
        pub fn set_ic7enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "IC8 enable."]
        #[inline(always)]
        pub const fn ic8enc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "IC8 enable."]
        #[inline(always)]
        pub fn set_ic8enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "IC9 enable."]
        #[inline(always)]
        pub const fn ic9enc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "IC9 enable."]
        #[inline(always)]
        pub fn set_ic9enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "IC10 enable."]
        #[inline(always)]
        pub const fn ic10enc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "IC10 enable."]
        #[inline(always)]
        pub fn set_ic10enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "IC11 enable."]
        #[inline(always)]
        pub const fn ic11enc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IC11 enable."]
        #[inline(always)]
        pub fn set_ic11enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "IC12 enable."]
        #[inline(always)]
        pub const fn ic12enc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "IC12 enable."]
        #[inline(always)]
        pub fn set_ic12enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "IC13 enable."]
        #[inline(always)]
        pub const fn ic13enc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "IC13 enable."]
        #[inline(always)]
        pub fn set_ic13enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "IC14 enable."]
        #[inline(always)]
        pub const fn ic14enc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "IC14 enable."]
        #[inline(always)]
        pub fn set_ic14enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "IC15 enable."]
        #[inline(always)]
        pub const fn ic15enc(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "IC15 enable."]
        #[inline(always)]
        pub fn set_ic15enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "IC16 enable."]
        #[inline(always)]
        pub const fn ic16enc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "IC16 enable."]
        #[inline(always)]
        pub fn set_ic16enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "IC17 enable."]
        #[inline(always)]
        pub const fn ic17enc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "IC17 enable."]
        #[inline(always)]
        pub fn set_ic17enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "IC18 enable."]
        #[inline(always)]
        pub const fn ic18enc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "IC18 enable."]
        #[inline(always)]
        pub fn set_ic18enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "IC19 enable."]
        #[inline(always)]
        pub const fn ic19enc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "IC19 enable."]
        #[inline(always)]
        pub fn set_ic19enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "IC20 enable."]
        #[inline(always)]
        pub const fn ic20enc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "IC20 enable."]
        #[inline(always)]
        pub fn set_ic20enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Divencr {
        #[inline(always)]
        fn default() -> Divencr {
            Divencr(0)
        }
    }
    impl core::fmt::Debug for Divencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Divencr")
                .field("ic1enc", &self.ic1enc())
                .field("ic2enc", &self.ic2enc())
                .field("ic3enc", &self.ic3enc())
                .field("ic4enc", &self.ic4enc())
                .field("ic5enc", &self.ic5enc())
                .field("ic6enc", &self.ic6enc())
                .field("ic7enc", &self.ic7enc())
                .field("ic8enc", &self.ic8enc())
                .field("ic9enc", &self.ic9enc())
                .field("ic10enc", &self.ic10enc())
                .field("ic11enc", &self.ic11enc())
                .field("ic12enc", &self.ic12enc())
                .field("ic13enc", &self.ic13enc())
                .field("ic14enc", &self.ic14enc())
                .field("ic15enc", &self.ic15enc())
                .field("ic16enc", &self.ic16enc())
                .field("ic17enc", &self.ic17enc())
                .field("ic18enc", &self.ic18enc())
                .field("ic19enc", &self.ic19enc())
                .field("ic20enc", &self.ic20enc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Divencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Divencr {{ ic1enc: {=bool:?}, ic2enc: {=bool:?}, ic3enc: {=bool:?}, ic4enc: {=bool:?}, ic5enc: {=bool:?}, ic6enc: {=bool:?}, ic7enc: {=bool:?}, ic8enc: {=bool:?}, ic9enc: {=bool:?}, ic10enc: {=bool:?}, ic11enc: {=bool:?}, ic12enc: {=bool:?}, ic13enc: {=bool:?}, ic14enc: {=bool:?}, ic15enc: {=bool:?}, ic16enc: {=bool:?}, ic17enc: {=bool:?}, ic18enc: {=bool:?}, ic19enc: {=bool:?}, ic20enc: {=bool:?} }}" , self . ic1enc () , self . ic2enc () , self . ic3enc () , self . ic4enc () , self . ic5enc () , self . ic6enc () , self . ic7enc () , self . ic8enc () , self . ic9enc () , self . ic10enc () , self . ic11enc () , self . ic12enc () , self . ic13enc () , self . ic14enc () , self . ic15enc () , self . ic16enc () , self . ic17enc () , self . ic18enc () , self . ic19enc () , self . ic20enc ())
        }
    }
    #[doc = "RCC IC dividers enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Divenr(pub u32);
    impl Divenr {
        #[doc = "IC1 enable."]
        #[inline(always)]
        pub const fn ic1en(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "IC1 enable."]
        #[inline(always)]
        pub fn set_ic1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "IC2 enable."]
        #[inline(always)]
        pub const fn ic2en(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "IC2 enable."]
        #[inline(always)]
        pub fn set_ic2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "IC3 enable."]
        #[inline(always)]
        pub const fn ic3en(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "IC3 enable."]
        #[inline(always)]
        pub fn set_ic3en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "IC4 enable."]
        #[inline(always)]
        pub const fn ic4en(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "IC4 enable."]
        #[inline(always)]
        pub fn set_ic4en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "IC5 enable."]
        #[inline(always)]
        pub const fn ic5en(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "IC5 enable."]
        #[inline(always)]
        pub fn set_ic5en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "IC6 enable."]
        #[inline(always)]
        pub const fn ic6en(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "IC6 enable."]
        #[inline(always)]
        pub fn set_ic6en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "IC7 enable."]
        #[inline(always)]
        pub const fn ic7en(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "IC7 enable."]
        #[inline(always)]
        pub fn set_ic7en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "IC8 enable."]
        #[inline(always)]
        pub const fn ic8en(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "IC8 enable."]
        #[inline(always)]
        pub fn set_ic8en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "IC9 enable."]
        #[inline(always)]
        pub const fn ic9en(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "IC9 enable."]
        #[inline(always)]
        pub fn set_ic9en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "IC10 enable."]
        #[inline(always)]
        pub const fn ic10en(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "IC10 enable."]
        #[inline(always)]
        pub fn set_ic10en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "IC11 enable."]
        #[inline(always)]
        pub const fn ic11en(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IC11 enable."]
        #[inline(always)]
        pub fn set_ic11en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "IC12 enable."]
        #[inline(always)]
        pub const fn ic12en(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "IC12 enable."]
        #[inline(always)]
        pub fn set_ic12en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "IC13 enable."]
        #[inline(always)]
        pub const fn ic13en(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "IC13 enable."]
        #[inline(always)]
        pub fn set_ic13en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "IC14 enable."]
        #[inline(always)]
        pub const fn ic14en(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "IC14 enable."]
        #[inline(always)]
        pub fn set_ic14en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "IC15 enable."]
        #[inline(always)]
        pub const fn ic15en(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "IC15 enable."]
        #[inline(always)]
        pub fn set_ic15en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "IC16 enable."]
        #[inline(always)]
        pub const fn ic16en(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "IC16 enable."]
        #[inline(always)]
        pub fn set_ic16en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "IC17 enable."]
        #[inline(always)]
        pub const fn ic17en(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "IC17 enable."]
        #[inline(always)]
        pub fn set_ic17en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "IC18 enable."]
        #[inline(always)]
        pub const fn ic18en(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "IC18 enable."]
        #[inline(always)]
        pub fn set_ic18en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "IC19 enable."]
        #[inline(always)]
        pub const fn ic19en(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "IC19 enable."]
        #[inline(always)]
        pub fn set_ic19en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "IC20 enable."]
        #[inline(always)]
        pub const fn ic20en(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "IC20 enable."]
        #[inline(always)]
        pub fn set_ic20en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Divenr {
        #[inline(always)]
        fn default() -> Divenr {
            Divenr(0)
        }
    }
    impl core::fmt::Debug for Divenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Divenr")
                .field("ic1en", &self.ic1en())
                .field("ic2en", &self.ic2en())
                .field("ic3en", &self.ic3en())
                .field("ic4en", &self.ic4en())
                .field("ic5en", &self.ic5en())
                .field("ic6en", &self.ic6en())
                .field("ic7en", &self.ic7en())
                .field("ic8en", &self.ic8en())
                .field("ic9en", &self.ic9en())
                .field("ic10en", &self.ic10en())
                .field("ic11en", &self.ic11en())
                .field("ic12en", &self.ic12en())
                .field("ic13en", &self.ic13en())
                .field("ic14en", &self.ic14en())
                .field("ic15en", &self.ic15en())
                .field("ic16en", &self.ic16en())
                .field("ic17en", &self.ic17en())
                .field("ic18en", &self.ic18en())
                .field("ic19en", &self.ic19en())
                .field("ic20en", &self.ic20en())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Divenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Divenr {{ ic1en: {=bool:?}, ic2en: {=bool:?}, ic3en: {=bool:?}, ic4en: {=bool:?}, ic5en: {=bool:?}, ic6en: {=bool:?}, ic7en: {=bool:?}, ic8en: {=bool:?}, ic9en: {=bool:?}, ic10en: {=bool:?}, ic11en: {=bool:?}, ic12en: {=bool:?}, ic13en: {=bool:?}, ic14en: {=bool:?}, ic15en: {=bool:?}, ic16en: {=bool:?}, ic17en: {=bool:?}, ic18en: {=bool:?}, ic19en: {=bool:?}, ic20en: {=bool:?} }}" , self . ic1en () , self . ic2en () , self . ic3en () , self . ic4en () , self . ic5en () , self . ic6en () , self . ic7en () , self . ic8en () , self . ic9en () , self . ic10en () , self . ic11en () , self . ic12en () , self . ic13en () , self . ic14en () , self . ic15en () , self . ic16en () , self . ic17en () , self . ic18en () , self . ic19en () , self . ic20en ())
        }
    }
    #[doc = "RCC Divider enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Divensr(pub u32);
    impl Divensr {
        #[doc = "IC1 enable."]
        #[inline(always)]
        pub const fn ic1ens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "IC1 enable."]
        #[inline(always)]
        pub fn set_ic1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "IC2 enable."]
        #[inline(always)]
        pub const fn ic2ens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "IC2 enable."]
        #[inline(always)]
        pub fn set_ic2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "IC3 enable."]
        #[inline(always)]
        pub const fn ic3ens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "IC3 enable."]
        #[inline(always)]
        pub fn set_ic3ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "IC4 enable."]
        #[inline(always)]
        pub const fn ic4ens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "IC4 enable."]
        #[inline(always)]
        pub fn set_ic4ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "IC5 enable."]
        #[inline(always)]
        pub const fn ic5ens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "IC5 enable."]
        #[inline(always)]
        pub fn set_ic5ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "IC6 enable."]
        #[inline(always)]
        pub const fn ic6ens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "IC6 enable."]
        #[inline(always)]
        pub fn set_ic6ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "IC7 enable."]
        #[inline(always)]
        pub const fn ic7ens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "IC7 enable."]
        #[inline(always)]
        pub fn set_ic7ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "IC8 enable."]
        #[inline(always)]
        pub const fn ic8ens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "IC8 enable."]
        #[inline(always)]
        pub fn set_ic8ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "IC9 enable."]
        #[inline(always)]
        pub const fn ic9ens(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "IC9 enable."]
        #[inline(always)]
        pub fn set_ic9ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "IC10 enable."]
        #[inline(always)]
        pub const fn ic10ens(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "IC10 enable."]
        #[inline(always)]
        pub fn set_ic10ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "IC11 enable."]
        #[inline(always)]
        pub const fn ic11ens(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IC11 enable."]
        #[inline(always)]
        pub fn set_ic11ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "IC12 enable."]
        #[inline(always)]
        pub const fn ic12ens(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "IC12 enable."]
        #[inline(always)]
        pub fn set_ic12ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "IC13 enable."]
        #[inline(always)]
        pub const fn ic13ens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "IC13 enable."]
        #[inline(always)]
        pub fn set_ic13ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "IC14 enable."]
        #[inline(always)]
        pub const fn ic14ens(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "IC14 enable."]
        #[inline(always)]
        pub fn set_ic14ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "IC15 enable."]
        #[inline(always)]
        pub const fn ic15ens(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "IC15 enable."]
        #[inline(always)]
        pub fn set_ic15ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "IC16 enable."]
        #[inline(always)]
        pub const fn ic16ens(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "IC16 enable."]
        #[inline(always)]
        pub fn set_ic16ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "IC17 enable."]
        #[inline(always)]
        pub const fn ic17ens(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "IC17 enable."]
        #[inline(always)]
        pub fn set_ic17ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "IC18 enable."]
        #[inline(always)]
        pub const fn ic18ens(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "IC18 enable."]
        #[inline(always)]
        pub fn set_ic18ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "IC19 enable."]
        #[inline(always)]
        pub const fn ic19ens(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "IC19 enable."]
        #[inline(always)]
        pub fn set_ic19ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "IC20 enable."]
        #[inline(always)]
        pub const fn ic20ens(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "IC20 enable."]
        #[inline(always)]
        pub fn set_ic20ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Divensr {
        #[inline(always)]
        fn default() -> Divensr {
            Divensr(0)
        }
    }
    impl core::fmt::Debug for Divensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Divensr")
                .field("ic1ens", &self.ic1ens())
                .field("ic2ens", &self.ic2ens())
                .field("ic3ens", &self.ic3ens())
                .field("ic4ens", &self.ic4ens())
                .field("ic5ens", &self.ic5ens())
                .field("ic6ens", &self.ic6ens())
                .field("ic7ens", &self.ic7ens())
                .field("ic8ens", &self.ic8ens())
                .field("ic9ens", &self.ic9ens())
                .field("ic10ens", &self.ic10ens())
                .field("ic11ens", &self.ic11ens())
                .field("ic12ens", &self.ic12ens())
                .field("ic13ens", &self.ic13ens())
                .field("ic14ens", &self.ic14ens())
                .field("ic15ens", &self.ic15ens())
                .field("ic16ens", &self.ic16ens())
                .field("ic17ens", &self.ic17ens())
                .field("ic18ens", &self.ic18ens())
                .field("ic19ens", &self.ic19ens())
                .field("ic20ens", &self.ic20ens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Divensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Divensr {{ ic1ens: {=bool:?}, ic2ens: {=bool:?}, ic3ens: {=bool:?}, ic4ens: {=bool:?}, ic5ens: {=bool:?}, ic6ens: {=bool:?}, ic7ens: {=bool:?}, ic8ens: {=bool:?}, ic9ens: {=bool:?}, ic10ens: {=bool:?}, ic11ens: {=bool:?}, ic12ens: {=bool:?}, ic13ens: {=bool:?}, ic14ens: {=bool:?}, ic15ens: {=bool:?}, ic16ens: {=bool:?}, ic17ens: {=bool:?}, ic18ens: {=bool:?}, ic19ens: {=bool:?}, ic20ens: {=bool:?} }}" , self . ic1ens () , self . ic2ens () , self . ic3ens () , self . ic4ens () , self . ic5ens () , self . ic6ens () , self . ic7ens () , self . ic8ens () , self . ic9ens () , self . ic10ens () , self . ic11ens () , self . ic12ens () , self . ic13ens () , self . ic14ens () , self . ic15ens () , self . ic16ens () , self . ic17ens () , self . ic18ens () , self . ic19ens () , self . ic20ens ())
        }
    }
    #[doc = "RCC divider Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Divlpencr(pub u32);
    impl Divlpencr {
        #[doc = "IC1 sleep enable."]
        #[inline(always)]
        pub const fn ic1lpenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "IC1 sleep enable."]
        #[inline(always)]
        pub fn set_ic1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "IC2 sleep enable."]
        #[inline(always)]
        pub const fn ic2lpenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "IC2 sleep enable."]
        #[inline(always)]
        pub fn set_ic2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "IC3 sleep enable."]
        #[inline(always)]
        pub const fn ic3lpenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "IC3 sleep enable."]
        #[inline(always)]
        pub fn set_ic3lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "IC4 sleep enable."]
        #[inline(always)]
        pub const fn ic4lpenc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "IC4 sleep enable."]
        #[inline(always)]
        pub fn set_ic4lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "IC5 sleep enable."]
        #[inline(always)]
        pub const fn ic5lpenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "IC5 sleep enable."]
        #[inline(always)]
        pub fn set_ic5lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "IC6 sleep enable."]
        #[inline(always)]
        pub const fn ic6lpenc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "IC6 sleep enable."]
        #[inline(always)]
        pub fn set_ic6lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "IC7 sleep enable."]
        #[inline(always)]
        pub const fn ic7lpenc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "IC7 sleep enable."]
        #[inline(always)]
        pub fn set_ic7lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "IC8 sleep enable."]
        #[inline(always)]
        pub const fn ic8lpenc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "IC8 sleep enable."]
        #[inline(always)]
        pub fn set_ic8lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "IC9 sleep enable."]
        #[inline(always)]
        pub const fn ic9lpenc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "IC9 sleep enable."]
        #[inline(always)]
        pub fn set_ic9lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "IC10 sleep enable."]
        #[inline(always)]
        pub const fn ic10lpenc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "IC10 sleep enable."]
        #[inline(always)]
        pub fn set_ic10lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "IC11 sleep enable."]
        #[inline(always)]
        pub const fn ic11lpenc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IC11 sleep enable."]
        #[inline(always)]
        pub fn set_ic11lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "IC12 sleep enable."]
        #[inline(always)]
        pub const fn ic12lpenc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "IC12 sleep enable."]
        #[inline(always)]
        pub fn set_ic12lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "IC13 sleep enable."]
        #[inline(always)]
        pub const fn ic13lpenc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "IC13 sleep enable."]
        #[inline(always)]
        pub fn set_ic13lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "IC14 sleep enable."]
        #[inline(always)]
        pub const fn ic14lpenc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "IC14 sleep enable."]
        #[inline(always)]
        pub fn set_ic14lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "IC15 sleep enable."]
        #[inline(always)]
        pub const fn ic15lpenc(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "IC15 sleep enable."]
        #[inline(always)]
        pub fn set_ic15lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "IC16 sleep enable."]
        #[inline(always)]
        pub const fn ic16lpenc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "IC16 sleep enable."]
        #[inline(always)]
        pub fn set_ic16lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "IC17 sleep enable."]
        #[inline(always)]
        pub const fn ic17lpenc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "IC17 sleep enable."]
        #[inline(always)]
        pub fn set_ic17lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "IC18 sleep enable."]
        #[inline(always)]
        pub const fn ic18lpenc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "IC18 sleep enable."]
        #[inline(always)]
        pub fn set_ic18lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "IC19 sleep enable."]
        #[inline(always)]
        pub const fn ic19lpenc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "IC19 sleep enable."]
        #[inline(always)]
        pub fn set_ic19lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "IC20 sleep enable."]
        #[inline(always)]
        pub const fn ic20lpenc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "IC20 sleep enable."]
        #[inline(always)]
        pub fn set_ic20lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Divlpencr {
        #[inline(always)]
        fn default() -> Divlpencr {
            Divlpencr(0)
        }
    }
    impl core::fmt::Debug for Divlpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Divlpencr")
                .field("ic1lpenc", &self.ic1lpenc())
                .field("ic2lpenc", &self.ic2lpenc())
                .field("ic3lpenc", &self.ic3lpenc())
                .field("ic4lpenc", &self.ic4lpenc())
                .field("ic5lpenc", &self.ic5lpenc())
                .field("ic6lpenc", &self.ic6lpenc())
                .field("ic7lpenc", &self.ic7lpenc())
                .field("ic8lpenc", &self.ic8lpenc())
                .field("ic9lpenc", &self.ic9lpenc())
                .field("ic10lpenc", &self.ic10lpenc())
                .field("ic11lpenc", &self.ic11lpenc())
                .field("ic12lpenc", &self.ic12lpenc())
                .field("ic13lpenc", &self.ic13lpenc())
                .field("ic14lpenc", &self.ic14lpenc())
                .field("ic15lpenc", &self.ic15lpenc())
                .field("ic16lpenc", &self.ic16lpenc())
                .field("ic17lpenc", &self.ic17lpenc())
                .field("ic18lpenc", &self.ic18lpenc())
                .field("ic19lpenc", &self.ic19lpenc())
                .field("ic20lpenc", &self.ic20lpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Divlpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Divlpencr {{ ic1lpenc: {=bool:?}, ic2lpenc: {=bool:?}, ic3lpenc: {=bool:?}, ic4lpenc: {=bool:?}, ic5lpenc: {=bool:?}, ic6lpenc: {=bool:?}, ic7lpenc: {=bool:?}, ic8lpenc: {=bool:?}, ic9lpenc: {=bool:?}, ic10lpenc: {=bool:?}, ic11lpenc: {=bool:?}, ic12lpenc: {=bool:?}, ic13lpenc: {=bool:?}, ic14lpenc: {=bool:?}, ic15lpenc: {=bool:?}, ic16lpenc: {=bool:?}, ic17lpenc: {=bool:?}, ic18lpenc: {=bool:?}, ic19lpenc: {=bool:?}, ic20lpenc: {=bool:?} }}" , self . ic1lpenc () , self . ic2lpenc () , self . ic3lpenc () , self . ic4lpenc () , self . ic5lpenc () , self . ic6lpenc () , self . ic7lpenc () , self . ic8lpenc () , self . ic9lpenc () , self . ic10lpenc () , self . ic11lpenc () , self . ic12lpenc () , self . ic13lpenc () , self . ic14lpenc () , self . ic15lpenc () , self . ic16lpenc () , self . ic17lpenc () , self . ic18lpenc () , self . ic19lpenc () , self . ic20lpenc ())
        }
    }
    #[doc = "RCC dividers Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Divlpenr(pub u32);
    impl Divlpenr {
        #[doc = "IC1 sleep enable."]
        #[inline(always)]
        pub const fn ic1lpen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "IC1 sleep enable."]
        #[inline(always)]
        pub fn set_ic1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "IC2 sleep enable."]
        #[inline(always)]
        pub const fn ic2lpen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "IC2 sleep enable."]
        #[inline(always)]
        pub fn set_ic2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "IC3 sleep enable."]
        #[inline(always)]
        pub const fn ic3lpen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "IC3 sleep enable."]
        #[inline(always)]
        pub fn set_ic3lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "IC4 sleep enable."]
        #[inline(always)]
        pub const fn ic4lpen(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "IC4 sleep enable."]
        #[inline(always)]
        pub fn set_ic4lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "IC5 sleep enable."]
        #[inline(always)]
        pub const fn ic5lpen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "IC5 sleep enable."]
        #[inline(always)]
        pub fn set_ic5lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "IC6 sleep enable."]
        #[inline(always)]
        pub const fn ic6lpen(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "IC6 sleep enable."]
        #[inline(always)]
        pub fn set_ic6lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "IC7 sleep enable."]
        #[inline(always)]
        pub const fn ic7lpen(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "IC7 sleep enable."]
        #[inline(always)]
        pub fn set_ic7lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "IC8 sleep enable."]
        #[inline(always)]
        pub const fn ic8lpen(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "IC8 sleep enable."]
        #[inline(always)]
        pub fn set_ic8lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "IC9 sleep enable."]
        #[inline(always)]
        pub const fn ic9lpen(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "IC9 sleep enable."]
        #[inline(always)]
        pub fn set_ic9lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "IC10 sleep enable."]
        #[inline(always)]
        pub const fn ic10lpen(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "IC10 sleep enable."]
        #[inline(always)]
        pub fn set_ic10lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "IC11 sleep enable."]
        #[inline(always)]
        pub const fn ic11lpen(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IC11 sleep enable."]
        #[inline(always)]
        pub fn set_ic11lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "IC12 sleep enable."]
        #[inline(always)]
        pub const fn ic12lpen(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "IC12 sleep enable."]
        #[inline(always)]
        pub fn set_ic12lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "IC13 sleep enable."]
        #[inline(always)]
        pub const fn ic13lpen(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "IC13 sleep enable."]
        #[inline(always)]
        pub fn set_ic13lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "IC14 sleep enable."]
        #[inline(always)]
        pub const fn ic14lpen(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "IC14 sleep enable."]
        #[inline(always)]
        pub fn set_ic14lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "IC15 sleep enable."]
        #[inline(always)]
        pub const fn ic15lpen(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "IC15 sleep enable."]
        #[inline(always)]
        pub fn set_ic15lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "IC16 sleep enable."]
        #[inline(always)]
        pub const fn ic16lpen(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "IC16 sleep enable."]
        #[inline(always)]
        pub fn set_ic16lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "IC17 sleep enable."]
        #[inline(always)]
        pub const fn ic17lpen(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "IC17 sleep enable."]
        #[inline(always)]
        pub fn set_ic17lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "IC18 sleep enable."]
        #[inline(always)]
        pub const fn ic18lpen(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "IC18 sleep enable."]
        #[inline(always)]
        pub fn set_ic18lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "IC19 sleep enable."]
        #[inline(always)]
        pub const fn ic19lpen(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "IC19 sleep enable."]
        #[inline(always)]
        pub fn set_ic19lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "IC20 sleep enable."]
        #[inline(always)]
        pub const fn ic20lpen(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "IC20 sleep enable."]
        #[inline(always)]
        pub fn set_ic20lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Divlpenr {
        #[inline(always)]
        fn default() -> Divlpenr {
            Divlpenr(0)
        }
    }
    impl core::fmt::Debug for Divlpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Divlpenr")
                .field("ic1lpen", &self.ic1lpen())
                .field("ic2lpen", &self.ic2lpen())
                .field("ic3lpen", &self.ic3lpen())
                .field("ic4lpen", &self.ic4lpen())
                .field("ic5lpen", &self.ic5lpen())
                .field("ic6lpen", &self.ic6lpen())
                .field("ic7lpen", &self.ic7lpen())
                .field("ic8lpen", &self.ic8lpen())
                .field("ic9lpen", &self.ic9lpen())
                .field("ic10lpen", &self.ic10lpen())
                .field("ic11lpen", &self.ic11lpen())
                .field("ic12lpen", &self.ic12lpen())
                .field("ic13lpen", &self.ic13lpen())
                .field("ic14lpen", &self.ic14lpen())
                .field("ic15lpen", &self.ic15lpen())
                .field("ic16lpen", &self.ic16lpen())
                .field("ic17lpen", &self.ic17lpen())
                .field("ic18lpen", &self.ic18lpen())
                .field("ic19lpen", &self.ic19lpen())
                .field("ic20lpen", &self.ic20lpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Divlpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Divlpenr {{ ic1lpen: {=bool:?}, ic2lpen: {=bool:?}, ic3lpen: {=bool:?}, ic4lpen: {=bool:?}, ic5lpen: {=bool:?}, ic6lpen: {=bool:?}, ic7lpen: {=bool:?}, ic8lpen: {=bool:?}, ic9lpen: {=bool:?}, ic10lpen: {=bool:?}, ic11lpen: {=bool:?}, ic12lpen: {=bool:?}, ic13lpen: {=bool:?}, ic14lpen: {=bool:?}, ic15lpen: {=bool:?}, ic16lpen: {=bool:?}, ic17lpen: {=bool:?}, ic18lpen: {=bool:?}, ic19lpen: {=bool:?}, ic20lpen: {=bool:?} }}" , self . ic1lpen () , self . ic2lpen () , self . ic3lpen () , self . ic4lpen () , self . ic5lpen () , self . ic6lpen () , self . ic7lpen () , self . ic8lpen () , self . ic9lpen () , self . ic10lpen () , self . ic11lpen () , self . ic12lpen () , self . ic13lpen () , self . ic14lpen () , self . ic15lpen () , self . ic16lpen () , self . ic17lpen () , self . ic18lpen () , self . ic19lpen () , self . ic20lpen ())
        }
    }
    #[doc = "RCC divider Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Divlpensr(pub u32);
    impl Divlpensr {
        #[doc = "IC1 sleep enable."]
        #[inline(always)]
        pub const fn ic1lpens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "IC1 sleep enable."]
        #[inline(always)]
        pub fn set_ic1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "IC2 sleep enable."]
        #[inline(always)]
        pub const fn ic2lpens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "IC2 sleep enable."]
        #[inline(always)]
        pub fn set_ic2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "IC3 sleep enable."]
        #[inline(always)]
        pub const fn ic3lpens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "IC3 sleep enable."]
        #[inline(always)]
        pub fn set_ic3lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "IC4 sleep enable."]
        #[inline(always)]
        pub const fn ic4lpens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "IC4 sleep enable."]
        #[inline(always)]
        pub fn set_ic4lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "IC5 sleep enable."]
        #[inline(always)]
        pub const fn ic5lpens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "IC5 sleep enable."]
        #[inline(always)]
        pub fn set_ic5lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "IC6 sleep enable."]
        #[inline(always)]
        pub const fn ic6lpens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "IC6 sleep enable."]
        #[inline(always)]
        pub fn set_ic6lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "IC7 sleep enable."]
        #[inline(always)]
        pub const fn ic7lpens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "IC7 sleep enable."]
        #[inline(always)]
        pub fn set_ic7lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "IC8 sleep enable."]
        #[inline(always)]
        pub const fn ic8lpens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "IC8 sleep enable."]
        #[inline(always)]
        pub fn set_ic8lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "IC9 sleep enable."]
        #[inline(always)]
        pub const fn ic9lpens(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "IC9 sleep enable."]
        #[inline(always)]
        pub fn set_ic9lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "IC10 sleep enable."]
        #[inline(always)]
        pub const fn ic10lpens(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "IC10 sleep enable."]
        #[inline(always)]
        pub fn set_ic10lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "IC11 sleep enable."]
        #[inline(always)]
        pub const fn ic11lpens(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "IC11 sleep enable."]
        #[inline(always)]
        pub fn set_ic11lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "IC12 sleep enable."]
        #[inline(always)]
        pub const fn ic12lpens(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "IC12 sleep enable."]
        #[inline(always)]
        pub fn set_ic12lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "IC13 sleep enable."]
        #[inline(always)]
        pub const fn ic13lpens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "IC13 sleep enable."]
        #[inline(always)]
        pub fn set_ic13lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "IC14 sleep enable."]
        #[inline(always)]
        pub const fn ic14lpens(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "IC14 sleep enable."]
        #[inline(always)]
        pub fn set_ic14lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "IC15 sleep enable."]
        #[inline(always)]
        pub const fn ic15lpens(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "IC15 sleep enable."]
        #[inline(always)]
        pub fn set_ic15lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "IC16 sleep enable."]
        #[inline(always)]
        pub const fn ic16lpens(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "IC16 sleep enable."]
        #[inline(always)]
        pub fn set_ic16lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "IC17 sleep enable."]
        #[inline(always)]
        pub const fn ic17lpens(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "IC17 sleep enable."]
        #[inline(always)]
        pub fn set_ic17lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "IC18 sleep enable."]
        #[inline(always)]
        pub const fn ic18lpens(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "IC18 sleep enable."]
        #[inline(always)]
        pub fn set_ic18lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "IC19 sleep enable."]
        #[inline(always)]
        pub const fn ic19lpens(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "IC19 sleep enable."]
        #[inline(always)]
        pub fn set_ic19lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "IC20 sleep enable."]
        #[inline(always)]
        pub const fn ic20lpens(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "IC20 sleep enable."]
        #[inline(always)]
        pub fn set_ic20lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Divlpensr {
        #[inline(always)]
        fn default() -> Divlpensr {
            Divlpensr(0)
        }
    }
    impl core::fmt::Debug for Divlpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Divlpensr")
                .field("ic1lpens", &self.ic1lpens())
                .field("ic2lpens", &self.ic2lpens())
                .field("ic3lpens", &self.ic3lpens())
                .field("ic4lpens", &self.ic4lpens())
                .field("ic5lpens", &self.ic5lpens())
                .field("ic6lpens", &self.ic6lpens())
                .field("ic7lpens", &self.ic7lpens())
                .field("ic8lpens", &self.ic8lpens())
                .field("ic9lpens", &self.ic9lpens())
                .field("ic10lpens", &self.ic10lpens())
                .field("ic11lpens", &self.ic11lpens())
                .field("ic12lpens", &self.ic12lpens())
                .field("ic13lpens", &self.ic13lpens())
                .field("ic14lpens", &self.ic14lpens())
                .field("ic15lpens", &self.ic15lpens())
                .field("ic16lpens", &self.ic16lpens())
                .field("ic17lpens", &self.ic17lpens())
                .field("ic18lpens", &self.ic18lpens())
                .field("ic19lpens", &self.ic19lpens())
                .field("ic20lpens", &self.ic20lpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Divlpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Divlpensr {{ ic1lpens: {=bool:?}, ic2lpens: {=bool:?}, ic3lpens: {=bool:?}, ic4lpens: {=bool:?}, ic5lpens: {=bool:?}, ic6lpens: {=bool:?}, ic7lpens: {=bool:?}, ic8lpens: {=bool:?}, ic9lpens: {=bool:?}, ic10lpens: {=bool:?}, ic11lpens: {=bool:?}, ic12lpens: {=bool:?}, ic13lpens: {=bool:?}, ic14lpens: {=bool:?}, ic15lpens: {=bool:?}, ic16lpens: {=bool:?}, ic17lpens: {=bool:?}, ic18lpens: {=bool:?}, ic19lpens: {=bool:?}, ic20lpens: {=bool:?} }}" , self . ic1lpens () , self . ic2lpens () , self . ic3lpens () , self . ic4lpens () , self . ic5lpens () , self . ic6lpens () , self . ic7lpens () , self . ic8lpens () , self . ic9lpens () , self . ic10lpens () , self . ic11lpens () , self . ic12lpens () , self . ic13lpens () , self . ic14lpens () , self . ic15lpens () , self . ic16lpens () , self . ic17lpens () , self . ic18lpens () , self . ic19lpens () , self . ic20lpens ())
        }
    }
    #[doc = "RCC HSE configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Hsecfgr(pub u32);
    impl Hsecfgr {
        #[doc = "HSE div2 oscillator clock in Bypass mode."]
        #[inline(always)]
        pub const fn hsediv2byp(&self) -> super::vals::Hsedivbyp {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Hsedivbyp::from_bits(val as u8)
        }
        #[doc = "HSE div2 oscillator clock in Bypass mode."]
        #[inline(always)]
        pub fn set_hsediv2byp(&mut self, val: super::vals::Hsedivbyp) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
        #[doc = "HSE clock security system (CSS) enable."]
        #[inline(always)]
        pub const fn hsecsson(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "HSE clock security system (CSS) enable."]
        #[inline(always)]
        pub fn set_hsecsson(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "HSE clock security system (CSS) re-arm function."]
        #[inline(always)]
        pub const fn hsecssra(&self) -> super::vals::Hsecssra {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Hsecssra::from_bits(val as u8)
        }
        #[doc = "HSE clock security system (CSS) re-arm function."]
        #[inline(always)]
        pub fn set_hsecssra(&mut self, val: super::vals::Hsecssra) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
        #[doc = "HSE clock security system (CSS) failure detection."]
        #[inline(always)]
        pub const fn hsecssd(&self) -> super::vals::Hsecssd {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Hsecssd::from_bits(val as u8)
        }
        #[doc = "HSE clock security system (CSS) failure detection."]
        #[inline(always)]
        pub fn set_hsecssd(&mut self, val: super::vals::Hsecssd) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
        #[doc = "HSE clock security system (CSS) bypass enable."]
        #[inline(always)]
        pub const fn hsecssbyp(&self) -> super::vals::Hsecssbyp {
            let val = (self.0 >> 10usize) & 0x01;
            super::vals::Hsecssbyp::from_bits(val as u8)
        }
        #[doc = "HSE clock security system (CSS) bypass enable."]
        #[inline(always)]
        pub fn set_hsecssbyp(&mut self, val: super::vals::Hsecssbyp) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
        }
        #[doc = "HSE clock security system (CSS) bypass divider."]
        #[inline(always)]
        pub const fn hsecssbpre(&self) -> super::vals::Hsecssbpre {
            let val = (self.0 >> 11usize) & 0x0f;
            super::vals::Hsecssbpre::from_bits(val as u8)
        }
        #[doc = "HSE clock security system (CSS) bypass divider."]
        #[inline(always)]
        pub fn set_hsecssbpre(&mut self, val: super::vals::Hsecssbpre) {
            self.0 = (self.0 & !(0x0f << 11usize)) | (((val.to_bits() as u32) & 0x0f) << 11usize);
        }
        #[doc = "HSE clock bypass."]
        #[inline(always)]
        pub const fn hsebyp(&self) -> super::vals::Hsebyp {
            let val = (self.0 >> 15usize) & 0x01;
            super::vals::Hsebyp::from_bits(val as u8)
        }
        #[doc = "HSE clock bypass."]
        #[inline(always)]
        pub fn set_hsebyp(&mut self, val: super::vals::Hsebyp) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
        }
        #[doc = "HSE clock type in Bypass mode."]
        #[inline(always)]
        pub const fn hseext(&self) -> super::vals::Hseext {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::Hseext::from_bits(val as u8)
        }
        #[doc = "HSE clock type in Bypass mode."]
        #[inline(always)]
        pub fn set_hseext(&mut self, val: super::vals::Hseext) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
        #[doc = "HSE clock glitch filter enable."]
        #[inline(always)]
        pub const fn hsegfon(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "HSE clock glitch filter enable."]
        #[inline(always)]
        pub fn set_hsegfon(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "HSE oscillator driving capability."]
        #[inline(always)]
        pub const fn hsedrv(&self) -> super::vals::Hsedrv {
            let val = (self.0 >> 18usize) & 0x03;
            super::vals::Hsedrv::from_bits(val as u8)
        }
        #[doc = "HSE oscillator driving capability."]
        #[inline(always)]
        pub fn set_hsedrv(&mut self, val: super::vals::Hsedrv) {
            self.0 = (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
        }
    }
    impl Default for Hsecfgr {
        #[inline(always)]
        fn default() -> Hsecfgr {
            Hsecfgr(0)
        }
    }
    impl core::fmt::Debug for Hsecfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Hsecfgr")
                .field("hsediv2byp", &self.hsediv2byp())
                .field("hsecsson", &self.hsecsson())
                .field("hsecssra", &self.hsecssra())
                .field("hsecssd", &self.hsecssd())
                .field("hsecssbyp", &self.hsecssbyp())
                .field("hsecssbpre", &self.hsecssbpre())
                .field("hsebyp", &self.hsebyp())
                .field("hseext", &self.hseext())
                .field("hsegfon", &self.hsegfon())
                .field("hsedrv", &self.hsedrv())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Hsecfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Hsecfgr {{ hsediv2byp: {:?}, hsecsson: {=bool:?}, hsecssra: {:?}, hsecssd: {:?}, hsecssbyp: {:?}, hsecssbpre: {:?}, hsebyp: {:?}, hseext: {:?}, hsegfon: {=bool:?}, hsedrv: {:?} }}" , self . hsediv2byp () , self . hsecsson () , self . hsecssra () , self . hsecssd () , self . hsecssbyp () , self . hsecssbpre () , self . hsebyp () , self . hseext () , self . hsegfon () , self . hsedrv ())
        }
    }
    #[doc = "RCC HSI configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Hsicfgr(pub u32);
    impl Hsicfgr {
        #[doc = "HSI clock divider."]
        #[inline(always)]
        pub const fn hsidiv(&self) -> super::vals::Hsidiv {
            let val = (self.0 >> 7usize) & 0x03;
            super::vals::Hsidiv::from_bits(val as u8)
        }
        #[doc = "HSI clock divider."]
        #[inline(always)]
        pub fn set_hsidiv(&mut self, val: super::vals::Hsidiv) {
            self.0 = (self.0 & !(0x03 << 7usize)) | (((val.to_bits() as u32) & 0x03) << 7usize);
        }
        #[doc = "HSI clock trimming."]
        #[inline(always)]
        pub const fn hsitrim(&self) -> super::vals::Hsitrim {
            let val = (self.0 >> 16usize) & 0x7f;
            super::vals::Hsitrim::from_bits(val as u8)
        }
        #[doc = "HSI clock trimming."]
        #[inline(always)]
        pub fn set_hsitrim(&mut self, val: super::vals::Hsitrim) {
            self.0 = (self.0 & !(0x7f << 16usize)) | (((val.to_bits() as u32) & 0x7f) << 16usize);
        }
        #[doc = "HSI clock calibration."]
        #[inline(always)]
        pub const fn hsical(&self) -> u16 {
            let val = (self.0 >> 23usize) & 0x01ff;
            val as u16
        }
        #[doc = "HSI clock calibration."]
        #[inline(always)]
        pub fn set_hsical(&mut self, val: u16) {
            self.0 = (self.0 & !(0x01ff << 23usize)) | (((val as u32) & 0x01ff) << 23usize);
        }
    }
    impl Default for Hsicfgr {
        #[inline(always)]
        fn default() -> Hsicfgr {
            Hsicfgr(0)
        }
    }
    impl core::fmt::Debug for Hsicfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Hsicfgr")
                .field("hsidiv", &self.hsidiv())
                .field("hsitrim", &self.hsitrim())
                .field("hsical", &self.hsical())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Hsicfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Hsicfgr {{ hsidiv: {:?}, hsitrim: {:?}, hsical: {=u16:?} }}",
                self.hsidiv(),
                self.hsitrim(),
                self.hsical()
            )
        }
    }
    #[doc = "RCC HSI monitor control register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Hsimcr(pub u32);
    impl Hsimcr {
        #[doc = "HSI clock cycle counter reference value."]
        #[inline(always)]
        pub const fn hsiref(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0x07ff;
            val as u16
        }
        #[doc = "HSI clock cycle counter reference value."]
        #[inline(always)]
        pub fn set_hsiref(&mut self, val: u16) {
            self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
        }
        #[doc = "HSI clock count deviation value."]
        #[inline(always)]
        pub const fn hsidev(&self) -> u8 {
            let val = (self.0 >> 16usize) & 0x3f;
            val as u8
        }
        #[doc = "HSI clock count deviation value."]
        #[inline(always)]
        pub fn set_hsidev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x3f << 16usize)) | (((val as u32) & 0x3f) << 16usize);
        }
        #[doc = "HSI clock period monitor enable."]
        #[inline(always)]
        pub const fn hsimonen(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "HSI clock period monitor enable."]
        #[inline(always)]
        pub fn set_hsimonen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Hsimcr {
        #[inline(always)]
        fn default() -> Hsimcr {
            Hsimcr(0)
        }
    }
    impl core::fmt::Debug for Hsimcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Hsimcr")
                .field("hsiref", &self.hsiref())
                .field("hsidev", &self.hsidev())
                .field("hsimonen", &self.hsimonen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Hsimcr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Hsimcr {{ hsiref: {=u16:?}, hsidev: {=u8:?}, hsimonen: {=bool:?} }}",
                self.hsiref(),
                self.hsidev(),
                self.hsimonen()
            )
        }
    }
    #[doc = "RCC HSI monitor status register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Hsimsr(pub u32);
    impl Hsimsr {
        #[doc = "HSI clock cycle counter measured value."]
        #[inline(always)]
        pub const fn hsival(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0x07ff;
            val as u16
        }
        #[doc = "HSI clock cycle counter measured value."]
        #[inline(always)]
        pub fn set_hsival(&mut self, val: u16) {
            self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
        }
    }
    impl Default for Hsimsr {
        #[inline(always)]
        fn default() -> Hsimsr {
            Hsimsr(0)
        }
    }
    impl core::fmt::Debug for Hsimsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Hsimsr").field("hsival", &self.hsival()).finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Hsimsr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(f, "Hsimsr {{ hsival: {=u16:?} }}", self.hsival())
        }
    }
    #[doc = "RCC reset status register for hardware."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Hwrsr(pub u32);
    impl Hwrsr {
        #[doc = "Remove reset flag."]
        #[inline(always)]
        pub const fn rmvf(&self) -> super::vals::HwrsrRmvf {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::HwrsrRmvf::from_bits(val as u8)
        }
        #[doc = "Remove reset flag."]
        #[inline(always)]
        pub fn set_rmvf(&mut self, val: super::vals::HwrsrRmvf) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
        #[doc = "CPU lockup reset flag."]
        #[inline(always)]
        pub const fn lckrstf(&self) -> super::vals::HwrsrLckrstf {
            let val = (self.0 >> 17usize) & 0x01;
            super::vals::HwrsrLckrstf::from_bits(val as u8)
        }
        #[doc = "CPU lockup reset flag."]
        #[inline(always)]
        pub fn set_lckrstf(&mut self, val: super::vals::HwrsrLckrstf) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
        }
        #[doc = "BOR flag."]
        #[inline(always)]
        pub const fn borrstf(&self) -> super::vals::HwrsrBorrstf {
            let val = (self.0 >> 21usize) & 0x01;
            super::vals::HwrsrBorrstf::from_bits(val as u8)
        }
        #[doc = "BOR flag."]
        #[inline(always)]
        pub fn set_borrstf(&mut self, val: super::vals::HwrsrBorrstf) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
        }
        #[doc = "Pin reset flag (NRST)."]
        #[inline(always)]
        pub const fn pinrstf(&self) -> super::vals::HwrsrPinrstf {
            let val = (self.0 >> 22usize) & 0x01;
            super::vals::HwrsrPinrstf::from_bits(val as u8)
        }
        #[doc = "Pin reset flag (NRST)."]
        #[inline(always)]
        pub fn set_pinrstf(&mut self, val: super::vals::HwrsrPinrstf) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
        }
        #[doc = "POR/PDR flag."]
        #[inline(always)]
        pub const fn porrstf(&self) -> super::vals::HwrsrPorrstf {
            let val = (self.0 >> 23usize) & 0x01;
            super::vals::HwrsrPorrstf::from_bits(val as u8)
        }
        #[doc = "POR/PDR flag."]
        #[inline(always)]
        pub fn set_porrstf(&mut self, val: super::vals::HwrsrPorrstf) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
        }
        #[doc = "Software system reset flag (1)."]
        #[inline(always)]
        pub const fn sftrstf(&self) -> super::vals::HwrsrSftrstf {
            let val = (self.0 >> 24usize) & 0x01;
            super::vals::HwrsrSftrstf::from_bits(val as u8)
        }
        #[doc = "Software system reset flag (1)."]
        #[inline(always)]
        pub fn set_sftrstf(&mut self, val: super::vals::HwrsrSftrstf) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
        }
        #[doc = "Independent Watchdog reset flag."]
        #[inline(always)]
        pub const fn iwdgrstf(&self) -> super::vals::HwrsrIwdgrstf {
            let val = (self.0 >> 26usize) & 0x01;
            super::vals::HwrsrIwdgrstf::from_bits(val as u8)
        }
        #[doc = "Independent Watchdog reset flag."]
        #[inline(always)]
        pub fn set_iwdgrstf(&mut self, val: super::vals::HwrsrIwdgrstf) {
            self.0 = (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
        }
        #[doc = "Window watchdog reset flag."]
        #[inline(always)]
        pub const fn wwdgrstf(&self) -> super::vals::HwrsrWwdgrstf {
            let val = (self.0 >> 28usize) & 0x01;
            super::vals::HwrsrWwdgrstf::from_bits(val as u8)
        }
        #[doc = "Window watchdog reset flag."]
        #[inline(always)]
        pub fn set_wwdgrstf(&mut self, val: super::vals::HwrsrWwdgrstf) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
        }
        #[doc = "Illegal Stop or Standby flag."]
        #[inline(always)]
        pub const fn lpwrrstf(&self) -> super::vals::HwrsrLpwrrstf {
            let val = (self.0 >> 30usize) & 0x01;
            super::vals::HwrsrLpwrrstf::from_bits(val as u8)
        }
        #[doc = "Illegal Stop or Standby flag."]
        #[inline(always)]
        pub fn set_lpwrrstf(&mut self, val: super::vals::HwrsrLpwrrstf) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
        }
    }
    impl Default for Hwrsr {
        #[inline(always)]
        fn default() -> Hwrsr {
            Hwrsr(0)
        }
    }
    impl core::fmt::Debug for Hwrsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Hwrsr")
                .field("rmvf", &self.rmvf())
                .field("lckrstf", &self.lckrstf())
                .field("borrstf", &self.borrstf())
                .field("pinrstf", &self.pinrstf())
                .field("porrstf", &self.porrstf())
                .field("sftrstf", &self.sftrstf())
                .field("iwdgrstf", &self.iwdgrstf())
                .field("wwdgrstf", &self.wwdgrstf())
                .field("lpwrrstf", &self.lpwrrstf())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Hwrsr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Hwrsr {{ rmvf: {:?}, lckrstf: {:?}, borrstf: {:?}, pinrstf: {:?}, porrstf: {:?}, sftrstf: {:?}, iwdgrstf: {:?}, wwdgrstf: {:?}, lpwrrstf: {:?} }}" , self . rmvf () , self . lckrstf () , self . borrstf () , self . pinrstf () , self . porrstf () , self . sftrstf () , self . iwdgrstf () , self . wwdgrstf () , self . lpwrrstf ())
        }
    }
    #[doc = "RCC IC10 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic10cfgr(pub u32);
    impl Ic10cfgr {
        #[doc = "Divider IC10 integer division factor."]
        #[inline(always)]
        pub const fn ic10int(&self) -> super::vals::Ic10int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic10int::from_bits(val as u8)
        }
        #[doc = "Divider IC10 integer division factor."]
        #[inline(always)]
        pub fn set_ic10int(&mut self, val: super::vals::Ic10int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC10 Source Selection."]
        #[inline(always)]
        pub const fn ic10sel(&self) -> super::vals::Ic10sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic10sel::from_bits(val as u8)
        }
        #[doc = "Divider IC10 Source Selection."]
        #[inline(always)]
        pub fn set_ic10sel(&mut self, val: super::vals::Ic10sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic10cfgr {
        #[inline(always)]
        fn default() -> Ic10cfgr {
            Ic10cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic10cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic10cfgr")
                .field("ic10int", &self.ic10int())
                .field("ic10sel", &self.ic10sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic10cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic10cfgr {{ ic10int: {:?}, ic10sel: {:?} }}",
                self.ic10int(),
                self.ic10sel()
            )
        }
    }
    #[doc = "RCC IC11 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic11cfgr(pub u32);
    impl Ic11cfgr {
        #[doc = "Divider IC11 integer division factor."]
        #[inline(always)]
        pub const fn ic11int(&self) -> super::vals::Ic11int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic11int::from_bits(val as u8)
        }
        #[doc = "Divider IC11 integer division factor."]
        #[inline(always)]
        pub fn set_ic11int(&mut self, val: super::vals::Ic11int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC11 Source Selection."]
        #[inline(always)]
        pub const fn ic11sel(&self) -> super::vals::Ic11sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic11sel::from_bits(val as u8)
        }
        #[doc = "Divider IC11 Source Selection."]
        #[inline(always)]
        pub fn set_ic11sel(&mut self, val: super::vals::Ic11sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic11cfgr {
        #[inline(always)]
        fn default() -> Ic11cfgr {
            Ic11cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic11cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic11cfgr")
                .field("ic11int", &self.ic11int())
                .field("ic11sel", &self.ic11sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic11cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic11cfgr {{ ic11int: {:?}, ic11sel: {:?} }}",
                self.ic11int(),
                self.ic11sel()
            )
        }
    }
    #[doc = "RCC IC12 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic12cfgr(pub u32);
    impl Ic12cfgr {
        #[doc = "Divider IC12 integer division factor."]
        #[inline(always)]
        pub const fn ic12int(&self) -> super::vals::Ic12int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic12int::from_bits(val as u8)
        }
        #[doc = "Divider IC12 integer division factor."]
        #[inline(always)]
        pub fn set_ic12int(&mut self, val: super::vals::Ic12int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC12 Source Selection."]
        #[inline(always)]
        pub const fn ic12sel(&self) -> super::vals::Ic12sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic12sel::from_bits(val as u8)
        }
        #[doc = "Divider IC12 Source Selection."]
        #[inline(always)]
        pub fn set_ic12sel(&mut self, val: super::vals::Ic12sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic12cfgr {
        #[inline(always)]
        fn default() -> Ic12cfgr {
            Ic12cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic12cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic12cfgr")
                .field("ic12int", &self.ic12int())
                .field("ic12sel", &self.ic12sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic12cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic12cfgr {{ ic12int: {:?}, ic12sel: {:?} }}",
                self.ic12int(),
                self.ic12sel()
            )
        }
    }
    #[doc = "RCC IC13 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic13cfgr(pub u32);
    impl Ic13cfgr {
        #[doc = "Divider IC13 integer division factor."]
        #[inline(always)]
        pub const fn ic13int(&self) -> super::vals::Ic13int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic13int::from_bits(val as u8)
        }
        #[doc = "Divider IC13 integer division factor."]
        #[inline(always)]
        pub fn set_ic13int(&mut self, val: super::vals::Ic13int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC13 Source Selection."]
        #[inline(always)]
        pub const fn ic13sel(&self) -> super::vals::Ic13sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic13sel::from_bits(val as u8)
        }
        #[doc = "Divider IC13 Source Selection."]
        #[inline(always)]
        pub fn set_ic13sel(&mut self, val: super::vals::Ic13sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic13cfgr {
        #[inline(always)]
        fn default() -> Ic13cfgr {
            Ic13cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic13cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic13cfgr")
                .field("ic13int", &self.ic13int())
                .field("ic13sel", &self.ic13sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic13cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic13cfgr {{ ic13int: {:?}, ic13sel: {:?} }}",
                self.ic13int(),
                self.ic13sel()
            )
        }
    }
    #[doc = "RCC IC14 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic14cfgr(pub u32);
    impl Ic14cfgr {
        #[doc = "Divider IC14 integer division factor."]
        #[inline(always)]
        pub const fn ic14int(&self) -> super::vals::Ic14int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic14int::from_bits(val as u8)
        }
        #[doc = "Divider IC14 integer division factor."]
        #[inline(always)]
        pub fn set_ic14int(&mut self, val: super::vals::Ic14int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC14 Source Selection."]
        #[inline(always)]
        pub const fn ic14sel(&self) -> super::vals::Ic14sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic14sel::from_bits(val as u8)
        }
        #[doc = "Divider IC14 Source Selection."]
        #[inline(always)]
        pub fn set_ic14sel(&mut self, val: super::vals::Ic14sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic14cfgr {
        #[inline(always)]
        fn default() -> Ic14cfgr {
            Ic14cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic14cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic14cfgr")
                .field("ic14int", &self.ic14int())
                .field("ic14sel", &self.ic14sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic14cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic14cfgr {{ ic14int: {:?}, ic14sel: {:?} }}",
                self.ic14int(),
                self.ic14sel()
            )
        }
    }
    #[doc = "RCC IC15 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic15cfgr(pub u32);
    impl Ic15cfgr {
        #[doc = "Divider IC15 integer division factor."]
        #[inline(always)]
        pub const fn ic15int(&self) -> super::vals::Ic15int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic15int::from_bits(val as u8)
        }
        #[doc = "Divider IC15 integer division factor."]
        #[inline(always)]
        pub fn set_ic15int(&mut self, val: super::vals::Ic15int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC15 Source Selection."]
        #[inline(always)]
        pub const fn ic15sel(&self) -> super::vals::Ic15sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic15sel::from_bits(val as u8)
        }
        #[doc = "Divider IC15 Source Selection."]
        #[inline(always)]
        pub fn set_ic15sel(&mut self, val: super::vals::Ic15sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic15cfgr {
        #[inline(always)]
        fn default() -> Ic15cfgr {
            Ic15cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic15cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic15cfgr")
                .field("ic15int", &self.ic15int())
                .field("ic15sel", &self.ic15sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic15cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic15cfgr {{ ic15int: {:?}, ic15sel: {:?} }}",
                self.ic15int(),
                self.ic15sel()
            )
        }
    }
    #[doc = "RCC IC16 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic16cfgr(pub u32);
    impl Ic16cfgr {
        #[doc = "Divider IC16 integer division factor."]
        #[inline(always)]
        pub const fn ic16int(&self) -> super::vals::Ic16int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic16int::from_bits(val as u8)
        }
        #[doc = "Divider IC16 integer division factor."]
        #[inline(always)]
        pub fn set_ic16int(&mut self, val: super::vals::Ic16int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC16 Source Selection."]
        #[inline(always)]
        pub const fn ic16sel(&self) -> super::vals::Ic16sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic16sel::from_bits(val as u8)
        }
        #[doc = "Divider IC16 Source Selection."]
        #[inline(always)]
        pub fn set_ic16sel(&mut self, val: super::vals::Ic16sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic16cfgr {
        #[inline(always)]
        fn default() -> Ic16cfgr {
            Ic16cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic16cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic16cfgr")
                .field("ic16int", &self.ic16int())
                .field("ic16sel", &self.ic16sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic16cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic16cfgr {{ ic16int: {:?}, ic16sel: {:?} }}",
                self.ic16int(),
                self.ic16sel()
            )
        }
    }
    #[doc = "RCC IC17 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic17cfgr(pub u32);
    impl Ic17cfgr {
        #[doc = "Divider IC17 integer division factor."]
        #[inline(always)]
        pub const fn ic17int(&self) -> super::vals::Ic17int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic17int::from_bits(val as u8)
        }
        #[doc = "Divider IC17 integer division factor."]
        #[inline(always)]
        pub fn set_ic17int(&mut self, val: super::vals::Ic17int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC17 Source Selection."]
        #[inline(always)]
        pub const fn ic17sel(&self) -> super::vals::Ic17sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic17sel::from_bits(val as u8)
        }
        #[doc = "Divider IC17 Source Selection."]
        #[inline(always)]
        pub fn set_ic17sel(&mut self, val: super::vals::Ic17sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic17cfgr {
        #[inline(always)]
        fn default() -> Ic17cfgr {
            Ic17cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic17cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic17cfgr")
                .field("ic17int", &self.ic17int())
                .field("ic17sel", &self.ic17sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic17cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic17cfgr {{ ic17int: {:?}, ic17sel: {:?} }}",
                self.ic17int(),
                self.ic17sel()
            )
        }
    }
    #[doc = "RCC IC18 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic18cfgr(pub u32);
    impl Ic18cfgr {
        #[doc = "Divider IC18 integer division factor."]
        #[inline(always)]
        pub const fn ic18int(&self) -> super::vals::Ic18int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic18int::from_bits(val as u8)
        }
        #[doc = "Divider IC18 integer division factor."]
        #[inline(always)]
        pub fn set_ic18int(&mut self, val: super::vals::Ic18int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC18 Source Selection."]
        #[inline(always)]
        pub const fn ic18sel(&self) -> super::vals::Ic18sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic18sel::from_bits(val as u8)
        }
        #[doc = "Divider IC18 Source Selection."]
        #[inline(always)]
        pub fn set_ic18sel(&mut self, val: super::vals::Ic18sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic18cfgr {
        #[inline(always)]
        fn default() -> Ic18cfgr {
            Ic18cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic18cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic18cfgr")
                .field("ic18int", &self.ic18int())
                .field("ic18sel", &self.ic18sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic18cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic18cfgr {{ ic18int: {:?}, ic18sel: {:?} }}",
                self.ic18int(),
                self.ic18sel()
            )
        }
    }
    #[doc = "RCC IC19 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic19cfgr(pub u32);
    impl Ic19cfgr {
        #[doc = "Divider IC19 integer division factor."]
        #[inline(always)]
        pub const fn ic19int(&self) -> super::vals::Ic19int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic19int::from_bits(val as u8)
        }
        #[doc = "Divider IC19 integer division factor."]
        #[inline(always)]
        pub fn set_ic19int(&mut self, val: super::vals::Ic19int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC19 Source Selection."]
        #[inline(always)]
        pub const fn ic19sel(&self) -> super::vals::Ic19sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic19sel::from_bits(val as u8)
        }
        #[doc = "Divider IC19 Source Selection."]
        #[inline(always)]
        pub fn set_ic19sel(&mut self, val: super::vals::Ic19sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic19cfgr {
        #[inline(always)]
        fn default() -> Ic19cfgr {
            Ic19cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic19cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic19cfgr")
                .field("ic19int", &self.ic19int())
                .field("ic19sel", &self.ic19sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic19cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic19cfgr {{ ic19int: {:?}, ic19sel: {:?} }}",
                self.ic19int(),
                self.ic19sel()
            )
        }
    }
    #[doc = "RCC IC1 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic1cfgr(pub u32);
    impl Ic1cfgr {
        #[doc = "Divider IC1 integer division factor."]
        #[inline(always)]
        pub const fn ic1int(&self) -> super::vals::Ic1int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic1int::from_bits(val as u8)
        }
        #[doc = "Divider IC1 integer division factor."]
        #[inline(always)]
        pub fn set_ic1int(&mut self, val: super::vals::Ic1int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC1 Source Selection."]
        #[inline(always)]
        pub const fn ic1sel(&self) -> super::vals::Ic1sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic1sel::from_bits(val as u8)
        }
        #[doc = "Divider IC1 Source Selection."]
        #[inline(always)]
        pub fn set_ic1sel(&mut self, val: super::vals::Ic1sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic1cfgr {
        #[inline(always)]
        fn default() -> Ic1cfgr {
            Ic1cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic1cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic1cfgr")
                .field("ic1int", &self.ic1int())
                .field("ic1sel", &self.ic1sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic1cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic1cfgr {{ ic1int: {:?}, ic1sel: {:?} }}",
                self.ic1int(),
                self.ic1sel()
            )
        }
    }
    #[doc = "RCC IC20 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic20cfgr(pub u32);
    impl Ic20cfgr {
        #[doc = "Divider IC20 integer division factor."]
        #[inline(always)]
        pub const fn ic20int(&self) -> super::vals::Ic20int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic20int::from_bits(val as u8)
        }
        #[doc = "Divider IC20 integer division factor."]
        #[inline(always)]
        pub fn set_ic20int(&mut self, val: super::vals::Ic20int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC20 Source Selection."]
        #[inline(always)]
        pub const fn ic20sel(&self) -> super::vals::Ic20sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic20sel::from_bits(val as u8)
        }
        #[doc = "Divider IC20 Source Selection."]
        #[inline(always)]
        pub fn set_ic20sel(&mut self, val: super::vals::Ic20sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic20cfgr {
        #[inline(always)]
        fn default() -> Ic20cfgr {
            Ic20cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic20cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic20cfgr")
                .field("ic20int", &self.ic20int())
                .field("ic20sel", &self.ic20sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic20cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic20cfgr {{ ic20int: {:?}, ic20sel: {:?} }}",
                self.ic20int(),
                self.ic20sel()
            )
        }
    }
    #[doc = "RCC IC2 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic2cfgr(pub u32);
    impl Ic2cfgr {
        #[doc = "Divider IC2 integer division factor."]
        #[inline(always)]
        pub const fn ic2int(&self) -> super::vals::Ic2int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic2int::from_bits(val as u8)
        }
        #[doc = "Divider IC2 integer division factor."]
        #[inline(always)]
        pub fn set_ic2int(&mut self, val: super::vals::Ic2int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC2 Source Selection."]
        #[inline(always)]
        pub const fn ic2sel(&self) -> super::vals::Ic2sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic2sel::from_bits(val as u8)
        }
        #[doc = "Divider IC2 Source Selection."]
        #[inline(always)]
        pub fn set_ic2sel(&mut self, val: super::vals::Ic2sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic2cfgr {
        #[inline(always)]
        fn default() -> Ic2cfgr {
            Ic2cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic2cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic2cfgr")
                .field("ic2int", &self.ic2int())
                .field("ic2sel", &self.ic2sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic2cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic2cfgr {{ ic2int: {:?}, ic2sel: {:?} }}",
                self.ic2int(),
                self.ic2sel()
            )
        }
    }
    #[doc = "RCC IC3 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic3cfgr(pub u32);
    impl Ic3cfgr {
        #[doc = "Divider IC3 integer division factor."]
        #[inline(always)]
        pub const fn ic3int(&self) -> super::vals::Ic3int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic3int::from_bits(val as u8)
        }
        #[doc = "Divider IC3 integer division factor."]
        #[inline(always)]
        pub fn set_ic3int(&mut self, val: super::vals::Ic3int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC3 Source Selection."]
        #[inline(always)]
        pub const fn ic3sel(&self) -> super::vals::Ic3sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic3sel::from_bits(val as u8)
        }
        #[doc = "Divider IC3 Source Selection."]
        #[inline(always)]
        pub fn set_ic3sel(&mut self, val: super::vals::Ic3sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic3cfgr {
        #[inline(always)]
        fn default() -> Ic3cfgr {
            Ic3cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic3cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic3cfgr")
                .field("ic3int", &self.ic3int())
                .field("ic3sel", &self.ic3sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic3cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic3cfgr {{ ic3int: {:?}, ic3sel: {:?} }}",
                self.ic3int(),
                self.ic3sel()
            )
        }
    }
    #[doc = "RCC IC4 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic4cfgr(pub u32);
    impl Ic4cfgr {
        #[doc = "Divider IC4 integer division factor."]
        #[inline(always)]
        pub const fn ic4int(&self) -> super::vals::Ic4int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic4int::from_bits(val as u8)
        }
        #[doc = "Divider IC4 integer division factor."]
        #[inline(always)]
        pub fn set_ic4int(&mut self, val: super::vals::Ic4int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC4 Source Selection."]
        #[inline(always)]
        pub const fn ic4sel(&self) -> super::vals::Ic4sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic4sel::from_bits(val as u8)
        }
        #[doc = "Divider IC4 Source Selection."]
        #[inline(always)]
        pub fn set_ic4sel(&mut self, val: super::vals::Ic4sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic4cfgr {
        #[inline(always)]
        fn default() -> Ic4cfgr {
            Ic4cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic4cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic4cfgr")
                .field("ic4int", &self.ic4int())
                .field("ic4sel", &self.ic4sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic4cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic4cfgr {{ ic4int: {:?}, ic4sel: {:?} }}",
                self.ic4int(),
                self.ic4sel()
            )
        }
    }
    #[doc = "RCC IC5 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic5cfgr(pub u32);
    impl Ic5cfgr {
        #[doc = "Divider IC5 integer division factor."]
        #[inline(always)]
        pub const fn ic5int(&self) -> super::vals::Ic5int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic5int::from_bits(val as u8)
        }
        #[doc = "Divider IC5 integer division factor."]
        #[inline(always)]
        pub fn set_ic5int(&mut self, val: super::vals::Ic5int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC5 Source Selection."]
        #[inline(always)]
        pub const fn ic5sel(&self) -> super::vals::Ic5sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic5sel::from_bits(val as u8)
        }
        #[doc = "Divider IC5 Source Selection."]
        #[inline(always)]
        pub fn set_ic5sel(&mut self, val: super::vals::Ic5sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic5cfgr {
        #[inline(always)]
        fn default() -> Ic5cfgr {
            Ic5cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic5cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic5cfgr")
                .field("ic5int", &self.ic5int())
                .field("ic5sel", &self.ic5sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic5cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic5cfgr {{ ic5int: {:?}, ic5sel: {:?} }}",
                self.ic5int(),
                self.ic5sel()
            )
        }
    }
    #[doc = "RCC IC6 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic6cfgr(pub u32);
    impl Ic6cfgr {
        #[doc = "Divider IC6 integer division factor."]
        #[inline(always)]
        pub const fn ic6int(&self) -> super::vals::Ic6int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic6int::from_bits(val as u8)
        }
        #[doc = "Divider IC6 integer division factor."]
        #[inline(always)]
        pub fn set_ic6int(&mut self, val: super::vals::Ic6int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC6 Source Selection."]
        #[inline(always)]
        pub const fn ic6sel(&self) -> super::vals::Ic6sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic6sel::from_bits(val as u8)
        }
        #[doc = "Divider IC6 Source Selection."]
        #[inline(always)]
        pub fn set_ic6sel(&mut self, val: super::vals::Ic6sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic6cfgr {
        #[inline(always)]
        fn default() -> Ic6cfgr {
            Ic6cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic6cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic6cfgr")
                .field("ic6int", &self.ic6int())
                .field("ic6sel", &self.ic6sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic6cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic6cfgr {{ ic6int: {:?}, ic6sel: {:?} }}",
                self.ic6int(),
                self.ic6sel()
            )
        }
    }
    #[doc = "RCC IC7 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic7cfgr(pub u32);
    impl Ic7cfgr {
        #[doc = "Divider IC7 integer division factor."]
        #[inline(always)]
        pub const fn ic7int(&self) -> super::vals::Ic7int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic7int::from_bits(val as u8)
        }
        #[doc = "Divider IC7 integer division factor."]
        #[inline(always)]
        pub fn set_ic7int(&mut self, val: super::vals::Ic7int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC7 Source Selection."]
        #[inline(always)]
        pub const fn ic7sel(&self) -> super::vals::Ic7sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic7sel::from_bits(val as u8)
        }
        #[doc = "Divider IC7 Source Selection."]
        #[inline(always)]
        pub fn set_ic7sel(&mut self, val: super::vals::Ic7sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic7cfgr {
        #[inline(always)]
        fn default() -> Ic7cfgr {
            Ic7cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic7cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic7cfgr")
                .field("ic7int", &self.ic7int())
                .field("ic7sel", &self.ic7sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic7cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic7cfgr {{ ic7int: {:?}, ic7sel: {:?} }}",
                self.ic7int(),
                self.ic7sel()
            )
        }
    }
    #[doc = "RCC IC8 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic8cfgr(pub u32);
    impl Ic8cfgr {
        #[doc = "Divider IC8 integer division factor."]
        #[inline(always)]
        pub const fn ic8int(&self) -> super::vals::Ic8int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic8int::from_bits(val as u8)
        }
        #[doc = "Divider IC8 integer division factor."]
        #[inline(always)]
        pub fn set_ic8int(&mut self, val: super::vals::Ic8int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC8 Source Selection."]
        #[inline(always)]
        pub const fn ic8sel(&self) -> super::vals::Ic8sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic8sel::from_bits(val as u8)
        }
        #[doc = "Divider IC8 Source Selection."]
        #[inline(always)]
        pub fn set_ic8sel(&mut self, val: super::vals::Ic8sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic8cfgr {
        #[inline(always)]
        fn default() -> Ic8cfgr {
            Ic8cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic8cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic8cfgr")
                .field("ic8int", &self.ic8int())
                .field("ic8sel", &self.ic8sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic8cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic8cfgr {{ ic8int: {:?}, ic8sel: {:?} }}",
                self.ic8int(),
                self.ic8sel()
            )
        }
    }
    #[doc = "RCC IC9 configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ic9cfgr(pub u32);
    impl Ic9cfgr {
        #[doc = "Divider IC9 integer division factor."]
        #[inline(always)]
        pub const fn ic9int(&self) -> super::vals::Ic9int {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Ic9int::from_bits(val as u8)
        }
        #[doc = "Divider IC9 integer division factor."]
        #[inline(always)]
        pub fn set_ic9int(&mut self, val: super::vals::Ic9int) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
        #[doc = "Divider IC9 Source Selection."]
        #[inline(always)]
        pub const fn ic9sel(&self) -> super::vals::Ic9sel {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Ic9sel::from_bits(val as u8)
        }
        #[doc = "Divider IC9 Source Selection."]
        #[inline(always)]
        pub fn set_ic9sel(&mut self, val: super::vals::Ic9sel) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ic9cfgr {
        #[inline(always)]
        fn default() -> Ic9cfgr {
            Ic9cfgr(0)
        }
    }
    impl core::fmt::Debug for Ic9cfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ic9cfgr")
                .field("ic9int", &self.ic9int())
                .field("ic9sel", &self.ic9sel())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic9cfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Ic9cfgr {{ ic9int: {:?}, ic9sel: {:?} }}",
                self.ic9int(),
                self.ic9sel()
            )
        }
    }
    #[doc = "RCC oscillator lock configuration register0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lockcfgr0(pub u32);
    impl Lockcfgr0 {
        #[doc = "Defines the lock protection of the LSI oscillator configuration bits."]
        #[inline(always)]
        pub const fn lsilock(&self) -> super::vals::Lsilock {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Lsilock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the LSI oscillator configuration bits."]
        #[inline(always)]
        pub fn set_lsilock(&mut self, val: super::vals::Lsilock) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the lock protection of the LSE oscillator configuration bits."]
        #[inline(always)]
        pub const fn lselock(&self) -> super::vals::Lselock {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Lselock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the LSE oscillator configuration bits."]
        #[inline(always)]
        pub fn set_lselock(&mut self, val: super::vals::Lselock) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the lock protection of the MSI oscillator configuration bits."]
        #[inline(always)]
        pub const fn msilock(&self) -> super::vals::Msilock {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Msilock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the MSI oscillator configuration bits."]
        #[inline(always)]
        pub fn set_msilock(&mut self, val: super::vals::Msilock) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the lock protection of the HSI oscillator configuration bits."]
        #[inline(always)]
        pub const fn hsilock(&self) -> super::vals::Hsilock {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Hsilock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the HSI oscillator configuration bits."]
        #[inline(always)]
        pub fn set_hsilock(&mut self, val: super::vals::Hsilock) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the lock protection of the HSE oscillator configuration bits."]
        #[inline(always)]
        pub const fn hselock(&self) -> super::vals::Hselock {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Hselock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the HSE oscillator configuration bits."]
        #[inline(always)]
        pub fn set_hselock(&mut self, val: super::vals::Hselock) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Lockcfgr0 {
        #[inline(always)]
        fn default() -> Lockcfgr0 {
            Lockcfgr0(0)
        }
    }
    impl core::fmt::Debug for Lockcfgr0 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Lockcfgr0")
                .field("lsilock", &self.lsilock())
                .field("lselock", &self.lselock())
                .field("msilock", &self.msilock())
                .field("hsilock", &self.hsilock())
                .field("hselock", &self.hselock())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Lockcfgr0 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Lockcfgr0 {{ lsilock: {:?}, lselock: {:?}, msilock: {:?}, hsilock: {:?}, hselock: {:?} }}",
                self.lsilock(),
                self.lselock(),
                self.msilock(),
                self.hsilock(),
                self.hselock()
            )
        }
    }
    #[doc = "RCC PLL lock configuration register1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lockcfgr1(pub u32);
    impl Lockcfgr1 {
        #[doc = "Defines the lock protection of the PLL1 PLL configuration bits."]
        #[inline(always)]
        pub const fn plllock(&self, n: usize) -> super::vals::Plllock {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Plllock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the PLL1 PLL configuration bits."]
        #[inline(always)]
        pub fn set_plllock(&mut self, n: usize, val: super::vals::Plllock) {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
    }
    impl Default for Lockcfgr1 {
        #[inline(always)]
        fn default() -> Lockcfgr1 {
            Lockcfgr1(0)
        }
    }
    impl core::fmt::Debug for Lockcfgr1 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Lockcfgr1")
                .field("plllock[0]", &self.plllock(0usize))
                .field("plllock[1]", &self.plllock(1usize))
                .field("plllock[2]", &self.plllock(2usize))
                .field("plllock[3]", &self.plllock(3usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Lockcfgr1 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Lockcfgr1 {{ plllock[0]: {:?}, plllock[1]: {:?}, plllock[2]: {:?}, plllock[3]: {:?} }}",
                self.plllock(0usize),
                self.plllock(1usize),
                self.plllock(2usize),
                self.plllock(3usize)
            )
        }
    }
    #[doc = "RCC divider lock configuration register2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lockcfgr2(pub u32);
    impl Lockcfgr2 {
        #[doc = "Defines the lock protection of the IC1 divider configuration bits."]
        #[inline(always)]
        pub const fn ic1lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC1 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic1lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the lock protection of the IC2 divider configuration bits."]
        #[inline(always)]
        pub const fn ic2lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC2 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic2lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the lock protection of the IC3 divider configuration bits."]
        #[inline(always)]
        pub const fn ic3lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC3 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic3lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the lock protection of the IC4 divider configuration bits."]
        #[inline(always)]
        pub const fn ic4lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC4 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic4lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the lock protection of the IC5 divider configuration bits."]
        #[inline(always)]
        pub const fn ic5lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC5 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic5lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the lock protection of the IC6 divider configuration bits."]
        #[inline(always)]
        pub const fn ic6lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 5usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC6 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic6lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the lock protection of the IC7 divider configuration bits."]
        #[inline(always)]
        pub const fn ic7lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC7 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic7lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the lock protection of the IC8 divider configuration bits."]
        #[inline(always)]
        pub const fn ic8lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 7usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC8 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic8lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the lock protection of the IC9 divider configuration bits."]
        #[inline(always)]
        pub const fn ic9lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC9 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic9lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the lock protection of the IC10 divider configuration bits."]
        #[inline(always)]
        pub const fn ic10lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC10 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic10lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the lock protection of the IC11 divider configuration bits."]
        #[inline(always)]
        pub const fn ic11lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 10usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC11 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic11lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the lock protection of the IC12 divider configuration bits."]
        #[inline(always)]
        pub const fn ic12lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 11usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC12 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic12lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the lock protection of the IC13 divider configuration bits."]
        #[inline(always)]
        pub const fn ic13lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 12usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC13 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic13lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the lock protection of the IC14 divider configuration bits."]
        #[inline(always)]
        pub const fn ic14lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 13usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC14 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic14lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
        }
        #[doc = "Defines the lock protection of the IC15 divider configuration bits."]
        #[inline(always)]
        pub const fn ic15lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 14usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC15 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic15lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
        }
        #[doc = "Defines the lock protection of the IC16 divider configuration bits."]
        #[inline(always)]
        pub const fn ic16lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 15usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC16 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic16lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
        }
        #[doc = "Defines the lock protection of the IC17 divider configuration bits."]
        #[inline(always)]
        pub const fn ic17lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC17 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic17lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
        #[doc = "Defines the lock protection of the IC18 divider configuration bits."]
        #[inline(always)]
        pub const fn ic18lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 17usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC18 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic18lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
        }
        #[doc = "Defines the lock protection of the IC19 divider configuration bits."]
        #[inline(always)]
        pub const fn ic19lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 18usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC19 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic19lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
        }
        #[doc = "Defines the lock protection of the IC20 divider configuration bits."]
        #[inline(always)]
        pub const fn ic20lock(&self) -> super::vals::Iclock {
            let val = (self.0 >> 19usize) & 0x01;
            super::vals::Iclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the IC20 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic20lock(&mut self, val: super::vals::Iclock) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Lockcfgr2 {
        #[inline(always)]
        fn default() -> Lockcfgr2 {
            Lockcfgr2(0)
        }
    }
    impl core::fmt::Debug for Lockcfgr2 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Lockcfgr2")
                .field("ic1lock", &self.ic1lock())
                .field("ic2lock", &self.ic2lock())
                .field("ic3lock", &self.ic3lock())
                .field("ic4lock", &self.ic4lock())
                .field("ic5lock", &self.ic5lock())
                .field("ic6lock", &self.ic6lock())
                .field("ic7lock", &self.ic7lock())
                .field("ic8lock", &self.ic8lock())
                .field("ic9lock", &self.ic9lock())
                .field("ic10lock", &self.ic10lock())
                .field("ic11lock", &self.ic11lock())
                .field("ic12lock", &self.ic12lock())
                .field("ic13lock", &self.ic13lock())
                .field("ic14lock", &self.ic14lock())
                .field("ic15lock", &self.ic15lock())
                .field("ic16lock", &self.ic16lock())
                .field("ic17lock", &self.ic17lock())
                .field("ic18lock", &self.ic18lock())
                .field("ic19lock", &self.ic19lock())
                .field("ic20lock", &self.ic20lock())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Lockcfgr2 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Lockcfgr2 {{ ic1lock: {:?}, ic2lock: {:?}, ic3lock: {:?}, ic4lock: {:?}, ic5lock: {:?}, ic6lock: {:?}, ic7lock: {:?}, ic8lock: {:?}, ic9lock: {:?}, ic10lock: {:?}, ic11lock: {:?}, ic12lock: {:?}, ic13lock: {:?}, ic14lock: {:?}, ic15lock: {:?}, ic16lock: {:?}, ic17lock: {:?}, ic18lock: {:?}, ic19lock: {:?}, ic20lock: {:?} }}" , self . ic1lock () , self . ic2lock () , self . ic3lock () , self . ic4lock () , self . ic5lock () , self . ic6lock () , self . ic7lock () , self . ic8lock () , self . ic9lock () , self . ic10lock () , self . ic11lock () , self . ic12lock () , self . ic13lock () , self . ic14lock () , self . ic15lock () , self . ic16lock () , self . ic17lock () , self . ic18lock () , self . ic19lock () , self . ic20lock ())
        }
    }
    #[doc = "RCC system lock configuration register3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lockcfgr3(pub u32);
    impl Lockcfgr3 {
        #[doc = "Defines the lock protection of the MOD system configuration bits."]
        #[inline(always)]
        pub const fn modlock(&self) -> super::vals::Modlock {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Modlock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the MOD system configuration bits."]
        #[inline(always)]
        pub fn set_modlock(&mut self, val: super::vals::Modlock) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the lock protection of the SYS system configuration bits."]
        #[inline(always)]
        pub const fn syslock(&self) -> super::vals::Syslock {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Syslock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the SYS system configuration bits."]
        #[inline(always)]
        pub fn set_syslock(&mut self, val: super::vals::Syslock) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the lock protection of the BUS system configuration bits."]
        #[inline(always)]
        pub const fn buslock(&self) -> super::vals::Buslock {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Buslock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the BUS system configuration bits."]
        #[inline(always)]
        pub fn set_buslock(&mut self, val: super::vals::Buslock) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the lock protection of the PER system configuration bits."]
        #[inline(always)]
        pub const fn perlock(&self) -> super::vals::Perlock {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Perlock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the PER system configuration bits."]
        #[inline(always)]
        pub fn set_perlock(&mut self, val: super::vals::Perlock) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the lock protection of the INT system configuration bits."]
        #[inline(always)]
        pub const fn intlock(&self) -> super::vals::Intlock {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Intlock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the INT system configuration bits."]
        #[inline(always)]
        pub fn set_intlock(&mut self, val: super::vals::Intlock) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the lock protection of the RST system configuration bits."]
        #[inline(always)]
        pub const fn rstlock(&self) -> super::vals::Rstlock {
            let val = (self.0 >> 5usize) & 0x01;
            super::vals::Rstlock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the RST system configuration bits."]
        #[inline(always)]
        pub fn set_rstlock(&mut self, val: super::vals::Rstlock) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the lock protection of the DFT system configuration bits."]
        #[inline(always)]
        pub const fn dftlock(&self) -> super::vals::Dftlock {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Dftlock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the DFT system configuration bits."]
        #[inline(always)]
        pub fn set_dftlock(&mut self, val: super::vals::Dftlock) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Lockcfgr3 {
        #[inline(always)]
        fn default() -> Lockcfgr3 {
            Lockcfgr3(0)
        }
    }
    impl core::fmt::Debug for Lockcfgr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Lockcfgr3")
                .field("modlock", &self.modlock())
                .field("syslock", &self.syslock())
                .field("buslock", &self.buslock())
                .field("perlock", &self.perlock())
                .field("intlock", &self.intlock())
                .field("rstlock", &self.rstlock())
                .field("dftlock", &self.dftlock())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Lockcfgr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Lockcfgr3 {{ modlock: {:?}, syslock: {:?}, buslock: {:?}, perlock: {:?}, intlock: {:?}, rstlock: {:?}, dftlock: {:?} }}" , self . modlock () , self . syslock () , self . buslock () , self . perlock () , self . intlock () , self . rstlock () , self . dftlock ())
        }
    }
    #[doc = "RCC bus lock configuration register4."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lockcfgr4(pub u32);
    impl Lockcfgr4 {
        #[doc = "Defines the lock protection of the ACLKN bus configuration bits."]
        #[inline(always)]
        pub const fn aclknlock(&self) -> super::vals::Aclknlock {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Aclknlock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the ACLKN bus configuration bits."]
        #[inline(always)]
        pub fn set_aclknlock(&mut self, val: super::vals::Aclknlock) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the lock protection of the ACLKNC bus configuration bits."]
        #[inline(always)]
        pub const fn aclknclock(&self) -> super::vals::Aclknclock {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Aclknclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the ACLKNC bus configuration bits."]
        #[inline(always)]
        pub fn set_aclknclock(&mut self, val: super::vals::Aclknclock) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the lock protection of the AHBM bus configuration bits."]
        #[inline(always)]
        pub const fn ahbmlock(&self) -> super::vals::Ahbmlock {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Ahbmlock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the AHBM bus configuration bits."]
        #[inline(always)]
        pub fn set_ahbmlock(&mut self, val: super::vals::Ahbmlock) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the lock protection of the AHB1 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb1lock(&self) -> super::vals::Ahblock {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Ahblock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the AHB1 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb1lock(&mut self, val: super::vals::Ahblock) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the lock protection of the AHB2 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb2lock(&self) -> super::vals::Ahblock {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Ahblock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the AHB2 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb2lock(&mut self, val: super::vals::Ahblock) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the lock protection of the AHB3 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb3lock(&self) -> super::vals::Ahblock {
            let val = (self.0 >> 5usize) & 0x01;
            super::vals::Ahblock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the AHB3 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb3lock(&mut self, val: super::vals::Ahblock) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the lock protection of the AHB4 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb4lock(&self) -> super::vals::Ahblock {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Ahblock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the AHB4 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb4lock(&mut self, val: super::vals::Ahblock) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the lock protection of the AHB5 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb5lock(&self) -> super::vals::Ahblock {
            let val = (self.0 >> 7usize) & 0x01;
            super::vals::Ahblock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the AHB5 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb5lock(&mut self, val: super::vals::Ahblock) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the lock protection of the APB1 bus configuration bits."]
        #[inline(always)]
        pub const fn apb1lock(&self) -> super::vals::Apblock {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Apblock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the APB1 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb1lock(&mut self, val: super::vals::Apblock) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the lock protection of the APB2 bus configuration bits."]
        #[inline(always)]
        pub const fn apb2lock(&self) -> super::vals::Apblock {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Apblock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the APB2 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb2lock(&mut self, val: super::vals::Apblock) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the lock protection of the APB3 bus configuration bits."]
        #[inline(always)]
        pub const fn apb3lock(&self) -> super::vals::Apblock {
            let val = (self.0 >> 10usize) & 0x01;
            super::vals::Apblock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the APB3 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb3lock(&mut self, val: super::vals::Apblock) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the lock protection of the APB4 bus configuration bits."]
        #[inline(always)]
        pub const fn apb4lock(&self) -> super::vals::Apblock {
            let val = (self.0 >> 11usize) & 0x01;
            super::vals::Apblock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the APB4 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb4lock(&mut self, val: super::vals::Apblock) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the lock protection of the APB5 bus configuration bits."]
        #[inline(always)]
        pub const fn apb5lock(&self) -> super::vals::Apblock {
            let val = (self.0 >> 12usize) & 0x01;
            super::vals::Apblock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the APB5 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb5lock(&mut self, val: super::vals::Apblock) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the lock protection of the NOC bus configuration bits."]
        #[inline(always)]
        pub const fn noclock(&self) -> super::vals::Noclock {
            let val = (self.0 >> 13usize) & 0x01;
            super::vals::Noclock::from_bits(val as u8)
        }
        #[doc = "Defines the lock protection of the NOC bus configuration bits."]
        #[inline(always)]
        pub fn set_noclock(&mut self, val: super::vals::Noclock) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
        }
    }
    impl Default for Lockcfgr4 {
        #[inline(always)]
        fn default() -> Lockcfgr4 {
            Lockcfgr4(0)
        }
    }
    impl core::fmt::Debug for Lockcfgr4 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Lockcfgr4")
                .field("aclknlock", &self.aclknlock())
                .field("aclknclock", &self.aclknclock())
                .field("ahbmlock", &self.ahbmlock())
                .field("ahb1lock", &self.ahb1lock())
                .field("ahb2lock", &self.ahb2lock())
                .field("ahb3lock", &self.ahb3lock())
                .field("ahb4lock", &self.ahb4lock())
                .field("ahb5lock", &self.ahb5lock())
                .field("apb1lock", &self.apb1lock())
                .field("apb2lock", &self.apb2lock())
                .field("apb3lock", &self.apb3lock())
                .field("apb4lock", &self.apb4lock())
                .field("apb5lock", &self.apb5lock())
                .field("noclock", &self.noclock())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Lockcfgr4 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Lockcfgr4 {{ aclknlock: {:?}, aclknclock: {:?}, ahbmlock: {:?}, ahb1lock: {:?}, ahb2lock: {:?}, ahb3lock: {:?}, ahb4lock: {:?}, ahb5lock: {:?}, apb1lock: {:?}, apb2lock: {:?}, apb3lock: {:?}, apb4lock: {:?}, apb5lock: {:?}, noclock: {:?} }}" , self . aclknlock () , self . aclknclock () , self . ahbmlock () , self . ahb1lock () , self . ahb2lock () , self . ahb3lock () , self . ahb4lock () , self . ahb5lock () , self . apb1lock () , self . apb2lock () , self . apb3lock () , self . apb4lock () , self . apb5lock () , self . noclock ())
        }
    }
    #[doc = "RCC system lock configuration register3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lockcfgsr3(pub u32);
    impl Lockcfgsr3 {
        #[doc = "Defines the lock protection of the MOD configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn modlocks(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the lock protection of the MOD configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_modlocks(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the lock protection of the SYS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn syslocks(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the lock protection of the SYS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_syslocks(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the lock protection of the BUS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn buslocks(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the lock protection of the BUS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_buslocks(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the lock protection of the PER configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn perlocks(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the lock protection of the PER configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_perlocks(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the lock protection of the INT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn intlocks(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the lock protection of the INT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_intlocks(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the lock protection of the RST configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn rstlocks(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the lock protection of the RST configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_rstlocks(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the lock protection of the DFT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn dftlocks(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the lock protection of the DFT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_dftlocks(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Lockcfgsr3 {
        #[inline(always)]
        fn default() -> Lockcfgsr3 {
            Lockcfgsr3(0)
        }
    }
    impl core::fmt::Debug for Lockcfgsr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Lockcfgsr3")
                .field("modlocks", &self.modlocks())
                .field("syslocks", &self.syslocks())
                .field("buslocks", &self.buslocks())
                .field("perlocks", &self.perlocks())
                .field("intlocks", &self.intlocks())
                .field("rstlocks", &self.rstlocks())
                .field("dftlocks", &self.dftlocks())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Lockcfgsr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Lockcfgsr3 {{ modlocks: {=bool:?}, syslocks: {=bool:?}, buslocks: {=bool:?}, perlocks: {=bool:?}, intlocks: {=bool:?}, rstlocks: {=bool:?}, dftlocks: {=bool:?} }}" , self . modlocks () , self . syslocks () , self . buslocks () , self . perlocks () , self . intlocks () , self . rstlocks () , self . dftlocks ())
        }
    }
    #[doc = "RCC LSE configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lsecfgr(pub u32);
    impl Lsecfgr {
        #[doc = "LSE clock security system (CSS) enable."]
        #[inline(always)]
        pub const fn lsecsson(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "LSE clock security system (CSS) enable."]
        #[inline(always)]
        pub fn set_lsecsson(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "LSE clock security system (CSS) re-arm function."]
        #[inline(always)]
        pub const fn lsecssra(&self) -> super::vals::Lsecssra {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Lsecssra::from_bits(val as u8)
        }
        #[doc = "LSE clock security system (CSS) re-arm function."]
        #[inline(always)]
        pub fn set_lsecssra(&mut self, val: super::vals::Lsecssra) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
        #[doc = "LSE clock security system (CSS) failure detection."]
        #[inline(always)]
        pub const fn lsecssd(&self) -> super::vals::Lsecssd {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Lsecssd::from_bits(val as u8)
        }
        #[doc = "LSE clock security system (CSS) failure detection."]
        #[inline(always)]
        pub fn set_lsecssd(&mut self, val: super::vals::Lsecssd) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
        #[doc = "LSE clock bypass."]
        #[inline(always)]
        pub const fn lsebyp(&self) -> super::vals::Lsebyp {
            let val = (self.0 >> 15usize) & 0x01;
            super::vals::Lsebyp::from_bits(val as u8)
        }
        #[doc = "LSE clock bypass."]
        #[inline(always)]
        pub fn set_lsebyp(&mut self, val: super::vals::Lsebyp) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
        }
        #[doc = "LSE clock type in Bypass mode."]
        #[inline(always)]
        pub const fn lseext(&self) -> super::vals::Lseext {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::Lseext::from_bits(val as u8)
        }
        #[doc = "LSE clock type in Bypass mode."]
        #[inline(always)]
        pub fn set_lseext(&mut self, val: super::vals::Lseext) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
        #[doc = "LSE clock glitch filter enable."]
        #[inline(always)]
        pub const fn lsegfon(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "LSE clock glitch filter enable."]
        #[inline(always)]
        pub fn set_lsegfon(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "LSE oscillator driving capability."]
        #[inline(always)]
        pub const fn lsedrv(&self) -> super::vals::Lsedrv {
            let val = (self.0 >> 18usize) & 0x03;
            super::vals::Lsedrv::from_bits(val as u8)
        }
        #[doc = "LSE oscillator driving capability."]
        #[inline(always)]
        pub fn set_lsedrv(&mut self, val: super::vals::Lsedrv) {
            self.0 = (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
        }
    }
    impl Default for Lsecfgr {
        #[inline(always)]
        fn default() -> Lsecfgr {
            Lsecfgr(0)
        }
    }
    impl core::fmt::Debug for Lsecfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Lsecfgr")
                .field("lsecsson", &self.lsecsson())
                .field("lsecssra", &self.lsecssra())
                .field("lsecssd", &self.lsecssd())
                .field("lsebyp", &self.lsebyp())
                .field("lseext", &self.lseext())
                .field("lsegfon", &self.lsegfon())
                .field("lsedrv", &self.lsedrv())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Lsecfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Lsecfgr {{ lsecsson: {=bool:?}, lsecssra: {:?}, lsecssd: {:?}, lsebyp: {:?}, lseext: {:?}, lsegfon: {=bool:?}, lsedrv: {:?} }}" , self . lsecsson () , self . lsecssra () , self . lsecssd () , self . lsebyp () , self . lseext () , self . lsegfon () , self . lsedrv ())
        }
    }
    #[doc = "RCC memory enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memencr(pub u32);
    impl Memencr {
        #[doc = "AXISRAM3 enable."]
        #[inline(always)]
        pub const fn axisram3enc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM3 enable."]
        #[inline(always)]
        pub fn set_axisram3enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "AXISRAM4 enable."]
        #[inline(always)]
        pub const fn axisram4enc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM4 enable."]
        #[inline(always)]
        pub fn set_axisram4enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AXISRAM5 enable."]
        #[inline(always)]
        pub const fn axisram5enc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM5 enable."]
        #[inline(always)]
        pub fn set_axisram5enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AXISRAM6 enable."]
        #[inline(always)]
        pub const fn axisram6enc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM6 enable."]
        #[inline(always)]
        pub fn set_axisram6enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHBSRAM1 enable."]
        #[inline(always)]
        pub const fn ahbsram1enc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM1 enable."]
        #[inline(always)]
        pub fn set_ahbsram1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHBSRAM2 enable."]
        #[inline(always)]
        pub const fn ahbsram2enc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM2 enable."]
        #[inline(always)]
        pub fn set_ahbsram2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "BKPSRAM enable."]
        #[inline(always)]
        pub const fn bkpsramenc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "BKPSRAM enable."]
        #[inline(always)]
        pub fn set_bkpsramenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AXISRAM1 enable."]
        #[inline(always)]
        pub const fn axisram1enc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM1 enable."]
        #[inline(always)]
        pub fn set_axisram1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "AXISRAM2 enable."]
        #[inline(always)]
        pub const fn axisram2enc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM2 enable."]
        #[inline(always)]
        pub fn set_axisram2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "FLEXRAM enable."]
        #[inline(always)]
        pub const fn flexramenc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "FLEXRAM enable."]
        #[inline(always)]
        pub fn set_flexramenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "NPUCACHERAM enable."]
        #[inline(always)]
        pub const fn npucacheramenc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHERAM enable."]
        #[inline(always)]
        pub fn set_npucacheramenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "VENCRAM enable."]
        #[inline(always)]
        pub const fn vencramenc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "VENCRAM enable."]
        #[inline(always)]
        pub fn set_vencramenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "BOOTROM enable."]
        #[inline(always)]
        pub const fn bootromenc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "BOOTROM enable."]
        #[inline(always)]
        pub fn set_bootromenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Memencr {
        #[inline(always)]
        fn default() -> Memencr {
            Memencr(0)
        }
    }
    impl core::fmt::Debug for Memencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Memencr")
                .field("axisram3enc", &self.axisram3enc())
                .field("axisram4enc", &self.axisram4enc())
                .field("axisram5enc", &self.axisram5enc())
                .field("axisram6enc", &self.axisram6enc())
                .field("ahbsram1enc", &self.ahbsram1enc())
                .field("ahbsram2enc", &self.ahbsram2enc())
                .field("bkpsramenc", &self.bkpsramenc())
                .field("axisram1enc", &self.axisram1enc())
                .field("axisram2enc", &self.axisram2enc())
                .field("flexramenc", &self.flexramenc())
                .field("npucacheramenc", &self.npucacheramenc())
                .field("vencramenc", &self.vencramenc())
                .field("bootromenc", &self.bootromenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Memencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Memencr {{ axisram3enc: {=bool:?}, axisram4enc: {=bool:?}, axisram5enc: {=bool:?}, axisram6enc: {=bool:?}, ahbsram1enc: {=bool:?}, ahbsram2enc: {=bool:?}, bkpsramenc: {=bool:?}, axisram1enc: {=bool:?}, axisram2enc: {=bool:?}, flexramenc: {=bool:?}, npucacheramenc: {=bool:?}, vencramenc: {=bool:?}, bootromenc: {=bool:?} }}" , self . axisram3enc () , self . axisram4enc () , self . axisram5enc () , self . axisram6enc () , self . ahbsram1enc () , self . ahbsram2enc () , self . bkpsramenc () , self . axisram1enc () , self . axisram2enc () , self . flexramenc () , self . npucacheramenc () , self . vencramenc () , self . bootromenc ())
        }
    }
    #[doc = "RCC memory enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memenr(pub u32);
    impl Memenr {
        #[doc = "AXISRAM3 enable."]
        #[inline(always)]
        pub const fn axisram3en(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM3 enable."]
        #[inline(always)]
        pub fn set_axisram3en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "AXISRAM4 enable."]
        #[inline(always)]
        pub const fn axisram4en(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM4 enable."]
        #[inline(always)]
        pub fn set_axisram4en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AXISRAM5 enable."]
        #[inline(always)]
        pub const fn axisram5en(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM5 enable."]
        #[inline(always)]
        pub fn set_axisram5en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AXISRAM6 enable."]
        #[inline(always)]
        pub const fn axisram6en(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM6 enable."]
        #[inline(always)]
        pub fn set_axisram6en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHBSRAM1 enable."]
        #[inline(always)]
        pub const fn ahbsram1en(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM1 enable."]
        #[inline(always)]
        pub fn set_ahbsram1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHBSRAM2 enable."]
        #[inline(always)]
        pub const fn ahbsram2en(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM2 enable."]
        #[inline(always)]
        pub fn set_ahbsram2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "BKPSRAM enable."]
        #[inline(always)]
        pub const fn bkpsramen(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "BKPSRAM enable."]
        #[inline(always)]
        pub fn set_bkpsramen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AXISRAM1 enable."]
        #[inline(always)]
        pub const fn axisram1en(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM1 enable."]
        #[inline(always)]
        pub fn set_axisram1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "AXISRAM2 enable."]
        #[inline(always)]
        pub const fn axisram2en(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM2 enable."]
        #[inline(always)]
        pub fn set_axisram2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "FLEXRAM enable."]
        #[inline(always)]
        pub const fn flexramen(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "FLEXRAM enable."]
        #[inline(always)]
        pub fn set_flexramen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "NPUCACHERAM enable."]
        #[inline(always)]
        pub const fn npucacheramen(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHERAM enable."]
        #[inline(always)]
        pub fn set_npucacheramen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "VENCRAM enable."]
        #[inline(always)]
        pub const fn vencramen(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "VENCRAM enable."]
        #[inline(always)]
        pub fn set_vencramen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "BOOTROM enable."]
        #[inline(always)]
        pub const fn bootromen(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "BOOTROM enable."]
        #[inline(always)]
        pub fn set_bootromen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Memenr {
        #[inline(always)]
        fn default() -> Memenr {
            Memenr(0)
        }
    }
    impl core::fmt::Debug for Memenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Memenr")
                .field("axisram3en", &self.axisram3en())
                .field("axisram4en", &self.axisram4en())
                .field("axisram5en", &self.axisram5en())
                .field("axisram6en", &self.axisram6en())
                .field("ahbsram1en", &self.ahbsram1en())
                .field("ahbsram2en", &self.ahbsram2en())
                .field("bkpsramen", &self.bkpsramen())
                .field("axisram1en", &self.axisram1en())
                .field("axisram2en", &self.axisram2en())
                .field("flexramen", &self.flexramen())
                .field("npucacheramen", &self.npucacheramen())
                .field("vencramen", &self.vencramen())
                .field("bootromen", &self.bootromen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Memenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Memenr {{ axisram3en: {=bool:?}, axisram4en: {=bool:?}, axisram5en: {=bool:?}, axisram6en: {=bool:?}, ahbsram1en: {=bool:?}, ahbsram2en: {=bool:?}, bkpsramen: {=bool:?}, axisram1en: {=bool:?}, axisram2en: {=bool:?}, flexramen: {=bool:?}, npucacheramen: {=bool:?}, vencramen: {=bool:?}, bootromen: {=bool:?} }}" , self . axisram3en () , self . axisram4en () , self . axisram5en () , self . axisram6en () , self . ahbsram1en () , self . ahbsram2en () , self . bkpsramen () , self . axisram1en () , self . axisram2en () , self . flexramen () , self . npucacheramen () , self . vencramen () , self . bootromen ())
        }
    }
    #[doc = "RCC memory enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memensr(pub u32);
    impl Memensr {
        #[doc = "AXISRAM3 enable."]
        #[inline(always)]
        pub const fn axisram3ens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM3 enable."]
        #[inline(always)]
        pub fn set_axisram3ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "AXISRAM4 enable."]
        #[inline(always)]
        pub const fn axisram4ens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM4 enable."]
        #[inline(always)]
        pub fn set_axisram4ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AXISRAM5 enable."]
        #[inline(always)]
        pub const fn axisram5ens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM5 enable."]
        #[inline(always)]
        pub fn set_axisram5ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AXISRAM6 enable."]
        #[inline(always)]
        pub const fn axisram6ens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM6 enable."]
        #[inline(always)]
        pub fn set_axisram6ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHBSRAM1 enable."]
        #[inline(always)]
        pub const fn ahbsram1ens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM1 enable."]
        #[inline(always)]
        pub fn set_ahbsram1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHBSRAM2 enable."]
        #[inline(always)]
        pub const fn ahbsram2ens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM2 enable."]
        #[inline(always)]
        pub fn set_ahbsram2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "BKPSRAM enable."]
        #[inline(always)]
        pub const fn bkpsramens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "BKPSRAM enable."]
        #[inline(always)]
        pub fn set_bkpsramens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AXISRAM1 enable."]
        #[inline(always)]
        pub const fn axisram1ens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM1 enable."]
        #[inline(always)]
        pub fn set_axisram1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "AXISRAM2 enable."]
        #[inline(always)]
        pub const fn axisram2ens(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM2 enable."]
        #[inline(always)]
        pub fn set_axisram2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "FLEXRAM enable."]
        #[inline(always)]
        pub const fn flexramens(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "FLEXRAM enable."]
        #[inline(always)]
        pub fn set_flexramens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "NPUCACHERAM enable."]
        #[inline(always)]
        pub const fn npucacheramens(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHERAM enable."]
        #[inline(always)]
        pub fn set_npucacheramens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "VENCRAM enable."]
        #[inline(always)]
        pub const fn vencramens(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "VENCRAM enable."]
        #[inline(always)]
        pub fn set_vencramens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "BOOTROM enable."]
        #[inline(always)]
        pub const fn bootromens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "BOOTROM enable."]
        #[inline(always)]
        pub fn set_bootromens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Memensr {
        #[inline(always)]
        fn default() -> Memensr {
            Memensr(0)
        }
    }
    impl core::fmt::Debug for Memensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Memensr")
                .field("axisram3ens", &self.axisram3ens())
                .field("axisram4ens", &self.axisram4ens())
                .field("axisram5ens", &self.axisram5ens())
                .field("axisram6ens", &self.axisram6ens())
                .field("ahbsram1ens", &self.ahbsram1ens())
                .field("ahbsram2ens", &self.ahbsram2ens())
                .field("bkpsramens", &self.bkpsramens())
                .field("axisram1ens", &self.axisram1ens())
                .field("axisram2ens", &self.axisram2ens())
                .field("flexramens", &self.flexramens())
                .field("npucacheramens", &self.npucacheramens())
                .field("vencramens", &self.vencramens())
                .field("bootromens", &self.bootromens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Memensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Memensr {{ axisram3ens: {=bool:?}, axisram4ens: {=bool:?}, axisram5ens: {=bool:?}, axisram6ens: {=bool:?}, ahbsram1ens: {=bool:?}, ahbsram2ens: {=bool:?}, bkpsramens: {=bool:?}, axisram1ens: {=bool:?}, axisram2ens: {=bool:?}, flexramens: {=bool:?}, npucacheramens: {=bool:?}, vencramens: {=bool:?}, bootromens: {=bool:?} }}" , self . axisram3ens () , self . axisram4ens () , self . axisram5ens () , self . axisram6ens () , self . ahbsram1ens () , self . ahbsram2ens () , self . bkpsramens () , self . axisram1ens () , self . axisram2ens () , self . flexramens () , self . npucacheramens () , self . vencramens () , self . bootromens ())
        }
    }
    #[doc = "RCC memory Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memlpencr(pub u32);
    impl Memlpencr {
        #[doc = "AXISRAM3 sleep enable."]
        #[inline(always)]
        pub const fn axisram3lpenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM3 sleep enable."]
        #[inline(always)]
        pub fn set_axisram3lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "AXISRAM4 sleep enable."]
        #[inline(always)]
        pub const fn axisram4lpenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM4 sleep enable."]
        #[inline(always)]
        pub fn set_axisram4lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AXISRAM5 sleep enable."]
        #[inline(always)]
        pub const fn axisram5lpenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM5 sleep enable."]
        #[inline(always)]
        pub fn set_axisram5lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AXISRAM6 sleep enable."]
        #[inline(always)]
        pub const fn axisram6lpenc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM6 sleep enable."]
        #[inline(always)]
        pub fn set_axisram6lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHBSRAM1 sleep enable."]
        #[inline(always)]
        pub const fn ahbsram1lpenc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM1 sleep enable."]
        #[inline(always)]
        pub fn set_ahbsram1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHBSRAM2 sleep enable."]
        #[inline(always)]
        pub const fn ahbsram2lpenc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM2 sleep enable."]
        #[inline(always)]
        pub fn set_ahbsram2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "BKPSRAM sleep enable."]
        #[inline(always)]
        pub const fn bkpsramlpenc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "BKPSRAM sleep enable."]
        #[inline(always)]
        pub fn set_bkpsramlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AXISRAM1 sleep enable."]
        #[inline(always)]
        pub const fn axisram1lpenc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM1 sleep enable."]
        #[inline(always)]
        pub fn set_axisram1lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "AXISRAM2 sleep enable."]
        #[inline(always)]
        pub const fn axisram2lpenc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM2 sleep enable."]
        #[inline(always)]
        pub fn set_axisram2lpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "FLEXRAM sleep enable."]
        #[inline(always)]
        pub const fn flexramlpenc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "FLEXRAM sleep enable."]
        #[inline(always)]
        pub fn set_flexramlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "NPUCACHERAM sleep enable."]
        #[inline(always)]
        pub const fn npucacheramlpenc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHERAM sleep enable."]
        #[inline(always)]
        pub fn set_npucacheramlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "VENCRAM sleep enable."]
        #[inline(always)]
        pub const fn vencramlpenc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "VENCRAM sleep enable."]
        #[inline(always)]
        pub fn set_vencramlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "BOOTROM sleep enable."]
        #[inline(always)]
        pub const fn bootromlpenc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "BOOTROM sleep enable."]
        #[inline(always)]
        pub fn set_bootromlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Memlpencr {
        #[inline(always)]
        fn default() -> Memlpencr {
            Memlpencr(0)
        }
    }
    impl core::fmt::Debug for Memlpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Memlpencr")
                .field("axisram3lpenc", &self.axisram3lpenc())
                .field("axisram4lpenc", &self.axisram4lpenc())
                .field("axisram5lpenc", &self.axisram5lpenc())
                .field("axisram6lpenc", &self.axisram6lpenc())
                .field("ahbsram1lpenc", &self.ahbsram1lpenc())
                .field("ahbsram2lpenc", &self.ahbsram2lpenc())
                .field("bkpsramlpenc", &self.bkpsramlpenc())
                .field("axisram1lpenc", &self.axisram1lpenc())
                .field("axisram2lpenc", &self.axisram2lpenc())
                .field("flexramlpenc", &self.flexramlpenc())
                .field("npucacheramlpenc", &self.npucacheramlpenc())
                .field("vencramlpenc", &self.vencramlpenc())
                .field("bootromlpenc", &self.bootromlpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Memlpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Memlpencr {{ axisram3lpenc: {=bool:?}, axisram4lpenc: {=bool:?}, axisram5lpenc: {=bool:?}, axisram6lpenc: {=bool:?}, ahbsram1lpenc: {=bool:?}, ahbsram2lpenc: {=bool:?}, bkpsramlpenc: {=bool:?}, axisram1lpenc: {=bool:?}, axisram2lpenc: {=bool:?}, flexramlpenc: {=bool:?}, npucacheramlpenc: {=bool:?}, vencramlpenc: {=bool:?}, bootromlpenc: {=bool:?} }}" , self . axisram3lpenc () , self . axisram4lpenc () , self . axisram5lpenc () , self . axisram6lpenc () , self . ahbsram1lpenc () , self . ahbsram2lpenc () , self . bkpsramlpenc () , self . axisram1lpenc () , self . axisram2lpenc () , self . flexramlpenc () , self . npucacheramlpenc () , self . vencramlpenc () , self . bootromlpenc ())
        }
    }
    #[doc = "RCC memory Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memlpenr(pub u32);
    impl Memlpenr {
        #[doc = "AXISRAM3 sleep enable."]
        #[inline(always)]
        pub const fn axisram3lpen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM3 sleep enable."]
        #[inline(always)]
        pub fn set_axisram3lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "AXISRAM4 sleep enable."]
        #[inline(always)]
        pub const fn axisram4lpen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM4 sleep enable."]
        #[inline(always)]
        pub fn set_axisram4lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AXISRAM5 sleep enable."]
        #[inline(always)]
        pub const fn axisram5lpen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM5 sleep enable."]
        #[inline(always)]
        pub fn set_axisram5lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AXISRAM6 sleep enable."]
        #[inline(always)]
        pub const fn axisram6lpen(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM6 sleep enable."]
        #[inline(always)]
        pub fn set_axisram6lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHBSRAM1 sleep enable."]
        #[inline(always)]
        pub const fn ahbsram1lpen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM1 sleep enable."]
        #[inline(always)]
        pub fn set_ahbsram1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHBSRAM2 sleep enable."]
        #[inline(always)]
        pub const fn ahbsram2lpen(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM2 sleep enable."]
        #[inline(always)]
        pub fn set_ahbsram2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "BKPSRAM sleep enable."]
        #[inline(always)]
        pub const fn bkpsramlpen(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "BKPSRAM sleep enable."]
        #[inline(always)]
        pub fn set_bkpsramlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AXISRAM1 sleep enable."]
        #[inline(always)]
        pub const fn axisram1lpen(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM1 sleep enable."]
        #[inline(always)]
        pub fn set_axisram1lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "AXISRAM2 sleep enable."]
        #[inline(always)]
        pub const fn axisram2lpen(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM2 sleep enable."]
        #[inline(always)]
        pub fn set_axisram2lpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "FLEXRAM sleep enable."]
        #[inline(always)]
        pub const fn flexramlpen(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "FLEXRAM sleep enable."]
        #[inline(always)]
        pub fn set_flexramlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "NPUCACHERAM sleep enable."]
        #[inline(always)]
        pub const fn npucacheramlpen(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHERAM sleep enable."]
        #[inline(always)]
        pub fn set_npucacheramlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "VENCRAM sleep enable."]
        #[inline(always)]
        pub const fn vencramlpen(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "VENCRAM sleep enable."]
        #[inline(always)]
        pub fn set_vencramlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "BOOTROM sleep enable."]
        #[inline(always)]
        pub const fn bootromlpen(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "BOOTROM sleep enable."]
        #[inline(always)]
        pub fn set_bootromlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Memlpenr {
        #[inline(always)]
        fn default() -> Memlpenr {
            Memlpenr(0)
        }
    }
    impl core::fmt::Debug for Memlpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Memlpenr")
                .field("axisram3lpen", &self.axisram3lpen())
                .field("axisram4lpen", &self.axisram4lpen())
                .field("axisram5lpen", &self.axisram5lpen())
                .field("axisram6lpen", &self.axisram6lpen())
                .field("ahbsram1lpen", &self.ahbsram1lpen())
                .field("ahbsram2lpen", &self.ahbsram2lpen())
                .field("bkpsramlpen", &self.bkpsramlpen())
                .field("axisram1lpen", &self.axisram1lpen())
                .field("axisram2lpen", &self.axisram2lpen())
                .field("flexramlpen", &self.flexramlpen())
                .field("npucacheramlpen", &self.npucacheramlpen())
                .field("vencramlpen", &self.vencramlpen())
                .field("bootromlpen", &self.bootromlpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Memlpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Memlpenr {{ axisram3lpen: {=bool:?}, axisram4lpen: {=bool:?}, axisram5lpen: {=bool:?}, axisram6lpen: {=bool:?}, ahbsram1lpen: {=bool:?}, ahbsram2lpen: {=bool:?}, bkpsramlpen: {=bool:?}, axisram1lpen: {=bool:?}, axisram2lpen: {=bool:?}, flexramlpen: {=bool:?}, npucacheramlpen: {=bool:?}, vencramlpen: {=bool:?}, bootromlpen: {=bool:?} }}" , self . axisram3lpen () , self . axisram4lpen () , self . axisram5lpen () , self . axisram6lpen () , self . ahbsram1lpen () , self . ahbsram2lpen () , self . bkpsramlpen () , self . axisram1lpen () , self . axisram2lpen () , self . flexramlpen () , self . npucacheramlpen () , self . vencramlpen () , self . bootromlpen ())
        }
    }
    #[doc = "RCC memory sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memlpensr(pub u32);
    impl Memlpensr {
        #[doc = "AXISRAM3 sleep enable."]
        #[inline(always)]
        pub const fn axisram3lpens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM3 sleep enable."]
        #[inline(always)]
        pub fn set_axisram3lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "AXISRAM4 sleep enable."]
        #[inline(always)]
        pub const fn axisram4lpens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM4 sleep enable."]
        #[inline(always)]
        pub fn set_axisram4lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AXISRAM5 sleep enable."]
        #[inline(always)]
        pub const fn axisram5lpens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM5 sleep enable."]
        #[inline(always)]
        pub fn set_axisram5lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AXISRAM6 sleep enable."]
        #[inline(always)]
        pub const fn axisram6lpens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM6 sleep enable."]
        #[inline(always)]
        pub fn set_axisram6lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHBSRAM1 sleep enable."]
        #[inline(always)]
        pub const fn ahbsram1lpens(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM1 sleep enable."]
        #[inline(always)]
        pub fn set_ahbsram1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHBSRAM2 sleep enable."]
        #[inline(always)]
        pub const fn ahbsram2lpens(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM2 sleep enable."]
        #[inline(always)]
        pub fn set_ahbsram2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "BKPSRAM sleep enable."]
        #[inline(always)]
        pub const fn bkpsramlpens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "BKPSRAM sleep enable."]
        #[inline(always)]
        pub fn set_bkpsramlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "AXISRAM1 sleep enable."]
        #[inline(always)]
        pub const fn axisram1lpens(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM1 sleep enable."]
        #[inline(always)]
        pub fn set_axisram1lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "AXISRAM2 sleep enable."]
        #[inline(always)]
        pub const fn axisram2lpens(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM2 sleep enable."]
        #[inline(always)]
        pub fn set_axisram2lpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "FLEXRAM sleep enable."]
        #[inline(always)]
        pub const fn flexramlpens(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "FLEXRAM sleep enable."]
        #[inline(always)]
        pub fn set_flexramlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "NPUCACHERAM sleep enable."]
        #[inline(always)]
        pub const fn npucacheramlpens(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHERAM sleep enable."]
        #[inline(always)]
        pub fn set_npucacheramlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "VENCRAM sleep enable."]
        #[inline(always)]
        pub const fn vencramlpens(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "VENCRAM sleep enable."]
        #[inline(always)]
        pub fn set_vencramlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "BOOTROM sleep enable."]
        #[inline(always)]
        pub const fn bootromlpens(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "BOOTROM sleep enable."]
        #[inline(always)]
        pub fn set_bootromlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Memlpensr {
        #[inline(always)]
        fn default() -> Memlpensr {
            Memlpensr(0)
        }
    }
    impl core::fmt::Debug for Memlpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Memlpensr")
                .field("axisram3lpens", &self.axisram3lpens())
                .field("axisram4lpens", &self.axisram4lpens())
                .field("axisram5lpens", &self.axisram5lpens())
                .field("axisram6lpens", &self.axisram6lpens())
                .field("ahbsram1lpens", &self.ahbsram1lpens())
                .field("ahbsram2lpens", &self.ahbsram2lpens())
                .field("bkpsramlpens", &self.bkpsramlpens())
                .field("axisram1lpens", &self.axisram1lpens())
                .field("axisram2lpens", &self.axisram2lpens())
                .field("flexramlpens", &self.flexramlpens())
                .field("npucacheramlpens", &self.npucacheramlpens())
                .field("vencramlpens", &self.vencramlpens())
                .field("bootromlpens", &self.bootromlpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Memlpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Memlpensr {{ axisram3lpens: {=bool:?}, axisram4lpens: {=bool:?}, axisram5lpens: {=bool:?}, axisram6lpens: {=bool:?}, ahbsram1lpens: {=bool:?}, ahbsram2lpens: {=bool:?}, bkpsramlpens: {=bool:?}, axisram1lpens: {=bool:?}, axisram2lpens: {=bool:?}, flexramlpens: {=bool:?}, npucacheramlpens: {=bool:?}, vencramlpens: {=bool:?}, bootromlpens: {=bool:?} }}" , self . axisram3lpens () , self . axisram4lpens () , self . axisram5lpens () , self . axisram6lpens () , self . ahbsram1lpens () , self . ahbsram2lpens () , self . bkpsramlpens () , self . axisram1lpens () , self . axisram2lpens () , self . flexramlpens () , self . npucacheramlpens () , self . vencramlpens () , self . bootromlpens ())
        }
    }
    #[doc = "RCC memory reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memrstcr(pub u32);
    impl Memrstcr {
        #[doc = "AXISRAM3 reset."]
        #[inline(always)]
        pub const fn axisram3rstc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM3 reset."]
        #[inline(always)]
        pub fn set_axisram3rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "AXISRAM4 reset."]
        #[inline(always)]
        pub const fn axisram4rstc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM4 reset."]
        #[inline(always)]
        pub fn set_axisram4rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AXISRAM5 reset."]
        #[inline(always)]
        pub const fn axisram5rstc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM5 reset."]
        #[inline(always)]
        pub fn set_axisram5rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AXISRAM6 reset."]
        #[inline(always)]
        pub const fn axisram6rstc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM6 reset."]
        #[inline(always)]
        pub fn set_axisram6rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHBSRAM1 reset."]
        #[inline(always)]
        pub const fn ahbsram1rstc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM1 reset."]
        #[inline(always)]
        pub fn set_ahbsram1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHBSRAM2 reset."]
        #[inline(always)]
        pub const fn ahbsram2rstc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM2 reset."]
        #[inline(always)]
        pub fn set_ahbsram2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "AXISRAM1 reset."]
        #[inline(always)]
        pub const fn axisram1rstc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM1 reset."]
        #[inline(always)]
        pub fn set_axisram1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "AXISRAM2 reset."]
        #[inline(always)]
        pub const fn axisram2rstc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM2 reset."]
        #[inline(always)]
        pub fn set_axisram2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "FLEXRAM reset."]
        #[inline(always)]
        pub const fn flexramrstc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "FLEXRAM reset."]
        #[inline(always)]
        pub fn set_flexramrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "NPUCACHERAM reset."]
        #[inline(always)]
        pub const fn npucacheramrstc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHERAM reset."]
        #[inline(always)]
        pub fn set_npucacheramrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "VENCRAM reset."]
        #[inline(always)]
        pub const fn vencramrstc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "VENCRAM reset."]
        #[inline(always)]
        pub fn set_vencramrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "BOOTROM reset."]
        #[inline(always)]
        pub const fn bootromrstc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "BOOTROM reset."]
        #[inline(always)]
        pub fn set_bootromrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Memrstcr {
        #[inline(always)]
        fn default() -> Memrstcr {
            Memrstcr(0)
        }
    }
    impl core::fmt::Debug for Memrstcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Memrstcr")
                .field("axisram3rstc", &self.axisram3rstc())
                .field("axisram4rstc", &self.axisram4rstc())
                .field("axisram5rstc", &self.axisram5rstc())
                .field("axisram6rstc", &self.axisram6rstc())
                .field("ahbsram1rstc", &self.ahbsram1rstc())
                .field("ahbsram2rstc", &self.ahbsram2rstc())
                .field("axisram1rstc", &self.axisram1rstc())
                .field("axisram2rstc", &self.axisram2rstc())
                .field("flexramrstc", &self.flexramrstc())
                .field("npucacheramrstc", &self.npucacheramrstc())
                .field("vencramrstc", &self.vencramrstc())
                .field("bootromrstc", &self.bootromrstc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Memrstcr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Memrstcr {{ axisram3rstc: {=bool:?}, axisram4rstc: {=bool:?}, axisram5rstc: {=bool:?}, axisram6rstc: {=bool:?}, ahbsram1rstc: {=bool:?}, ahbsram2rstc: {=bool:?}, axisram1rstc: {=bool:?}, axisram2rstc: {=bool:?}, flexramrstc: {=bool:?}, npucacheramrstc: {=bool:?}, vencramrstc: {=bool:?}, bootromrstc: {=bool:?} }}" , self . axisram3rstc () , self . axisram4rstc () , self . axisram5rstc () , self . axisram6rstc () , self . ahbsram1rstc () , self . ahbsram2rstc () , self . axisram1rstc () , self . axisram2rstc () , self . flexramrstc () , self . npucacheramrstc () , self . vencramrstc () , self . bootromrstc ())
        }
    }
    #[doc = "RCC memories reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memrstr(pub u32);
    impl Memrstr {
        #[doc = "AXISRAM3 reset."]
        #[inline(always)]
        pub const fn axisram3rst(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM3 reset."]
        #[inline(always)]
        pub fn set_axisram3rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "AXISRAM4reset."]
        #[inline(always)]
        pub const fn axisram4rst(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM4reset."]
        #[inline(always)]
        pub fn set_axisram4rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AXISRAM5 reset."]
        #[inline(always)]
        pub const fn axisram5rst(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM5 reset."]
        #[inline(always)]
        pub fn set_axisram5rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AXISRAM6 reset."]
        #[inline(always)]
        pub const fn axisram6rst(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM6 reset."]
        #[inline(always)]
        pub fn set_axisram6rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHBSRAM1 reset."]
        #[inline(always)]
        pub const fn ahbsram1rst(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM1 reset."]
        #[inline(always)]
        pub fn set_ahbsram1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHBSRAM2 reset."]
        #[inline(always)]
        pub const fn ahbsram2rst(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM2 reset."]
        #[inline(always)]
        pub fn set_ahbsram2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "AXISRAM1 reset."]
        #[inline(always)]
        pub const fn axisram1rst(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM1 reset."]
        #[inline(always)]
        pub fn set_axisram1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "AXISRAM2 reset."]
        #[inline(always)]
        pub const fn axisram2rst(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM2 reset."]
        #[inline(always)]
        pub fn set_axisram2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "FLEXRAM reset."]
        #[inline(always)]
        pub const fn flexramrst(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "FLEXRAM reset."]
        #[inline(always)]
        pub fn set_flexramrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "NPUCACHERAM reset."]
        #[inline(always)]
        pub const fn npucacheramrst(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHERAM reset."]
        #[inline(always)]
        pub fn set_npucacheramrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "VENCRAM reset."]
        #[inline(always)]
        pub const fn vencramrst(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "VENCRAM reset."]
        #[inline(always)]
        pub fn set_vencramrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "BOOTROM reset."]
        #[inline(always)]
        pub const fn bootromrst(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "BOOTROM reset."]
        #[inline(always)]
        pub fn set_bootromrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Memrstr {
        #[inline(always)]
        fn default() -> Memrstr {
            Memrstr(0)
        }
    }
    impl core::fmt::Debug for Memrstr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Memrstr")
                .field("axisram3rst", &self.axisram3rst())
                .field("axisram4rst", &self.axisram4rst())
                .field("axisram5rst", &self.axisram5rst())
                .field("axisram6rst", &self.axisram6rst())
                .field("ahbsram1rst", &self.ahbsram1rst())
                .field("ahbsram2rst", &self.ahbsram2rst())
                .field("axisram1rst", &self.axisram1rst())
                .field("axisram2rst", &self.axisram2rst())
                .field("flexramrst", &self.flexramrst())
                .field("npucacheramrst", &self.npucacheramrst())
                .field("vencramrst", &self.vencramrst())
                .field("bootromrst", &self.bootromrst())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Memrstr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Memrstr {{ axisram3rst: {=bool:?}, axisram4rst: {=bool:?}, axisram5rst: {=bool:?}, axisram6rst: {=bool:?}, ahbsram1rst: {=bool:?}, ahbsram2rst: {=bool:?}, axisram1rst: {=bool:?}, axisram2rst: {=bool:?}, flexramrst: {=bool:?}, npucacheramrst: {=bool:?}, vencramrst: {=bool:?}, bootromrst: {=bool:?} }}" , self . axisram3rst () , self . axisram4rst () , self . axisram5rst () , self . axisram6rst () , self . ahbsram1rst () , self . ahbsram2rst () , self . axisram1rst () , self . axisram2rst () , self . flexramrst () , self . npucacheramrst () , self . vencramrst () , self . bootromrst ())
        }
    }
    #[doc = "RCC memory reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memrstsr(pub u32);
    impl Memrstsr {
        #[doc = "AXISRAM3 reset."]
        #[inline(always)]
        pub const fn axisram3rsts(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM3 reset."]
        #[inline(always)]
        pub fn set_axisram3rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "AXISRAM4 reset."]
        #[inline(always)]
        pub const fn axisram4rsts(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM4 reset."]
        #[inline(always)]
        pub fn set_axisram4rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "AXISRAM5 reset."]
        #[inline(always)]
        pub const fn axisram5rsts(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM5 reset."]
        #[inline(always)]
        pub fn set_axisram5rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "AXISRAM6 reset."]
        #[inline(always)]
        pub const fn axisram6rsts(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM6 reset."]
        #[inline(always)]
        pub fn set_axisram6rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "AHBSRAM1 reset."]
        #[inline(always)]
        pub const fn ahbsram1rsts(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM1 reset."]
        #[inline(always)]
        pub fn set_ahbsram1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "AHBSRAM2 reset."]
        #[inline(always)]
        pub const fn ahbsram2rsts(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "AHBSRAM2 reset."]
        #[inline(always)]
        pub fn set_ahbsram2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "AXISRAM1 reset."]
        #[inline(always)]
        pub const fn axisram1rsts(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM1 reset."]
        #[inline(always)]
        pub fn set_axisram1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "AXISRAM2 reset."]
        #[inline(always)]
        pub const fn axisram2rsts(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "AXISRAM2 reset."]
        #[inline(always)]
        pub fn set_axisram2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "FLEXRAM reset."]
        #[inline(always)]
        pub const fn flexramrsts(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "FLEXRAM reset."]
        #[inline(always)]
        pub fn set_flexramrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "NPUCACHERAM reset."]
        #[inline(always)]
        pub const fn npucacheramrsts(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "NPUCACHERAM reset."]
        #[inline(always)]
        pub fn set_npucacheramrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "VENCRAM reset."]
        #[inline(always)]
        pub const fn vencramrsts(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "VENCRAM reset."]
        #[inline(always)]
        pub fn set_vencramrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "BOOTROM reset."]
        #[inline(always)]
        pub const fn bootromrsts(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "BOOTROM reset."]
        #[inline(always)]
        pub fn set_bootromrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Memrstsr {
        #[inline(always)]
        fn default() -> Memrstsr {
            Memrstsr(0)
        }
    }
    impl core::fmt::Debug for Memrstsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Memrstsr")
                .field("axisram3rsts", &self.axisram3rsts())
                .field("axisram4rsts", &self.axisram4rsts())
                .field("axisram5rsts", &self.axisram5rsts())
                .field("axisram6rsts", &self.axisram6rsts())
                .field("ahbsram1rsts", &self.ahbsram1rsts())
                .field("ahbsram2rsts", &self.ahbsram2rsts())
                .field("axisram1rsts", &self.axisram1rsts())
                .field("axisram2rsts", &self.axisram2rsts())
                .field("flexramrsts", &self.flexramrsts())
                .field("npucacheramrsts", &self.npucacheramrsts())
                .field("vencramrsts", &self.vencramrsts())
                .field("bootromrsts", &self.bootromrsts())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Memrstsr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Memrstsr {{ axisram3rsts: {=bool:?}, axisram4rsts: {=bool:?}, axisram5rsts: {=bool:?}, axisram6rsts: {=bool:?}, ahbsram1rsts: {=bool:?}, ahbsram2rsts: {=bool:?}, axisram1rsts: {=bool:?}, axisram2rsts: {=bool:?}, flexramrsts: {=bool:?}, npucacheramrsts: {=bool:?}, vencramrsts: {=bool:?}, bootromrsts: {=bool:?} }}" , self . axisram3rsts () , self . axisram4rsts () , self . axisram5rsts () , self . axisram6rsts () , self . ahbsram1rsts () , self . ahbsram2rsts () , self . axisram1rsts () , self . axisram2rsts () , self . flexramrsts () , self . npucacheramrsts () , self . vencramrsts () , self . bootromrsts ())
        }
    }
    #[doc = "RCC miscellaneous enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Miscencr(pub u32);
    impl Miscencr {
        #[doc = "DBG enable."]
        #[inline(always)]
        pub const fn dbgenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "DBG enable."]
        #[inline(always)]
        pub fn set_dbgenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "MCO1 enable."]
        #[inline(always)]
        pub const fn mco1enc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "MCO1 enable."]
        #[inline(always)]
        pub fn set_mco1enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "MCO2 enable."]
        #[inline(always)]
        pub const fn mco2enc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "MCO2 enable."]
        #[inline(always)]
        pub fn set_mco2enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "XSPIPHYCOMP enable."]
        #[inline(always)]
        pub const fn xspiphycompenc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIPHYCOMP enable."]
        #[inline(always)]
        pub fn set_xspiphycompenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "PER enable."]
        #[inline(always)]
        pub const fn perenc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PER enable."]
        #[inline(always)]
        pub fn set_perenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Miscencr {
        #[inline(always)]
        fn default() -> Miscencr {
            Miscencr(0)
        }
    }
    impl core::fmt::Debug for Miscencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Miscencr")
                .field("dbgenc", &self.dbgenc())
                .field("mco1enc", &self.mco1enc())
                .field("mco2enc", &self.mco2enc())
                .field("xspiphycompenc", &self.xspiphycompenc())
                .field("perenc", &self.perenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Miscencr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Miscencr {{ dbgenc: {=bool:?}, mco1enc: {=bool:?}, mco2enc: {=bool:?}, xspiphycompenc: {=bool:?}, perenc: {=bool:?} }}" , self . dbgenc () , self . mco1enc () , self . mco2enc () , self . xspiphycompenc () , self . perenc ())
        }
    }
    #[doc = "RCC miscellaneous configuration enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Miscenr(pub u32);
    impl Miscenr {
        #[doc = "DBG enable."]
        #[inline(always)]
        pub const fn dbgen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "DBG enable."]
        #[inline(always)]
        pub fn set_dbgen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "MCO1 enable."]
        #[inline(always)]
        pub const fn mco1en(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "MCO1 enable."]
        #[inline(always)]
        pub fn set_mco1en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "MCO2 enable."]
        #[inline(always)]
        pub const fn mco2en(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "MCO2 enable."]
        #[inline(always)]
        pub fn set_mco2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "XSPIPHYCOMP enable."]
        #[inline(always)]
        pub const fn xspiphycompen(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIPHYCOMP enable."]
        #[inline(always)]
        pub fn set_xspiphycompen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "PER enable."]
        #[inline(always)]
        pub const fn peren(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PER enable."]
        #[inline(always)]
        pub fn set_peren(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Miscenr {
        #[inline(always)]
        fn default() -> Miscenr {
            Miscenr(0)
        }
    }
    impl core::fmt::Debug for Miscenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Miscenr")
                .field("dbgen", &self.dbgen())
                .field("mco1en", &self.mco1en())
                .field("mco2en", &self.mco2en())
                .field("xspiphycompen", &self.xspiphycompen())
                .field("peren", &self.peren())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Miscenr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Miscenr {{ dbgen: {=bool:?}, mco1en: {=bool:?}, mco2en: {=bool:?}, xspiphycompen: {=bool:?}, peren: {=bool:?} }}" , self . dbgen () , self . mco1en () , self . mco2en () , self . xspiphycompen () , self . peren ())
        }
    }
    #[doc = "RCC miscellaneous enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Miscensr(pub u32);
    impl Miscensr {
        #[doc = "DBG enable."]
        #[inline(always)]
        pub const fn dbgens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "DBG enable."]
        #[inline(always)]
        pub fn set_dbgens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "MCO1 enable."]
        #[inline(always)]
        pub const fn mco1ens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "MCO1 enable."]
        #[inline(always)]
        pub fn set_mco1ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "MCO2 enable."]
        #[inline(always)]
        pub const fn mco2ens(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "MCO2 enable."]
        #[inline(always)]
        pub fn set_mco2ens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "XSPIPHYCOMP enable."]
        #[inline(always)]
        pub const fn xspiphycompens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIPHYCOMP enable."]
        #[inline(always)]
        pub fn set_xspiphycompens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "PER enable."]
        #[inline(always)]
        pub const fn perens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PER enable."]
        #[inline(always)]
        pub fn set_perens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Miscensr {
        #[inline(always)]
        fn default() -> Miscensr {
            Miscensr(0)
        }
    }
    impl core::fmt::Debug for Miscensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Miscensr")
                .field("dbgens", &self.dbgens())
                .field("mco1ens", &self.mco1ens())
                .field("mco2ens", &self.mco2ens())
                .field("xspiphycompens", &self.xspiphycompens())
                .field("perens", &self.perens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Miscensr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Miscensr {{ dbgens: {=bool:?}, mco1ens: {=bool:?}, mco2ens: {=bool:?}, xspiphycompens: {=bool:?}, perens: {=bool:?} }}" , self . dbgens () , self . mco1ens () , self . mco2ens () , self . xspiphycompens () , self . perens ())
        }
    }
    #[doc = "RCC miscellaneous Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Misclpencr(pub u32);
    impl Misclpencr {
        #[doc = "DBG sleep enable."]
        #[inline(always)]
        pub const fn dbglpenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "DBG sleep enable."]
        #[inline(always)]
        pub fn set_dbglpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "XSPIPHYCOMP sleep enable."]
        #[inline(always)]
        pub const fn xspiphycomplpenc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIPHYCOMP sleep enable."]
        #[inline(always)]
        pub fn set_xspiphycomplpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "PER sleep enable."]
        #[inline(always)]
        pub const fn perlpenc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PER sleep enable."]
        #[inline(always)]
        pub fn set_perlpenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Misclpencr {
        #[inline(always)]
        fn default() -> Misclpencr {
            Misclpencr(0)
        }
    }
    impl core::fmt::Debug for Misclpencr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Misclpencr")
                .field("dbglpenc", &self.dbglpenc())
                .field("xspiphycomplpenc", &self.xspiphycomplpenc())
                .field("perlpenc", &self.perlpenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Misclpencr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Misclpencr {{ dbglpenc: {=bool:?}, xspiphycomplpenc: {=bool:?}, perlpenc: {=bool:?} }}",
                self.dbglpenc(),
                self.xspiphycomplpenc(),
                self.perlpenc()
            )
        }
    }
    #[doc = "RCC miscellaneous configurations Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Misclpenr(pub u32);
    impl Misclpenr {
        #[doc = "DBG sleep enable."]
        #[inline(always)]
        pub const fn dbglpen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "DBG sleep enable."]
        #[inline(always)]
        pub fn set_dbglpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "XSPIPHYCOMP sleep enable."]
        #[inline(always)]
        pub const fn xspiphycomplpen(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIPHYCOMP sleep enable."]
        #[inline(always)]
        pub fn set_xspiphycomplpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "PER sleep enable."]
        #[inline(always)]
        pub const fn perlpen(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PER sleep enable."]
        #[inline(always)]
        pub fn set_perlpen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Misclpenr {
        #[inline(always)]
        fn default() -> Misclpenr {
            Misclpenr(0)
        }
    }
    impl core::fmt::Debug for Misclpenr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Misclpenr")
                .field("dbglpen", &self.dbglpen())
                .field("xspiphycomplpen", &self.xspiphycomplpen())
                .field("perlpen", &self.perlpen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Misclpenr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Misclpenr {{ dbglpen: {=bool:?}, xspiphycomplpen: {=bool:?}, perlpen: {=bool:?} }}",
                self.dbglpen(),
                self.xspiphycomplpen(),
                self.perlpen()
            )
        }
    }
    #[doc = "RCC miscellaneous Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Misclpensr(pub u32);
    impl Misclpensr {
        #[doc = "DBG sleep enable."]
        #[inline(always)]
        pub const fn dbglpens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "DBG sleep enable."]
        #[inline(always)]
        pub fn set_dbglpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "XSPIPHYCOMP sleep enable."]
        #[inline(always)]
        pub const fn xspiphycomplpens(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIPHYCOMP sleep enable."]
        #[inline(always)]
        pub fn set_xspiphycomplpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "PER sleep enable."]
        #[inline(always)]
        pub const fn perlpens(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PER sleep enable."]
        #[inline(always)]
        pub fn set_perlpens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Misclpensr {
        #[inline(always)]
        fn default() -> Misclpensr {
            Misclpensr(0)
        }
    }
    impl core::fmt::Debug for Misclpensr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Misclpensr")
                .field("dbglpens", &self.dbglpens())
                .field("xspiphycomplpens", &self.xspiphycomplpens())
                .field("perlpens", &self.perlpens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Misclpensr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Misclpensr {{ dbglpens: {=bool:?}, xspiphycomplpens: {=bool:?}, perlpens: {=bool:?} }}",
                self.dbglpens(),
                self.xspiphycomplpens(),
                self.perlpens()
            )
        }
    }
    #[doc = "RCC miscellaneous reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Miscrstcr(pub u32);
    impl Miscrstcr {
        #[doc = "DBG reset."]
        #[inline(always)]
        pub const fn dbgrstc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "DBG reset."]
        #[inline(always)]
        pub fn set_dbgrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "XSPIPHY1 reset."]
        #[inline(always)]
        pub const fn xspiphy1rstc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIPHY1 reset."]
        #[inline(always)]
        pub fn set_xspiphy1rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "XSPIPHY2 reset."]
        #[inline(always)]
        pub const fn xspiphy2rstc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIPHY2 reset."]
        #[inline(always)]
        pub fn set_xspiphy2rstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "SDMMC1DLL reset."]
        #[inline(always)]
        pub const fn sdmmc1dllrstc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC1DLL reset."]
        #[inline(always)]
        pub fn set_sdmmc1dllrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SDMMC2DLL reset."]
        #[inline(always)]
        pub const fn sdmmc2dllrstc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC2DLL reset."]
        #[inline(always)]
        pub fn set_sdmmc2dllrstc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
    }
    impl Default for Miscrstcr {
        #[inline(always)]
        fn default() -> Miscrstcr {
            Miscrstcr(0)
        }
    }
    impl core::fmt::Debug for Miscrstcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Miscrstcr")
                .field("dbgrstc", &self.dbgrstc())
                .field("xspiphy1rstc", &self.xspiphy1rstc())
                .field("xspiphy2rstc", &self.xspiphy2rstc())
                .field("sdmmc1dllrstc", &self.sdmmc1dllrstc())
                .field("sdmmc2dllrstc", &self.sdmmc2dllrstc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Miscrstcr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Miscrstcr {{ dbgrstc: {=bool:?}, xspiphy1rstc: {=bool:?}, xspiphy2rstc: {=bool:?}, sdmmc1dllrstc: {=bool:?}, sdmmc2dllrstc: {=bool:?} }}" , self . dbgrstc () , self . xspiphy1rstc () , self . xspiphy2rstc () , self . sdmmc1dllrstc () , self . sdmmc2dllrstc ())
        }
    }
    #[doc = "RCC miscellaneous configurations reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Miscrstr(pub u32);
    impl Miscrstr {
        #[doc = "DBG reset."]
        #[inline(always)]
        pub const fn dbgrst(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "DBG reset."]
        #[inline(always)]
        pub fn set_dbgrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "XSPIPHY1 reset."]
        #[inline(always)]
        pub const fn xspiphy1rst(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIPHY1 reset."]
        #[inline(always)]
        pub fn set_xspiphy1rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "XSPIPHY2 reset."]
        #[inline(always)]
        pub const fn xspiphy2rst(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIPHY2 reset."]
        #[inline(always)]
        pub fn set_xspiphy2rst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "SDMMC1DLL reset."]
        #[inline(always)]
        pub const fn sdmmc1dllrst(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC1DLL reset."]
        #[inline(always)]
        pub fn set_sdmmc1dllrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SDMMC2DLL reset."]
        #[inline(always)]
        pub const fn sdmmc2dllrst(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC2DLL reset."]
        #[inline(always)]
        pub fn set_sdmmc2dllrst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
    }
    impl Default for Miscrstr {
        #[inline(always)]
        fn default() -> Miscrstr {
            Miscrstr(0)
        }
    }
    impl core::fmt::Debug for Miscrstr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Miscrstr")
                .field("dbgrst", &self.dbgrst())
                .field("xspiphy1rst", &self.xspiphy1rst())
                .field("xspiphy2rst", &self.xspiphy2rst())
                .field("sdmmc1dllrst", &self.sdmmc1dllrst())
                .field("sdmmc2dllrst", &self.sdmmc2dllrst())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Miscrstr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Miscrstr {{ dbgrst: {=bool:?}, xspiphy1rst: {=bool:?}, xspiphy2rst: {=bool:?}, sdmmc1dllrst: {=bool:?}, sdmmc2dllrst: {=bool:?} }}" , self . dbgrst () , self . xspiphy1rst () , self . xspiphy2rst () , self . sdmmc1dllrst () , self . sdmmc2dllrst ())
        }
    }
    #[doc = "RCC miscellaneous reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Miscrstsr(pub u32);
    impl Miscrstsr {
        #[doc = "DBG reset."]
        #[inline(always)]
        pub const fn dbgrsts(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "DBG reset."]
        #[inline(always)]
        pub fn set_dbgrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "XSPIPHY1 reset."]
        #[inline(always)]
        pub const fn xspiphy1rsts(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIPHY1 reset."]
        #[inline(always)]
        pub fn set_xspiphy1rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "XSPIPHY2 reset."]
        #[inline(always)]
        pub const fn xspiphy2rsts(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "XSPIPHY2 reset."]
        #[inline(always)]
        pub fn set_xspiphy2rsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "SDMMC1DLL reset."]
        #[inline(always)]
        pub const fn sdmmc1dllrsts(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC1DLL reset."]
        #[inline(always)]
        pub fn set_sdmmc1dllrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "SDMMC2DLL reset."]
        #[inline(always)]
        pub const fn sdmmc2dllrsts(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "SDMMC2DLL reset."]
        #[inline(always)]
        pub fn set_sdmmc2dllrsts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
    }
    impl Default for Miscrstsr {
        #[inline(always)]
        fn default() -> Miscrstsr {
            Miscrstsr(0)
        }
    }
    impl core::fmt::Debug for Miscrstsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Miscrstsr")
                .field("dbgrsts", &self.dbgrsts())
                .field("xspiphy1rsts", &self.xspiphy1rsts())
                .field("xspiphy2rsts", &self.xspiphy2rsts())
                .field("sdmmc1dllrsts", &self.sdmmc1dllrsts())
                .field("sdmmc2dllrsts", &self.sdmmc2dllrsts())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Miscrstsr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Miscrstsr {{ dbgrsts: {=bool:?}, xspiphy1rsts: {=bool:?}, xspiphy2rsts: {=bool:?}, sdmmc1dllrsts: {=bool:?}, sdmmc2dllrsts: {=bool:?} }}" , self . dbgrsts () , self . xspiphy1rsts () , self . xspiphy2rsts () , self . sdmmc1dllrsts () , self . sdmmc2dllrsts ())
        }
    }
    #[doc = "RCC MSI configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Msicfgr(pub u32);
    impl Msicfgr {
        #[doc = "MSI oscillator frequency select."]
        #[inline(always)]
        pub const fn msifreqsel(&self) -> super::vals::Msifreqsel {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Msifreqsel::from_bits(val as u8)
        }
        #[doc = "MSI oscillator frequency select."]
        #[inline(always)]
        pub fn set_msifreqsel(&mut self, val: super::vals::Msifreqsel) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
        #[doc = "MSI clock trimming."]
        #[inline(always)]
        pub const fn msitrim(&self) -> u8 {
            let val = (self.0 >> 16usize) & 0x1f;
            val as u8
        }
        #[doc = "MSI clock trimming."]
        #[inline(always)]
        pub fn set_msitrim(&mut self, val: u8) {
            self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
        }
        #[doc = "MSI clock calibration."]
        #[inline(always)]
        pub const fn msical(&self) -> u8 {
            let val = (self.0 >> 23usize) & 0xff;
            val as u8
        }
        #[doc = "MSI clock calibration."]
        #[inline(always)]
        pub fn set_msical(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 23usize)) | (((val as u32) & 0xff) << 23usize);
        }
    }
    impl Default for Msicfgr {
        #[inline(always)]
        fn default() -> Msicfgr {
            Msicfgr(0)
        }
    }
    impl core::fmt::Debug for Msicfgr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Msicfgr")
                .field("msifreqsel", &self.msifreqsel())
                .field("msitrim", &self.msitrim())
                .field("msical", &self.msical())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Msicfgr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Msicfgr {{ msifreqsel: {:?}, msitrim: {=u8:?}, msical: {=u8:?} }}",
                self.msifreqsel(),
                self.msitrim(),
                self.msical()
            )
        }
    }
    #[doc = "RCC PLL1 configuration register 1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll1cfgr1(pub u32);
    impl Pll1cfgr1 {
        #[doc = "PLL1 Integer part for the VCO multiplication factor."]
        #[inline(always)]
        pub const fn plldivn(&self, n: usize) -> u16 {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            let val = (self.0 >> offs) & 0x0fff;
            val as u16
        }
        #[doc = "PLL1 Integer part for the VCO multiplication factor."]
        #[inline(always)]
        pub fn set_plldivn(&mut self, n: usize, val: u16) {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            self.0 = (self.0 & !(0x0fff << offs)) | (((val as u32) & 0x0fff) << offs);
        }
        #[doc = "PLL1 reference input clock divide frequency ratio."]
        #[inline(always)]
        pub const fn plldivm(&self, n: usize) -> super::vals::Plldivm {
            assert!(n < 1usize);
            let offs = 20usize + n * 0usize;
            let val = (self.0 >> offs) & 0x3f;
            super::vals::Plldivm::from_bits(val as u8)
        }
        #[doc = "PLL1 reference input clock divide frequency ratio."]
        #[inline(always)]
        pub fn set_plldivm(&mut self, n: usize, val: super::vals::Plldivm) {
            assert!(n < 1usize);
            let offs = 20usize + n * 0usize;
            self.0 = (self.0 & !(0x3f << offs)) | (((val.to_bits() as u32) & 0x3f) << offs);
        }
        #[doc = "PLL1 bypass."]
        #[inline(always)]
        pub const fn pllbyp(&self, n: usize) -> super::vals::Pllbyp {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllbyp::from_bits(val as u8)
        }
        #[doc = "PLL1 bypass."]
        #[inline(always)]
        pub fn set_pllbyp(&mut self, n: usize, val: super::vals::Pllbyp) {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "PLL1 source selection of the reference clock."]
        #[inline(always)]
        pub const fn pllsel(&self, n: usize) -> super::vals::Pllsel {
            assert!(n < 1usize);
            let offs = 28usize + n * 0usize;
            let val = (self.0 >> offs) & 0x07;
            super::vals::Pllsel::from_bits(val as u8)
        }
        #[doc = "PLL1 source selection of the reference clock."]
        #[inline(always)]
        pub fn set_pllsel(&mut self, n: usize, val: super::vals::Pllsel) {
            assert!(n < 1usize);
            let offs = 28usize + n * 0usize;
            self.0 = (self.0 & !(0x07 << offs)) | (((val.to_bits() as u32) & 0x07) << offs);
        }
    }
    impl Default for Pll1cfgr1 {
        #[inline(always)]
        fn default() -> Pll1cfgr1 {
            Pll1cfgr1(0)
        }
    }
    impl core::fmt::Debug for Pll1cfgr1 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pll1cfgr1")
                .field("plldivn[0]", &self.plldivn(0usize))
                .field("plldivm[0]", &self.plldivm(0usize))
                .field("pllbyp[0]", &self.pllbyp(0usize))
                .field("pllsel[0]", &self.pllsel(0usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pll1cfgr1 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Pll1cfgr1 {{ plldivn[0]: {=u16:?}, plldivm[0]: {:?}, pllbyp[0]: {:?}, pllsel[0]: {:?} }}",
                self.plldivn(0usize),
                self.plldivm(0usize),
                self.pllbyp(0usize),
                self.pllsel(0usize)
            )
        }
    }
    #[doc = "RCC PLL1 configuration register 2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll1cfgr2(pub u32);
    impl Pll1cfgr2 {
        #[doc = "PLL1 Fractional part of the VCO multiplication factor."]
        #[inline(always)]
        pub const fn plldivnfrac(&self, n: usize) -> u32 {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            let val = (self.0 >> offs) & 0x00ff_ffff;
            val as u32
        }
        #[doc = "PLL1 Fractional part of the VCO multiplication factor."]
        #[inline(always)]
        pub fn set_plldivnfrac(&mut self, n: usize, val: u32) {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            self.0 = (self.0 & !(0x00ff_ffff << offs)) | (((val as u32) & 0x00ff_ffff) << offs);
        }
    }
    impl Default for Pll1cfgr2 {
        #[inline(always)]
        fn default() -> Pll1cfgr2 {
            Pll1cfgr2(0)
        }
    }
    impl core::fmt::Debug for Pll1cfgr2 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pll1cfgr2")
                .field("plldivnfrac[0]", &self.plldivnfrac(0usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pll1cfgr2 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(f, "Pll1cfgr2 {{ plldivnfrac[0]: {=u32:?} }}", self.plldivnfrac(0usize))
        }
    }
    #[doc = "RCC PLL1 configuration register 3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll1cfgr3(pub u32);
    impl Pll1cfgr3 {
        #[doc = "PLL1 Modulation Spread Spectrum reset."]
        #[inline(always)]
        pub const fn pllmodssrst(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL1 Modulation Spread Spectrum reset."]
        #[inline(always)]
        pub fn set_pllmodssrst(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "PLL1 noise canceling DAC enable in fractional mode."]
        #[inline(always)]
        pub const fn plldacen(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 1usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL1 noise canceling DAC enable in fractional mode."]
        #[inline(always)]
        pub fn set_plldacen(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 1usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "PLL1 Modulation Spread-Spectrum Disable."]
        #[inline(always)]
        pub const fn pllmodssdis(&self, n: usize) -> super::vals::Pllmodssdis {
            assert!(n < 1usize);
            let offs = 2usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllmodssdis::from_bits(val as u8)
        }
        #[doc = "PLL1 Modulation Spread-Spectrum Disable."]
        #[inline(always)]
        pub fn set_pllmodssdis(&mut self, n: usize, val: super::vals::Pllmodssdis) {
            assert!(n < 1usize);
            let offs = 2usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "PLL1 Modulation Spread-Spectrum (and Fractional Divide) enable."]
        #[inline(always)]
        pub const fn pllmoddsen(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 3usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL1 Modulation Spread-Spectrum (and Fractional Divide) enable."]
        #[inline(always)]
        pub fn set_pllmoddsen(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 3usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "PLL1 Modulation Spread-Spectrum Down."]
        #[inline(always)]
        pub const fn pllmodsprdw(&self, n: usize) -> super::vals::Pllmodsprdw {
            assert!(n < 1usize);
            let offs = 4usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllmodsprdw::from_bits(val as u8)
        }
        #[doc = "PLL1 Modulation Spread-Spectrum Down."]
        #[inline(always)]
        pub fn set_pllmodsprdw(&mut self, n: usize, val: super::vals::Pllmodsprdw) {
            assert!(n < 1usize);
            let offs = 4usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "PLL1 Modulation Division frequency adjustment."]
        #[inline(always)]
        pub const fn pllmoddiv(&self, n: usize) -> u8 {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            let val = (self.0 >> offs) & 0x0f;
            val as u8
        }
        #[doc = "PLL1 Modulation Division frequency adjustment."]
        #[inline(always)]
        pub fn set_pllmoddiv(&mut self, n: usize, val: u8) {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            self.0 = (self.0 & !(0x0f << offs)) | (((val as u32) & 0x0f) << offs);
        }
        #[doc = "PLL1 Modulation Spread depth adjustment."]
        #[inline(always)]
        pub const fn pllmodspr(&self, n: usize) -> u8 {
            assert!(n < 1usize);
            let offs = 16usize + n * 0usize;
            let val = (self.0 >> offs) & 0x1f;
            val as u8
        }
        #[doc = "PLL1 Modulation Spread depth adjustment."]
        #[inline(always)]
        pub fn set_pllmodspr(&mut self, n: usize, val: u8) {
            assert!(n < 1usize);
            let offs = 16usize + n * 0usize;
            self.0 = (self.0 & !(0x1f << offs)) | (((val as u32) & 0x1f) << offs);
        }
        #[doc = "PLL1 VCO frequency divider level 2."]
        #[inline(always)]
        pub const fn pllpdiv2(&self, n: usize) -> super::vals::Pllpdiv {
            assert!(n < 1usize);
            let offs = 24usize + n * 0usize;
            let val = (self.0 >> offs) & 0x07;
            super::vals::Pllpdiv::from_bits(val as u8)
        }
        #[doc = "PLL1 VCO frequency divider level 2."]
        #[inline(always)]
        pub fn set_pllpdiv2(&mut self, n: usize, val: super::vals::Pllpdiv) {
            assert!(n < 1usize);
            let offs = 24usize + n * 0usize;
            self.0 = (self.0 & !(0x07 << offs)) | (((val.to_bits() as u32) & 0x07) << offs);
        }
        #[doc = "PLL1 VCO frequency divider level 1."]
        #[inline(always)]
        pub const fn pllpdiv1(&self, n: usize) -> super::vals::Pllpdiv {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            let val = (self.0 >> offs) & 0x07;
            super::vals::Pllpdiv::from_bits(val as u8)
        }
        #[doc = "PLL1 VCO frequency divider level 1."]
        #[inline(always)]
        pub fn set_pllpdiv1(&mut self, n: usize, val: super::vals::Pllpdiv) {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            self.0 = (self.0 & !(0x07 << offs)) | (((val.to_bits() as u32) & 0x07) << offs);
        }
        #[doc = "PLL1 post divider POSTDIV1, POSTDIV2, and PLL clock output enable."]
        #[inline(always)]
        pub const fn pllpdiven(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 30usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL1 post divider POSTDIV1, POSTDIV2, and PLL clock output enable."]
        #[inline(always)]
        pub fn set_pllpdiven(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 30usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Pll1cfgr3 {
        #[inline(always)]
        fn default() -> Pll1cfgr3 {
            Pll1cfgr3(0)
        }
    }
    impl core::fmt::Debug for Pll1cfgr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pll1cfgr3")
                .field("pllmodssrst[0]", &self.pllmodssrst(0usize))
                .field("plldacen[0]", &self.plldacen(0usize))
                .field("pllmodssdis[0]", &self.pllmodssdis(0usize))
                .field("pllmoddsen[0]", &self.pllmoddsen(0usize))
                .field("pllmodsprdw[0]", &self.pllmodsprdw(0usize))
                .field("pllmoddiv[0]", &self.pllmoddiv(0usize))
                .field("pllmodspr[0]", &self.pllmodspr(0usize))
                .field("pllpdiv2[0]", &self.pllpdiv2(0usize))
                .field("pllpdiv1[0]", &self.pllpdiv1(0usize))
                .field("pllpdiven[0]", &self.pllpdiven(0usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pll1cfgr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pll1cfgr3 {{ pllmodssrst[0]: {=bool:?}, plldacen[0]: {=bool:?}, pllmodssdis[0]: {:?}, pllmoddsen[0]: {=bool:?}, pllmodsprdw[0]: {:?}, pllmoddiv[0]: {=u8:?}, pllmodspr[0]: {=u8:?}, pllpdiv2[0]: {:?}, pllpdiv1[0]: {:?}, pllpdiven[0]: {=bool:?} }}" , self . pllmodssrst (0usize) , self . plldacen (0usize) , self . pllmodssdis (0usize) , self . pllmoddsen (0usize) , self . pllmodsprdw (0usize) , self . pllmoddiv (0usize) , self . pllmodspr (0usize) , self . pllpdiv2 (0usize) , self . pllpdiv1 (0usize) , self . pllpdiven (0usize))
        }
    }
    #[doc = "RCC PLL2 configuration register 1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll2cfgr1(pub u32);
    impl Pll2cfgr1 {
        #[doc = "PLL2 Integer part for the VCO multiplication factor."]
        #[inline(always)]
        pub const fn plldivn(&self, n: usize) -> u16 {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            let val = (self.0 >> offs) & 0x0fff;
            val as u16
        }
        #[doc = "PLL2 Integer part for the VCO multiplication factor."]
        #[inline(always)]
        pub fn set_plldivn(&mut self, n: usize, val: u16) {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            self.0 = (self.0 & !(0x0fff << offs)) | (((val as u32) & 0x0fff) << offs);
        }
        #[doc = "PLL2 reference input clock divide frequency ratio."]
        #[inline(always)]
        pub const fn plldivm(&self, n: usize) -> super::vals::Plldivm {
            assert!(n < 1usize);
            let offs = 20usize + n * 0usize;
            let val = (self.0 >> offs) & 0x3f;
            super::vals::Plldivm::from_bits(val as u8)
        }
        #[doc = "PLL2 reference input clock divide frequency ratio."]
        #[inline(always)]
        pub fn set_plldivm(&mut self, n: usize, val: super::vals::Plldivm) {
            assert!(n < 1usize);
            let offs = 20usize + n * 0usize;
            self.0 = (self.0 & !(0x3f << offs)) | (((val.to_bits() as u32) & 0x3f) << offs);
        }
        #[doc = "PLL2 bypass."]
        #[inline(always)]
        pub const fn pllbyp(&self, n: usize) -> super::vals::Pllbyp {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllbyp::from_bits(val as u8)
        }
        #[doc = "PLL2 bypass."]
        #[inline(always)]
        pub fn set_pllbyp(&mut self, n: usize, val: super::vals::Pllbyp) {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "PLL2 source selection of the reference clock."]
        #[inline(always)]
        pub const fn pllsel(&self, n: usize) -> super::vals::Pllsel {
            assert!(n < 1usize);
            let offs = 28usize + n * 0usize;
            let val = (self.0 >> offs) & 0x07;
            super::vals::Pllsel::from_bits(val as u8)
        }
        #[doc = "PLL2 source selection of the reference clock."]
        #[inline(always)]
        pub fn set_pllsel(&mut self, n: usize, val: super::vals::Pllsel) {
            assert!(n < 1usize);
            let offs = 28usize + n * 0usize;
            self.0 = (self.0 & !(0x07 << offs)) | (((val.to_bits() as u32) & 0x07) << offs);
        }
    }
    impl Default for Pll2cfgr1 {
        #[inline(always)]
        fn default() -> Pll2cfgr1 {
            Pll2cfgr1(0)
        }
    }
    impl core::fmt::Debug for Pll2cfgr1 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pll2cfgr1")
                .field("plldivn[0]", &self.plldivn(0usize))
                .field("plldivm[0]", &self.plldivm(0usize))
                .field("pllbyp[0]", &self.pllbyp(0usize))
                .field("pllsel[0]", &self.pllsel(0usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pll2cfgr1 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Pll2cfgr1 {{ plldivn[0]: {=u16:?}, plldivm[0]: {:?}, pllbyp[0]: {:?}, pllsel[0]: {:?} }}",
                self.plldivn(0usize),
                self.plldivm(0usize),
                self.pllbyp(0usize),
                self.pllsel(0usize)
            )
        }
    }
    #[doc = "RCC PLL2 configuration register 2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll2cfgr2(pub u32);
    impl Pll2cfgr2 {
        #[doc = "PLL2 Fractional part of the VCO multiplication factor."]
        #[inline(always)]
        pub const fn plldivnfrac(&self, n: usize) -> u32 {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            let val = (self.0 >> offs) & 0x00ff_ffff;
            val as u32
        }
        #[doc = "PLL2 Fractional part of the VCO multiplication factor."]
        #[inline(always)]
        pub fn set_plldivnfrac(&mut self, n: usize, val: u32) {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            self.0 = (self.0 & !(0x00ff_ffff << offs)) | (((val as u32) & 0x00ff_ffff) << offs);
        }
    }
    impl Default for Pll2cfgr2 {
        #[inline(always)]
        fn default() -> Pll2cfgr2 {
            Pll2cfgr2(0)
        }
    }
    impl core::fmt::Debug for Pll2cfgr2 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pll2cfgr2")
                .field("plldivnfrac[0]", &self.plldivnfrac(0usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pll2cfgr2 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(f, "Pll2cfgr2 {{ plldivnfrac[0]: {=u32:?} }}", self.plldivnfrac(0usize))
        }
    }
    #[doc = "RCC PLL2 configuration register 3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll2cfgr3(pub u32);
    impl Pll2cfgr3 {
        #[doc = "PLL2 Modulation Spread Spectrum reset."]
        #[inline(always)]
        pub const fn pllmodssrst(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL2 Modulation Spread Spectrum reset."]
        #[inline(always)]
        pub fn set_pllmodssrst(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "PLL2 noise canceling DAC enable in fractional mode."]
        #[inline(always)]
        pub const fn plldacen(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 1usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL2 noise canceling DAC enable in fractional mode."]
        #[inline(always)]
        pub fn set_plldacen(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 1usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "PLL2 Modulation Spread-Spectrum Disable."]
        #[inline(always)]
        pub const fn pllmodssdis(&self, n: usize) -> super::vals::Pllmodssdis {
            assert!(n < 1usize);
            let offs = 2usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllmodssdis::from_bits(val as u8)
        }
        #[doc = "PLL2 Modulation Spread-Spectrum Disable."]
        #[inline(always)]
        pub fn set_pllmodssdis(&mut self, n: usize, val: super::vals::Pllmodssdis) {
            assert!(n < 1usize);
            let offs = 2usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "PLL2 Modulation Spread-Spectrum (and Fractional Divide) enable."]
        #[inline(always)]
        pub const fn pllmoddsen(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 3usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL2 Modulation Spread-Spectrum (and Fractional Divide) enable."]
        #[inline(always)]
        pub fn set_pllmoddsen(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 3usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "PLL2 Modulation Down Spread."]
        #[inline(always)]
        pub const fn pllmodsprdw(&self, n: usize) -> super::vals::Pllmodsprdw {
            assert!(n < 1usize);
            let offs = 4usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllmodsprdw::from_bits(val as u8)
        }
        #[doc = "PLL2 Modulation Down Spread."]
        #[inline(always)]
        pub fn set_pllmodsprdw(&mut self, n: usize, val: super::vals::Pllmodsprdw) {
            assert!(n < 1usize);
            let offs = 4usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "PLL2 Modulation Division frequency adjustment."]
        #[inline(always)]
        pub const fn pllmoddiv(&self, n: usize) -> u8 {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            let val = (self.0 >> offs) & 0x0f;
            val as u8
        }
        #[doc = "PLL2 Modulation Division frequency adjustment."]
        #[inline(always)]
        pub fn set_pllmoddiv(&mut self, n: usize, val: u8) {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            self.0 = (self.0 & !(0x0f << offs)) | (((val as u32) & 0x0f) << offs);
        }
        #[doc = "PLL2 Modulation Spread depth adjustment."]
        #[inline(always)]
        pub const fn pllmodspr(&self, n: usize) -> u8 {
            assert!(n < 1usize);
            let offs = 16usize + n * 0usize;
            let val = (self.0 >> offs) & 0x1f;
            val as u8
        }
        #[doc = "PLL2 Modulation Spread depth adjustment."]
        #[inline(always)]
        pub fn set_pllmodspr(&mut self, n: usize, val: u8) {
            assert!(n < 1usize);
            let offs = 16usize + n * 0usize;
            self.0 = (self.0 & !(0x1f << offs)) | (((val as u32) & 0x1f) << offs);
        }
        #[doc = "PLL2 VCO frequency divider level 2."]
        #[inline(always)]
        pub const fn pllpdiv2(&self, n: usize) -> super::vals::Pllpdiv {
            assert!(n < 1usize);
            let offs = 24usize + n * 0usize;
            let val = (self.0 >> offs) & 0x07;
            super::vals::Pllpdiv::from_bits(val as u8)
        }
        #[doc = "PLL2 VCO frequency divider level 2."]
        #[inline(always)]
        pub fn set_pllpdiv2(&mut self, n: usize, val: super::vals::Pllpdiv) {
            assert!(n < 1usize);
            let offs = 24usize + n * 0usize;
            self.0 = (self.0 & !(0x07 << offs)) | (((val.to_bits() as u32) & 0x07) << offs);
        }
        #[doc = "PLL2 VCO frequency divider level 1."]
        #[inline(always)]
        pub const fn pllpdiv1(&self, n: usize) -> super::vals::Pllpdiv {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            let val = (self.0 >> offs) & 0x07;
            super::vals::Pllpdiv::from_bits(val as u8)
        }
        #[doc = "PLL2 VCO frequency divider level 1."]
        #[inline(always)]
        pub fn set_pllpdiv1(&mut self, n: usize, val: super::vals::Pllpdiv) {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            self.0 = (self.0 & !(0x07 << offs)) | (((val.to_bits() as u32) & 0x07) << offs);
        }
        #[doc = "PLL2 post divider POSTDIV1, POSTDIV2, and PLL clock output enable."]
        #[inline(always)]
        pub const fn pllpdiven(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 30usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL2 post divider POSTDIV1, POSTDIV2, and PLL clock output enable."]
        #[inline(always)]
        pub fn set_pllpdiven(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 30usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Pll2cfgr3 {
        #[inline(always)]
        fn default() -> Pll2cfgr3 {
            Pll2cfgr3(0)
        }
    }
    impl core::fmt::Debug for Pll2cfgr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pll2cfgr3")
                .field("pllmodssrst[0]", &self.pllmodssrst(0usize))
                .field("plldacen[0]", &self.plldacen(0usize))
                .field("pllmodssdis[0]", &self.pllmodssdis(0usize))
                .field("pllmoddsen[0]", &self.pllmoddsen(0usize))
                .field("pllmodsprdw[0]", &self.pllmodsprdw(0usize))
                .field("pllmoddiv[0]", &self.pllmoddiv(0usize))
                .field("pllmodspr[0]", &self.pllmodspr(0usize))
                .field("pllpdiv2[0]", &self.pllpdiv2(0usize))
                .field("pllpdiv1[0]", &self.pllpdiv1(0usize))
                .field("pllpdiven[0]", &self.pllpdiven(0usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pll2cfgr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pll2cfgr3 {{ pllmodssrst[0]: {=bool:?}, plldacen[0]: {=bool:?}, pllmodssdis[0]: {:?}, pllmoddsen[0]: {=bool:?}, pllmodsprdw[0]: {:?}, pllmoddiv[0]: {=u8:?}, pllmodspr[0]: {=u8:?}, pllpdiv2[0]: {:?}, pllpdiv1[0]: {:?}, pllpdiven[0]: {=bool:?} }}" , self . pllmodssrst (0usize) , self . plldacen (0usize) , self . pllmodssdis (0usize) , self . pllmoddsen (0usize) , self . pllmodsprdw (0usize) , self . pllmoddiv (0usize) , self . pllmodspr (0usize) , self . pllpdiv2 (0usize) , self . pllpdiv1 (0usize) , self . pllpdiven (0usize))
        }
    }
    #[doc = "RCC PLL3 configuration register 1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll3cfgr1(pub u32);
    impl Pll3cfgr1 {
        #[doc = "PLL3 Integer part for the VCO multiplication factor."]
        #[inline(always)]
        pub const fn plldivn(&self, n: usize) -> u16 {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            let val = (self.0 >> offs) & 0x0fff;
            val as u16
        }
        #[doc = "PLL3 Integer part for the VCO multiplication factor."]
        #[inline(always)]
        pub fn set_plldivn(&mut self, n: usize, val: u16) {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            self.0 = (self.0 & !(0x0fff << offs)) | (((val as u32) & 0x0fff) << offs);
        }
        #[doc = "PLL3 reference input clock divide frequency ratio."]
        #[inline(always)]
        pub const fn plldivm(&self, n: usize) -> super::vals::Plldivm {
            assert!(n < 1usize);
            let offs = 20usize + n * 0usize;
            let val = (self.0 >> offs) & 0x3f;
            super::vals::Plldivm::from_bits(val as u8)
        }
        #[doc = "PLL3 reference input clock divide frequency ratio."]
        #[inline(always)]
        pub fn set_plldivm(&mut self, n: usize, val: super::vals::Plldivm) {
            assert!(n < 1usize);
            let offs = 20usize + n * 0usize;
            self.0 = (self.0 & !(0x3f << offs)) | (((val.to_bits() as u32) & 0x3f) << offs);
        }
        #[doc = "PLL3 bypass."]
        #[inline(always)]
        pub const fn pllbyp(&self, n: usize) -> super::vals::Pllbyp {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllbyp::from_bits(val as u8)
        }
        #[doc = "PLL3 bypass."]
        #[inline(always)]
        pub fn set_pllbyp(&mut self, n: usize, val: super::vals::Pllbyp) {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "PLL3 source selection of the reference clock."]
        #[inline(always)]
        pub const fn pllsel(&self, n: usize) -> super::vals::Pllsel {
            assert!(n < 1usize);
            let offs = 28usize + n * 0usize;
            let val = (self.0 >> offs) & 0x07;
            super::vals::Pllsel::from_bits(val as u8)
        }
        #[doc = "PLL3 source selection of the reference clock."]
        #[inline(always)]
        pub fn set_pllsel(&mut self, n: usize, val: super::vals::Pllsel) {
            assert!(n < 1usize);
            let offs = 28usize + n * 0usize;
            self.0 = (self.0 & !(0x07 << offs)) | (((val.to_bits() as u32) & 0x07) << offs);
        }
    }
    impl Default for Pll3cfgr1 {
        #[inline(always)]
        fn default() -> Pll3cfgr1 {
            Pll3cfgr1(0)
        }
    }
    impl core::fmt::Debug for Pll3cfgr1 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pll3cfgr1")
                .field("plldivn[0]", &self.plldivn(0usize))
                .field("plldivm[0]", &self.plldivm(0usize))
                .field("pllbyp[0]", &self.pllbyp(0usize))
                .field("pllsel[0]", &self.pllsel(0usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pll3cfgr1 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Pll3cfgr1 {{ plldivn[0]: {=u16:?}, plldivm[0]: {:?}, pllbyp[0]: {:?}, pllsel[0]: {:?} }}",
                self.plldivn(0usize),
                self.plldivm(0usize),
                self.pllbyp(0usize),
                self.pllsel(0usize)
            )
        }
    }
    #[doc = "RCC PLL3 configuration register 2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll3cfgr2(pub u32);
    impl Pll3cfgr2 {
        #[doc = "PLL3 Fractional part of the VCO multiplication factor."]
        #[inline(always)]
        pub const fn plldivnfrac(&self, n: usize) -> u32 {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            let val = (self.0 >> offs) & 0x00ff_ffff;
            val as u32
        }
        #[doc = "PLL3 Fractional part of the VCO multiplication factor."]
        #[inline(always)]
        pub fn set_plldivnfrac(&mut self, n: usize, val: u32) {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            self.0 = (self.0 & !(0x00ff_ffff << offs)) | (((val as u32) & 0x00ff_ffff) << offs);
        }
    }
    impl Default for Pll3cfgr2 {
        #[inline(always)]
        fn default() -> Pll3cfgr2 {
            Pll3cfgr2(0)
        }
    }
    impl core::fmt::Debug for Pll3cfgr2 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pll3cfgr2")
                .field("plldivnfrac[0]", &self.plldivnfrac(0usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pll3cfgr2 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(f, "Pll3cfgr2 {{ plldivnfrac[0]: {=u32:?} }}", self.plldivnfrac(0usize))
        }
    }
    #[doc = "RCC PLL3 configuration register 3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll3cfgr3(pub u32);
    impl Pll3cfgr3 {
        #[doc = "PLL3 Modulation Spread Spectrum reset."]
        #[inline(always)]
        pub const fn pllmodssrst(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL3 Modulation Spread Spectrum reset."]
        #[inline(always)]
        pub fn set_pllmodssrst(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "PLL3 noise canceling DAC enable in fractional mode."]
        #[inline(always)]
        pub const fn plldacen(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 1usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL3 noise canceling DAC enable in fractional mode."]
        #[inline(always)]
        pub fn set_plldacen(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 1usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "PLL3 Modulation Spread-Spectrum Disable."]
        #[inline(always)]
        pub const fn pllmodssdis(&self, n: usize) -> super::vals::Pllmodssdis {
            assert!(n < 1usize);
            let offs = 2usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllmodssdis::from_bits(val as u8)
        }
        #[doc = "PLL3 Modulation Spread-Spectrum Disable."]
        #[inline(always)]
        pub fn set_pllmodssdis(&mut self, n: usize, val: super::vals::Pllmodssdis) {
            assert!(n < 1usize);
            let offs = 2usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "PLL3 Modulation Spread-Spectrum (and Fractional Divide) enable."]
        #[inline(always)]
        pub const fn pllmoddsen(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 3usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL3 Modulation Spread-Spectrum (and Fractional Divide) enable."]
        #[inline(always)]
        pub fn set_pllmoddsen(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 3usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "PLL3 Modulation Down Spread."]
        #[inline(always)]
        pub const fn pllmodsprdw(&self, n: usize) -> super::vals::Pllmodsprdw {
            assert!(n < 1usize);
            let offs = 4usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllmodsprdw::from_bits(val as u8)
        }
        #[doc = "PLL3 Modulation Down Spread."]
        #[inline(always)]
        pub fn set_pllmodsprdw(&mut self, n: usize, val: super::vals::Pllmodsprdw) {
            assert!(n < 1usize);
            let offs = 4usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "PLL3 Modulation Division frequency adjustment."]
        #[inline(always)]
        pub const fn pllmoddiv(&self, n: usize) -> u8 {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            let val = (self.0 >> offs) & 0x0f;
            val as u8
        }
        #[doc = "PLL3 Modulation Division frequency adjustment."]
        #[inline(always)]
        pub fn set_pllmoddiv(&mut self, n: usize, val: u8) {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            self.0 = (self.0 & !(0x0f << offs)) | (((val as u32) & 0x0f) << offs);
        }
        #[doc = "PLL3 Modulation Spread depth adjustment."]
        #[inline(always)]
        pub const fn pllmodspr(&self, n: usize) -> u8 {
            assert!(n < 1usize);
            let offs = 16usize + n * 0usize;
            let val = (self.0 >> offs) & 0x1f;
            val as u8
        }
        #[doc = "PLL3 Modulation Spread depth adjustment."]
        #[inline(always)]
        pub fn set_pllmodspr(&mut self, n: usize, val: u8) {
            assert!(n < 1usize);
            let offs = 16usize + n * 0usize;
            self.0 = (self.0 & !(0x1f << offs)) | (((val as u32) & 0x1f) << offs);
        }
        #[doc = "PLL3 VCO frequency divider level 2."]
        #[inline(always)]
        pub const fn pllpdiv2(&self, n: usize) -> super::vals::Pllpdiv {
            assert!(n < 1usize);
            let offs = 24usize + n * 0usize;
            let val = (self.0 >> offs) & 0x07;
            super::vals::Pllpdiv::from_bits(val as u8)
        }
        #[doc = "PLL3 VCO frequency divider level 2."]
        #[inline(always)]
        pub fn set_pllpdiv2(&mut self, n: usize, val: super::vals::Pllpdiv) {
            assert!(n < 1usize);
            let offs = 24usize + n * 0usize;
            self.0 = (self.0 & !(0x07 << offs)) | (((val.to_bits() as u32) & 0x07) << offs);
        }
        #[doc = "PLL3 VCO frequency divider level 1."]
        #[inline(always)]
        pub const fn pllpdiv1(&self, n: usize) -> super::vals::Pllpdiv {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            let val = (self.0 >> offs) & 0x07;
            super::vals::Pllpdiv::from_bits(val as u8)
        }
        #[doc = "PLL3 VCO frequency divider level 1."]
        #[inline(always)]
        pub fn set_pllpdiv1(&mut self, n: usize, val: super::vals::Pllpdiv) {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            self.0 = (self.0 & !(0x07 << offs)) | (((val.to_bits() as u32) & 0x07) << offs);
        }
        #[doc = "PLL3 post divider POSTDIV1, POSTDIV2, and PLL clock output enable."]
        #[inline(always)]
        pub const fn pllpdiven(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 30usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL3 post divider POSTDIV1, POSTDIV2, and PLL clock output enable."]
        #[inline(always)]
        pub fn set_pllpdiven(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 30usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Pll3cfgr3 {
        #[inline(always)]
        fn default() -> Pll3cfgr3 {
            Pll3cfgr3(0)
        }
    }
    impl core::fmt::Debug for Pll3cfgr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pll3cfgr3")
                .field("pllmodssrst[0]", &self.pllmodssrst(0usize))
                .field("plldacen[0]", &self.plldacen(0usize))
                .field("pllmodssdis[0]", &self.pllmodssdis(0usize))
                .field("pllmoddsen[0]", &self.pllmoddsen(0usize))
                .field("pllmodsprdw[0]", &self.pllmodsprdw(0usize))
                .field("pllmoddiv[0]", &self.pllmoddiv(0usize))
                .field("pllmodspr[0]", &self.pllmodspr(0usize))
                .field("pllpdiv2[0]", &self.pllpdiv2(0usize))
                .field("pllpdiv1[0]", &self.pllpdiv1(0usize))
                .field("pllpdiven[0]", &self.pllpdiven(0usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pll3cfgr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pll3cfgr3 {{ pllmodssrst[0]: {=bool:?}, plldacen[0]: {=bool:?}, pllmodssdis[0]: {:?}, pllmoddsen[0]: {=bool:?}, pllmodsprdw[0]: {:?}, pllmoddiv[0]: {=u8:?}, pllmodspr[0]: {=u8:?}, pllpdiv2[0]: {:?}, pllpdiv1[0]: {:?}, pllpdiven[0]: {=bool:?} }}" , self . pllmodssrst (0usize) , self . plldacen (0usize) , self . pllmodssdis (0usize) , self . pllmoddsen (0usize) , self . pllmodsprdw (0usize) , self . pllmoddiv (0usize) , self . pllmodspr (0usize) , self . pllpdiv2 (0usize) , self . pllpdiv1 (0usize) , self . pllpdiven (0usize))
        }
    }
    #[doc = "RCC PLL4 configuration register 1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll4cfgr1(pub u32);
    impl Pll4cfgr1 {
        #[doc = "PLL4 Integer part for the VCO multiplication factor."]
        #[inline(always)]
        pub const fn plldivn(&self, n: usize) -> u16 {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            let val = (self.0 >> offs) & 0x0fff;
            val as u16
        }
        #[doc = "PLL4 Integer part for the VCO multiplication factor."]
        #[inline(always)]
        pub fn set_plldivn(&mut self, n: usize, val: u16) {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            self.0 = (self.0 & !(0x0fff << offs)) | (((val as u32) & 0x0fff) << offs);
        }
        #[doc = "PLL4 reference input clock divide frequency ratio."]
        #[inline(always)]
        pub const fn plldivm(&self, n: usize) -> super::vals::Plldivm {
            assert!(n < 1usize);
            let offs = 20usize + n * 0usize;
            let val = (self.0 >> offs) & 0x3f;
            super::vals::Plldivm::from_bits(val as u8)
        }
        #[doc = "PLL4 reference input clock divide frequency ratio."]
        #[inline(always)]
        pub fn set_plldivm(&mut self, n: usize, val: super::vals::Plldivm) {
            assert!(n < 1usize);
            let offs = 20usize + n * 0usize;
            self.0 = (self.0 & !(0x3f << offs)) | (((val.to_bits() as u32) & 0x3f) << offs);
        }
        #[doc = "PLL4 bypass."]
        #[inline(always)]
        pub const fn pllbyp(&self, n: usize) -> super::vals::Pllbyp {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllbyp::from_bits(val as u8)
        }
        #[doc = "PLL4 bypass."]
        #[inline(always)]
        pub fn set_pllbyp(&mut self, n: usize, val: super::vals::Pllbyp) {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "PLL4 source selection of the reference clock."]
        #[inline(always)]
        pub const fn pllsel(&self, n: usize) -> super::vals::Pllsel {
            assert!(n < 1usize);
            let offs = 28usize + n * 0usize;
            let val = (self.0 >> offs) & 0x07;
            super::vals::Pllsel::from_bits(val as u8)
        }
        #[doc = "PLL4 source selection of the reference clock."]
        #[inline(always)]
        pub fn set_pllsel(&mut self, n: usize, val: super::vals::Pllsel) {
            assert!(n < 1usize);
            let offs = 28usize + n * 0usize;
            self.0 = (self.0 & !(0x07 << offs)) | (((val.to_bits() as u32) & 0x07) << offs);
        }
    }
    impl Default for Pll4cfgr1 {
        #[inline(always)]
        fn default() -> Pll4cfgr1 {
            Pll4cfgr1(0)
        }
    }
    impl core::fmt::Debug for Pll4cfgr1 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pll4cfgr1")
                .field("plldivn[0]", &self.plldivn(0usize))
                .field("plldivm[0]", &self.plldivm(0usize))
                .field("pllbyp[0]", &self.pllbyp(0usize))
                .field("pllsel[0]", &self.pllsel(0usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pll4cfgr1 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Pll4cfgr1 {{ plldivn[0]: {=u16:?}, plldivm[0]: {:?}, pllbyp[0]: {:?}, pllsel[0]: {:?} }}",
                self.plldivn(0usize),
                self.plldivm(0usize),
                self.pllbyp(0usize),
                self.pllsel(0usize)
            )
        }
    }
    #[doc = "RCC PLL4 configuration register 2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll4cfgr2(pub u32);
    impl Pll4cfgr2 {
        #[doc = "PLL4 Fractional part of the VCO multiplication factor."]
        #[inline(always)]
        pub const fn plldivnfrac(&self, n: usize) -> u32 {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            let val = (self.0 >> offs) & 0x00ff_ffff;
            val as u32
        }
        #[doc = "PLL4 Fractional part of the VCO multiplication factor."]
        #[inline(always)]
        pub fn set_plldivnfrac(&mut self, n: usize, val: u32) {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            self.0 = (self.0 & !(0x00ff_ffff << offs)) | (((val as u32) & 0x00ff_ffff) << offs);
        }
    }
    impl Default for Pll4cfgr2 {
        #[inline(always)]
        fn default() -> Pll4cfgr2 {
            Pll4cfgr2(0)
        }
    }
    impl core::fmt::Debug for Pll4cfgr2 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pll4cfgr2")
                .field("plldivnfrac[0]", &self.plldivnfrac(0usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pll4cfgr2 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(f, "Pll4cfgr2 {{ plldivnfrac[0]: {=u32:?} }}", self.plldivnfrac(0usize))
        }
    }
    #[doc = "RCC PLL4 configuration register 3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll4cfgr3(pub u32);
    impl Pll4cfgr3 {
        #[doc = "PLL4 Modulation Spread Spectrum reset."]
        #[inline(always)]
        pub const fn pllmodssrst(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL4 Modulation Spread Spectrum reset."]
        #[inline(always)]
        pub fn set_pllmodssrst(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 0usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "PLL4 noise canceling DAC enable in fractional mode."]
        #[inline(always)]
        pub const fn plldacen(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 1usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL4 noise canceling DAC enable in fractional mode."]
        #[inline(always)]
        pub fn set_plldacen(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 1usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "PLL4 Modulation Spread-Spectrum Disable."]
        #[inline(always)]
        pub const fn pllmodssdis(&self, n: usize) -> super::vals::Pllmodssdis {
            assert!(n < 1usize);
            let offs = 2usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllmodssdis::from_bits(val as u8)
        }
        #[doc = "PLL4 Modulation Spread-Spectrum Disable."]
        #[inline(always)]
        pub fn set_pllmodssdis(&mut self, n: usize, val: super::vals::Pllmodssdis) {
            assert!(n < 1usize);
            let offs = 2usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "PLL4 Modulation Spread-Spectrum (and Fractional Divide) enable."]
        #[inline(always)]
        pub const fn pllmoddsen(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 3usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL4 Modulation Spread-Spectrum (and Fractional Divide) enable."]
        #[inline(always)]
        pub fn set_pllmoddsen(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 3usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "PLL4 Modulation Down Spread."]
        #[inline(always)]
        pub const fn pllmodsprdw(&self, n: usize) -> super::vals::Pllmodsprdw {
            assert!(n < 1usize);
            let offs = 4usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllmodsprdw::from_bits(val as u8)
        }
        #[doc = "PLL4 Modulation Down Spread."]
        #[inline(always)]
        pub fn set_pllmodsprdw(&mut self, n: usize, val: super::vals::Pllmodsprdw) {
            assert!(n < 1usize);
            let offs = 4usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
        #[doc = "PLL4 Modulation Division frequency adjustment."]
        #[inline(always)]
        pub const fn pllmoddiv(&self, n: usize) -> u8 {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            let val = (self.0 >> offs) & 0x0f;
            val as u8
        }
        #[doc = "PLL4 Modulation Division frequency adjustment."]
        #[inline(always)]
        pub fn set_pllmoddiv(&mut self, n: usize, val: u8) {
            assert!(n < 1usize);
            let offs = 8usize + n * 0usize;
            self.0 = (self.0 & !(0x0f << offs)) | (((val as u32) & 0x0f) << offs);
        }
        #[doc = "PLL4 Modulation Spread depth adjustment."]
        #[inline(always)]
        pub const fn pllmodspr(&self, n: usize) -> u8 {
            assert!(n < 1usize);
            let offs = 16usize + n * 0usize;
            let val = (self.0 >> offs) & 0x1f;
            val as u8
        }
        #[doc = "PLL4 Modulation Spread depth adjustment."]
        #[inline(always)]
        pub fn set_pllmodspr(&mut self, n: usize, val: u8) {
            assert!(n < 1usize);
            let offs = 16usize + n * 0usize;
            self.0 = (self.0 & !(0x1f << offs)) | (((val as u32) & 0x1f) << offs);
        }
        #[doc = "PLL4 VCO frequency divider level 2."]
        #[inline(always)]
        pub const fn pllpdiv2(&self, n: usize) -> super::vals::Pllpdiv {
            assert!(n < 1usize);
            let offs = 24usize + n * 0usize;
            let val = (self.0 >> offs) & 0x07;
            super::vals::Pllpdiv::from_bits(val as u8)
        }
        #[doc = "PLL4 VCO frequency divider level 2."]
        #[inline(always)]
        pub fn set_pllpdiv2(&mut self, n: usize, val: super::vals::Pllpdiv) {
            assert!(n < 1usize);
            let offs = 24usize + n * 0usize;
            self.0 = (self.0 & !(0x07 << offs)) | (((val.to_bits() as u32) & 0x07) << offs);
        }
        #[doc = "PLL4 VCO frequency divider level 1."]
        #[inline(always)]
        pub const fn pllpdiv1(&self, n: usize) -> super::vals::Pllpdiv {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            let val = (self.0 >> offs) & 0x07;
            super::vals::Pllpdiv::from_bits(val as u8)
        }
        #[doc = "PLL4 VCO frequency divider level 1."]
        #[inline(always)]
        pub fn set_pllpdiv1(&mut self, n: usize, val: super::vals::Pllpdiv) {
            assert!(n < 1usize);
            let offs = 27usize + n * 0usize;
            self.0 = (self.0 & !(0x07 << offs)) | (((val.to_bits() as u32) & 0x07) << offs);
        }
        #[doc = "PLL4 post divider POSTDIV1, POSTDIV2, and PLL clock output enable."]
        #[inline(always)]
        pub const fn pllpdiven(&self, n: usize) -> bool {
            assert!(n < 1usize);
            let offs = 30usize + n * 0usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "PLL4 post divider POSTDIV1, POSTDIV2, and PLL clock output enable."]
        #[inline(always)]
        pub fn set_pllpdiven(&mut self, n: usize, val: bool) {
            assert!(n < 1usize);
            let offs = 30usize + n * 0usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Pll4cfgr3 {
        #[inline(always)]
        fn default() -> Pll4cfgr3 {
            Pll4cfgr3(0)
        }
    }
    impl core::fmt::Debug for Pll4cfgr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pll4cfgr3")
                .field("pllmodssrst[0]", &self.pllmodssrst(0usize))
                .field("plldacen[0]", &self.plldacen(0usize))
                .field("pllmodssdis[0]", &self.pllmodssdis(0usize))
                .field("pllmoddsen[0]", &self.pllmoddsen(0usize))
                .field("pllmodsprdw[0]", &self.pllmodsprdw(0usize))
                .field("pllmoddiv[0]", &self.pllmoddiv(0usize))
                .field("pllmodspr[0]", &self.pllmodspr(0usize))
                .field("pllpdiv2[0]", &self.pllpdiv2(0usize))
                .field("pllpdiv1[0]", &self.pllpdiv1(0usize))
                .field("pllpdiven[0]", &self.pllpdiven(0usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pll4cfgr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pll4cfgr3 {{ pllmodssrst[0]: {=bool:?}, plldacen[0]: {=bool:?}, pllmodssdis[0]: {:?}, pllmoddsen[0]: {=bool:?}, pllmodsprdw[0]: {:?}, pllmoddiv[0]: {=u8:?}, pllmodspr[0]: {=u8:?}, pllpdiv2[0]: {:?}, pllpdiv1[0]: {:?}, pllpdiven[0]: {=bool:?} }}" , self . pllmodssrst (0usize) , self . plldacen (0usize) , self . pllmodssdis (0usize) , self . pllmoddsen (0usize) , self . pllmodsprdw (0usize) , self . pllmoddiv (0usize) , self . pllmodspr (0usize) , self . pllpdiv2 (0usize) , self . pllpdiv1 (0usize) , self . pllpdiven (0usize))
        }
    }
    #[doc = "RCC oscillator privilege configuration register0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgcr0(pub u32);
    impl Privcfgcr0 {
        #[doc = "Defines the privilege protection of the LSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn lsipvc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the LSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_lsipvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the privilege protection of the LSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn lsepvc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the LSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_lsepvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the privilege protection of the MSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn msipvc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the MSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_msipvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the privilege protection of the HSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn hsipvc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the HSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_hsipvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the privilege protection of the HSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn hsepvc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the HSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_hsepvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Privcfgcr0 {
        #[inline(always)]
        fn default() -> Privcfgcr0 {
            Privcfgcr0(0)
        }
    }
    impl core::fmt::Debug for Privcfgcr0 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgcr0")
                .field("lsipvc", &self.lsipvc())
                .field("lsepvc", &self.lsepvc())
                .field("msipvc", &self.msipvc())
                .field("hsipvc", &self.hsipvc())
                .field("hsepvc", &self.hsepvc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgcr0 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Privcfgcr0 {{ lsipvc: {=bool:?}, lsepvc: {=bool:?}, msipvc: {=bool:?}, hsipvc: {=bool:?}, hsepvc: {=bool:?} }}" , self . lsipvc () , self . lsepvc () , self . msipvc () , self . hsipvc () , self . hsepvc ())
        }
    }
    #[doc = "RCC PLL privilege configuration register1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgcr1(pub u32);
    impl Privcfgcr1 {
        #[doc = "Defines the privilege protection of the PLL1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn pllpvc(&self, n: usize) -> bool {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the PLL1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_pllpvc(&mut self, n: usize, val: bool) {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Privcfgcr1 {
        #[inline(always)]
        fn default() -> Privcfgcr1 {
            Privcfgcr1(0)
        }
    }
    impl core::fmt::Debug for Privcfgcr1 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgcr1")
                .field("pllpvc[0]", &self.pllpvc(0usize))
                .field("pllpvc[1]", &self.pllpvc(1usize))
                .field("pllpvc[2]", &self.pllpvc(2usize))
                .field("pllpvc[3]", &self.pllpvc(3usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgcr1 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Privcfgcr1 {{ pllpvc[0]: {=bool:?}, pllpvc[1]: {=bool:?}, pllpvc[2]: {=bool:?}, pllpvc[3]: {=bool:?} }}" , self . pllpvc (0usize) , self . pllpvc (1usize) , self . pllpvc (2usize) , self . pllpvc (3usize))
        }
    }
    #[doc = "RCC divider privilege configuration register2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgcr2(pub u32);
    impl Privcfgcr2 {
        #[doc = "Defines the privilege protection of the IC1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic1pvc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic1pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the privilege protection of the IC2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic2pvc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic2pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the privilege protection of the IC3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic3pvc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic3pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the privilege protection of the IC4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic4pvc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic4pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the privilege protection of the IC5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic5pvc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic5pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the privilege protection of the IC6 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic6pvc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC6 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic6pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the privilege protection of the IC7 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic7pvc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC7 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic7pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the privilege protection of the IC8 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic8pvc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC8 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic8pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the privilege protection of the IC9 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic9pvc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC9 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic9pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the privilege protection of the IC10 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic10pvc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC10 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic10pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the privilege protection of the IC11 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic11pvc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC11 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic11pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the privilege protection of the IC12 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic12pvc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC12 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic12pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the privilege protection of the IC13 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic13pvc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC13 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic13pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the privilege protection of the IC14 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic14pvc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC14 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic14pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "Defines the privilege protection of the IC15 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic15pvc(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC15 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic15pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "Defines the privilege protection of the IC16 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic16pvc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC16 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic16pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "Defines the privilege protection of the IC17 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic17pvc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC17 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic17pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "Defines the privilege protection of the IC18 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic18pvc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC18 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic18pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "Defines the privilege protection of the IC19 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic19pvc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC19 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic19pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "Defines the privilege protection of the IC20 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic20pvc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC20 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic20pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Privcfgcr2 {
        #[inline(always)]
        fn default() -> Privcfgcr2 {
            Privcfgcr2(0)
        }
    }
    impl core::fmt::Debug for Privcfgcr2 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgcr2")
                .field("ic1pvc", &self.ic1pvc())
                .field("ic2pvc", &self.ic2pvc())
                .field("ic3pvc", &self.ic3pvc())
                .field("ic4pvc", &self.ic4pvc())
                .field("ic5pvc", &self.ic5pvc())
                .field("ic6pvc", &self.ic6pvc())
                .field("ic7pvc", &self.ic7pvc())
                .field("ic8pvc", &self.ic8pvc())
                .field("ic9pvc", &self.ic9pvc())
                .field("ic10pvc", &self.ic10pvc())
                .field("ic11pvc", &self.ic11pvc())
                .field("ic12pvc", &self.ic12pvc())
                .field("ic13pvc", &self.ic13pvc())
                .field("ic14pvc", &self.ic14pvc())
                .field("ic15pvc", &self.ic15pvc())
                .field("ic16pvc", &self.ic16pvc())
                .field("ic17pvc", &self.ic17pvc())
                .field("ic18pvc", &self.ic18pvc())
                .field("ic19pvc", &self.ic19pvc())
                .field("ic20pvc", &self.ic20pvc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgcr2 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Privcfgcr2 {{ ic1pvc: {=bool:?}, ic2pvc: {=bool:?}, ic3pvc: {=bool:?}, ic4pvc: {=bool:?}, ic5pvc: {=bool:?}, ic6pvc: {=bool:?}, ic7pvc: {=bool:?}, ic8pvc: {=bool:?}, ic9pvc: {=bool:?}, ic10pvc: {=bool:?}, ic11pvc: {=bool:?}, ic12pvc: {=bool:?}, ic13pvc: {=bool:?}, ic14pvc: {=bool:?}, ic15pvc: {=bool:?}, ic16pvc: {=bool:?}, ic17pvc: {=bool:?}, ic18pvc: {=bool:?}, ic19pvc: {=bool:?}, ic20pvc: {=bool:?} }}" , self . ic1pvc () , self . ic2pvc () , self . ic3pvc () , self . ic4pvc () , self . ic5pvc () , self . ic6pvc () , self . ic7pvc () , self . ic8pvc () , self . ic9pvc () , self . ic10pvc () , self . ic11pvc () , self . ic12pvc () , self . ic13pvc () , self . ic14pvc () , self . ic15pvc () , self . ic16pvc () , self . ic17pvc () , self . ic18pvc () , self . ic19pvc () , self . ic20pvc ())
        }
    }
    #[doc = "RCC system privilege configuration register3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgcr3(pub u32);
    impl Privcfgcr3 {
        #[doc = "Defines the privilege protection of the MOD configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn modpvc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the MOD configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_modpvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the privilege protection of the SYS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn syspvc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the SYS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_syspvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the privilege protection of the BUS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn buspvc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the BUS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_buspvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the privilege protection of the PER configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn perpvc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the PER configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_perpvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the privilege protection of the INT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn intpvc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the INT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_intpvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the privilege protection of the RST configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn rstpvc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the RST configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_rstpvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the privilege protection of the DFT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn dftpvc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the DFT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_dftpvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Privcfgcr3 {
        #[inline(always)]
        fn default() -> Privcfgcr3 {
            Privcfgcr3(0)
        }
    }
    impl core::fmt::Debug for Privcfgcr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgcr3")
                .field("modpvc", &self.modpvc())
                .field("syspvc", &self.syspvc())
                .field("buspvc", &self.buspvc())
                .field("perpvc", &self.perpvc())
                .field("intpvc", &self.intpvc())
                .field("rstpvc", &self.rstpvc())
                .field("dftpvc", &self.dftpvc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgcr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Privcfgcr3 {{ modpvc: {=bool:?}, syspvc: {=bool:?}, buspvc: {=bool:?}, perpvc: {=bool:?}, intpvc: {=bool:?}, rstpvc: {=bool:?}, dftpvc: {=bool:?} }}" , self . modpvc () , self . syspvc () , self . buspvc () , self . perpvc () , self . intpvc () , self . rstpvc () , self . dftpvc ())
        }
    }
    #[doc = "RCC privilege configuration register4."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgcr4(pub u32);
    impl Privcfgcr4 {
        #[doc = "Defines the privilege protection of the ACLKN configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn aclknpvc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the ACLKN configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_aclknpvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the privilege protection of the ACLKNC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn aclkncpvc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the ACLKNC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_aclkncpvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the privilege protection of the AHBM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahbmpvc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the AHBM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahbmpvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the privilege protection of the AHB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb1pvc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the AHB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb1pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the privilege protection of the AHB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb2pvc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the AHB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb2pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the privilege protection of the AHB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb3pvc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the AHB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb3pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the privilege protection of the AHB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb4pvc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the AHB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb4pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the privilege protection of the AHB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb5pvc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the AHB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb5pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the privilege protection of the APB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb1pvc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the APB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb1pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the privilege protection of the APB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb2pvc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the APB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb2pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the privilege protection of the APB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb3pvc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the APB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb3pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the privilege protection of the APB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb4pvc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the APB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb4pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the privilege protection of the APB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb5pvc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the APB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb5pvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the privilege protection of the NOC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn nocpvc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the NOC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_nocpvc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
    }
    impl Default for Privcfgcr4 {
        #[inline(always)]
        fn default() -> Privcfgcr4 {
            Privcfgcr4(0)
        }
    }
    impl core::fmt::Debug for Privcfgcr4 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgcr4")
                .field("aclknpvc", &self.aclknpvc())
                .field("aclkncpvc", &self.aclkncpvc())
                .field("ahbmpvc", &self.ahbmpvc())
                .field("ahb1pvc", &self.ahb1pvc())
                .field("ahb2pvc", &self.ahb2pvc())
                .field("ahb3pvc", &self.ahb3pvc())
                .field("ahb4pvc", &self.ahb4pvc())
                .field("ahb5pvc", &self.ahb5pvc())
                .field("apb1pvc", &self.apb1pvc())
                .field("apb2pvc", &self.apb2pvc())
                .field("apb3pvc", &self.apb3pvc())
                .field("apb4pvc", &self.apb4pvc())
                .field("apb5pvc", &self.apb5pvc())
                .field("nocpvc", &self.nocpvc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgcr4 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Privcfgcr4 {{ aclknpvc: {=bool:?}, aclkncpvc: {=bool:?}, ahbmpvc: {=bool:?}, ahb1pvc: {=bool:?}, ahb2pvc: {=bool:?}, ahb3pvc: {=bool:?}, ahb4pvc: {=bool:?}, ahb5pvc: {=bool:?}, apb1pvc: {=bool:?}, apb2pvc: {=bool:?}, apb3pvc: {=bool:?}, apb4pvc: {=bool:?}, apb5pvc: {=bool:?}, nocpvc: {=bool:?} }}" , self . aclknpvc () , self . aclkncpvc () , self . ahbmpvc () , self . ahb1pvc () , self . ahb2pvc () , self . ahb3pvc () , self . ahb4pvc () , self . ahb5pvc () , self . apb1pvc () , self . apb2pvc () , self . apb3pvc () , self . apb4pvc () , self . apb5pvc () , self . nocpvc ())
        }
    }
    #[doc = "RCC oscillator privilege configuration register0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgr0(pub u32);
    impl Privcfgr0 {
        #[doc = "Defines the privilege protection of the LSI oscillator configuration bits."]
        #[inline(always)]
        pub const fn lsipv(&self) -> super::vals::Lsipv {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Lsipv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the LSI oscillator configuration bits."]
        #[inline(always)]
        pub fn set_lsipv(&mut self, val: super::vals::Lsipv) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the privilege protection of the LSE oscillator configuration bits."]
        #[inline(always)]
        pub const fn lsepv(&self) -> super::vals::Lsepv {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Lsepv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the LSE oscillator configuration bits."]
        #[inline(always)]
        pub fn set_lsepv(&mut self, val: super::vals::Lsepv) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the privilege protection of the MSI oscillator configuration bits."]
        #[inline(always)]
        pub const fn msipv(&self) -> super::vals::Msipv {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Msipv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the MSI oscillator configuration bits."]
        #[inline(always)]
        pub fn set_msipv(&mut self, val: super::vals::Msipv) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the privilege protection of the HSI oscillator configuration bits."]
        #[inline(always)]
        pub const fn hsipv(&self) -> super::vals::Hsipv {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Hsipv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the HSI oscillator configuration bits."]
        #[inline(always)]
        pub fn set_hsipv(&mut self, val: super::vals::Hsipv) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the privilege protection of the HSE oscillator configuration bits."]
        #[inline(always)]
        pub const fn hsepv(&self) -> super::vals::Hsepv {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Hsepv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the HSE oscillator configuration bits."]
        #[inline(always)]
        pub fn set_hsepv(&mut self, val: super::vals::Hsepv) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Privcfgr0 {
        #[inline(always)]
        fn default() -> Privcfgr0 {
            Privcfgr0(0)
        }
    }
    impl core::fmt::Debug for Privcfgr0 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgr0")
                .field("lsipv", &self.lsipv())
                .field("lsepv", &self.lsepv())
                .field("msipv", &self.msipv())
                .field("hsipv", &self.hsipv())
                .field("hsepv", &self.hsepv())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgr0 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Privcfgr0 {{ lsipv: {:?}, lsepv: {:?}, msipv: {:?}, hsipv: {:?}, hsepv: {:?} }}",
                self.lsipv(),
                self.lsepv(),
                self.msipv(),
                self.hsipv(),
                self.hsepv()
            )
        }
    }
    #[doc = "RCC PLL privilege configuration register1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgr1(pub u32);
    impl Privcfgr1 {
        #[doc = "Defines the privilege protection of the PLL1 PLL configuration bits."]
        #[inline(always)]
        pub const fn pllpv(&self, n: usize) -> super::vals::Pllpv {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the PLL1 PLL configuration bits."]
        #[inline(always)]
        pub fn set_pllpv(&mut self, n: usize, val: super::vals::Pllpv) {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
    }
    impl Default for Privcfgr1 {
        #[inline(always)]
        fn default() -> Privcfgr1 {
            Privcfgr1(0)
        }
    }
    impl core::fmt::Debug for Privcfgr1 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgr1")
                .field("pllpv[0]", &self.pllpv(0usize))
                .field("pllpv[1]", &self.pllpv(1usize))
                .field("pllpv[2]", &self.pllpv(2usize))
                .field("pllpv[3]", &self.pllpv(3usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgr1 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Privcfgr1 {{ pllpv[0]: {:?}, pllpv[1]: {:?}, pllpv[2]: {:?}, pllpv[3]: {:?} }}",
                self.pllpv(0usize),
                self.pllpv(1usize),
                self.pllpv(2usize),
                self.pllpv(3usize)
            )
        }
    }
    #[doc = "RCC divider privilege configuration register2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgr2(pub u32);
    impl Privcfgr2 {
        #[doc = "Defines the privilege protection of the IC1 divider configuration bits."]
        #[inline(always)]
        pub const fn ic1pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC1 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic1pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the privilege protection of the IC2 divider configuration bits."]
        #[inline(always)]
        pub const fn ic2pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC2 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic2pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the privilege protection of the IC3 divider configuration bits."]
        #[inline(always)]
        pub const fn ic3pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC3 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic3pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the privilege protection of the IC4 divider configuration bits."]
        #[inline(always)]
        pub const fn ic4pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC4 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic4pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the privilege protection of the IC5 divider configuration bits."]
        #[inline(always)]
        pub const fn ic5pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC5 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic5pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the privilege protection of the IC6 divider configuration bits."]
        #[inline(always)]
        pub const fn ic6pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 5usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC6 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic6pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the privilege protection of the IC7 divider configuration bits."]
        #[inline(always)]
        pub const fn ic7pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC7 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic7pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the privilege protection of the IC8 divider configuration bits."]
        #[inline(always)]
        pub const fn ic8pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 7usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC8 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic8pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the privilege protection of the IC9 divider configuration bits."]
        #[inline(always)]
        pub const fn ic9pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC9 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic9pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the privilege protection of the IC10 divider configuration bits."]
        #[inline(always)]
        pub const fn ic10pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC10 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic10pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the privilege protection of the IC11 divider configuration bits."]
        #[inline(always)]
        pub const fn ic11pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 10usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC11 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic11pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the privilege protection of the IC12 divider configuration bits."]
        #[inline(always)]
        pub const fn ic12pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 11usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC12 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic12pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the privilege protection of the IC13 divider configuration bits."]
        #[inline(always)]
        pub const fn ic13pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 12usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC13 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic13pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the privilege protection of the IC14 divider configuration bits."]
        #[inline(always)]
        pub const fn ic14pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 13usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC14 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic14pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
        }
        #[doc = "Defines the privilege protection of the IC15 divider configuration bits."]
        #[inline(always)]
        pub const fn ic15pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 14usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC15 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic15pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
        }
        #[doc = "Defines the privilege protection of the IC16 divider configuration bits."]
        #[inline(always)]
        pub const fn ic16pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 15usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC16 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic16pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
        }
        #[doc = "Defines the privilege protection of the IC17 divider configuration bits."]
        #[inline(always)]
        pub const fn ic17pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC17 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic17pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
        #[doc = "Defines the privilege protection of the IC18 divider configuration bits."]
        #[inline(always)]
        pub const fn ic18pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 17usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC18 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic18pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
        }
        #[doc = "Defines the privilege protection of the IC19 divider configuration bits."]
        #[inline(always)]
        pub const fn ic19pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 18usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC19 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic19pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
        }
        #[doc = "Defines the privilege protection of the IC20 divider configuration bits."]
        #[inline(always)]
        pub const fn ic20pv(&self) -> super::vals::Icpv {
            let val = (self.0 >> 19usize) & 0x01;
            super::vals::Icpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the IC20 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic20pv(&mut self, val: super::vals::Icpv) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Privcfgr2 {
        #[inline(always)]
        fn default() -> Privcfgr2 {
            Privcfgr2(0)
        }
    }
    impl core::fmt::Debug for Privcfgr2 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgr2")
                .field("ic1pv", &self.ic1pv())
                .field("ic2pv", &self.ic2pv())
                .field("ic3pv", &self.ic3pv())
                .field("ic4pv", &self.ic4pv())
                .field("ic5pv", &self.ic5pv())
                .field("ic6pv", &self.ic6pv())
                .field("ic7pv", &self.ic7pv())
                .field("ic8pv", &self.ic8pv())
                .field("ic9pv", &self.ic9pv())
                .field("ic10pv", &self.ic10pv())
                .field("ic11pv", &self.ic11pv())
                .field("ic12pv", &self.ic12pv())
                .field("ic13pv", &self.ic13pv())
                .field("ic14pv", &self.ic14pv())
                .field("ic15pv", &self.ic15pv())
                .field("ic16pv", &self.ic16pv())
                .field("ic17pv", &self.ic17pv())
                .field("ic18pv", &self.ic18pv())
                .field("ic19pv", &self.ic19pv())
                .field("ic20pv", &self.ic20pv())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgr2 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Privcfgr2 {{ ic1pv: {:?}, ic2pv: {:?}, ic3pv: {:?}, ic4pv: {:?}, ic5pv: {:?}, ic6pv: {:?}, ic7pv: {:?}, ic8pv: {:?}, ic9pv: {:?}, ic10pv: {:?}, ic11pv: {:?}, ic12pv: {:?}, ic13pv: {:?}, ic14pv: {:?}, ic15pv: {:?}, ic16pv: {:?}, ic17pv: {:?}, ic18pv: {:?}, ic19pv: {:?}, ic20pv: {:?} }}" , self . ic1pv () , self . ic2pv () , self . ic3pv () , self . ic4pv () , self . ic5pv () , self . ic6pv () , self . ic7pv () , self . ic8pv () , self . ic9pv () , self . ic10pv () , self . ic11pv () , self . ic12pv () , self . ic13pv () , self . ic14pv () , self . ic15pv () , self . ic16pv () , self . ic17pv () , self . ic18pv () , self . ic19pv () , self . ic20pv ())
        }
    }
    #[doc = "RCC system privilege configuration register3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgr3(pub u32);
    impl Privcfgr3 {
        #[doc = "Defines the privilege protection of the MOD system configuration bits."]
        #[inline(always)]
        pub const fn modpv(&self) -> super::vals::Modpv {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Modpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the MOD system configuration bits."]
        #[inline(always)]
        pub fn set_modpv(&mut self, val: super::vals::Modpv) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the privilege protection of the SYS system configuration bits."]
        #[inline(always)]
        pub const fn syspv(&self) -> super::vals::Syspv {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Syspv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the SYS system configuration bits."]
        #[inline(always)]
        pub fn set_syspv(&mut self, val: super::vals::Syspv) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the privilege protection of the BUS system configuration bits."]
        #[inline(always)]
        pub const fn buspv(&self) -> super::vals::Buspv {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Buspv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the BUS system configuration bits."]
        #[inline(always)]
        pub fn set_buspv(&mut self, val: super::vals::Buspv) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the privilege protection of the PER system configuration bits."]
        #[inline(always)]
        pub const fn perpv(&self) -> super::vals::Perpv {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Perpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the PER system configuration bits."]
        #[inline(always)]
        pub fn set_perpv(&mut self, val: super::vals::Perpv) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the privilege protection of the INT system configuration bits."]
        #[inline(always)]
        pub const fn intpv(&self) -> super::vals::Intpv {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Intpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the INT system configuration bits."]
        #[inline(always)]
        pub fn set_intpv(&mut self, val: super::vals::Intpv) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the privilege protection of the RST system configuration bits."]
        #[inline(always)]
        pub const fn rstpv(&self) -> super::vals::Rstpv {
            let val = (self.0 >> 5usize) & 0x01;
            super::vals::Rstpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the RST system configuration bits."]
        #[inline(always)]
        pub fn set_rstpv(&mut self, val: super::vals::Rstpv) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the privilege protection of the DFT system configuration bits."]
        #[inline(always)]
        pub const fn dftpv(&self) -> super::vals::Dftpv {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Dftpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the DFT system configuration bits."]
        #[inline(always)]
        pub fn set_dftpv(&mut self, val: super::vals::Dftpv) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Privcfgr3 {
        #[inline(always)]
        fn default() -> Privcfgr3 {
            Privcfgr3(0)
        }
    }
    impl core::fmt::Debug for Privcfgr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgr3")
                .field("modpv", &self.modpv())
                .field("syspv", &self.syspv())
                .field("buspv", &self.buspv())
                .field("perpv", &self.perpv())
                .field("intpv", &self.intpv())
                .field("rstpv", &self.rstpv())
                .field("dftpv", &self.dftpv())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Privcfgr3 {{ modpv: {:?}, syspv: {:?}, buspv: {:?}, perpv: {:?}, intpv: {:?}, rstpv: {:?}, dftpv: {:?} }}" , self . modpv () , self . syspv () , self . buspv () , self . perpv () , self . intpv () , self . rstpv () , self . dftpv ())
        }
    }
    #[doc = "RCC bus privilege configuration register4."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgr4(pub u32);
    impl Privcfgr4 {
        #[doc = "Defines the privilege protection of the ACLKN bus configuration bits."]
        #[inline(always)]
        pub const fn aclknpv(&self) -> super::vals::Aclknpv {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Aclknpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the ACLKN bus configuration bits."]
        #[inline(always)]
        pub fn set_aclknpv(&mut self, val: super::vals::Aclknpv) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the privilege protection of the ACLKNC bus configuration bits."]
        #[inline(always)]
        pub const fn aclkncpv(&self) -> super::vals::Aclkncpv {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Aclkncpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the ACLKNC bus configuration bits."]
        #[inline(always)]
        pub fn set_aclkncpv(&mut self, val: super::vals::Aclkncpv) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the privilege protection of the AHBM bus configuration bits."]
        #[inline(always)]
        pub const fn ahbmpv(&self) -> super::vals::Ahbmpv {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Ahbmpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the AHBM bus configuration bits."]
        #[inline(always)]
        pub fn set_ahbmpv(&mut self, val: super::vals::Ahbmpv) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the privilege protection of the AHB1 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb1pv(&self) -> super::vals::Ahbpv {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Ahbpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the AHB1 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb1pv(&mut self, val: super::vals::Ahbpv) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the privilege protection of the AHB2 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb2pv(&self) -> super::vals::Ahbpv {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Ahbpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the AHB2 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb2pv(&mut self, val: super::vals::Ahbpv) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the privilege protection of the AHB3 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb3pv(&self) -> super::vals::Ahbpv {
            let val = (self.0 >> 5usize) & 0x01;
            super::vals::Ahbpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the AHB3 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb3pv(&mut self, val: super::vals::Ahbpv) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the privilege protection of the AHB4 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb4pv(&self) -> super::vals::Ahbpv {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Ahbpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the AHB4 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb4pv(&mut self, val: super::vals::Ahbpv) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the privilege protection of the AHB5 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb5pv(&self) -> super::vals::Ahbpv {
            let val = (self.0 >> 7usize) & 0x01;
            super::vals::Ahbpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the AHB5 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb5pv(&mut self, val: super::vals::Ahbpv) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the privilege protection of the APB1 bus configuration bits."]
        #[inline(always)]
        pub const fn apb1pv(&self) -> super::vals::Apbpv {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Apbpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the APB1 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb1pv(&mut self, val: super::vals::Apbpv) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the privilege protection of the APB2 bus configuration bits."]
        #[inline(always)]
        pub const fn apb2pv(&self) -> super::vals::Apbpv {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Apbpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the APB2 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb2pv(&mut self, val: super::vals::Apbpv) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the privilege protection of the APB3 bus configuration bits."]
        #[inline(always)]
        pub const fn apb3pv(&self) -> super::vals::Apbpv {
            let val = (self.0 >> 10usize) & 0x01;
            super::vals::Apbpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the APB3 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb3pv(&mut self, val: super::vals::Apbpv) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the privilege protection of the APB4 bus configuration bits."]
        #[inline(always)]
        pub const fn apb4pv(&self) -> super::vals::Apbpv {
            let val = (self.0 >> 11usize) & 0x01;
            super::vals::Apbpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the APB4 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb4pv(&mut self, val: super::vals::Apbpv) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the privilege protection of the APB5 bus configuration bits."]
        #[inline(always)]
        pub const fn apb5pv(&self) -> super::vals::Apbpv {
            let val = (self.0 >> 12usize) & 0x01;
            super::vals::Apbpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the APB5 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb5pv(&mut self, val: super::vals::Apbpv) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the privilege protection of the NOC bus configuration bits."]
        #[inline(always)]
        pub const fn nocpv(&self) -> super::vals::Nocpv {
            let val = (self.0 >> 13usize) & 0x01;
            super::vals::Nocpv::from_bits(val as u8)
        }
        #[doc = "Defines the privilege protection of the NOC bus configuration bits."]
        #[inline(always)]
        pub fn set_nocpv(&mut self, val: super::vals::Nocpv) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
        }
    }
    impl Default for Privcfgr4 {
        #[inline(always)]
        fn default() -> Privcfgr4 {
            Privcfgr4(0)
        }
    }
    impl core::fmt::Debug for Privcfgr4 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgr4")
                .field("aclknpv", &self.aclknpv())
                .field("aclkncpv", &self.aclkncpv())
                .field("ahbmpv", &self.ahbmpv())
                .field("ahb1pv", &self.ahb1pv())
                .field("ahb2pv", &self.ahb2pv())
                .field("ahb3pv", &self.ahb3pv())
                .field("ahb4pv", &self.ahb4pv())
                .field("ahb5pv", &self.ahb5pv())
                .field("apb1pv", &self.apb1pv())
                .field("apb2pv", &self.apb2pv())
                .field("apb3pv", &self.apb3pv())
                .field("apb4pv", &self.apb4pv())
                .field("apb5pv", &self.apb5pv())
                .field("nocpv", &self.nocpv())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgr4 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Privcfgr4 {{ aclknpv: {:?}, aclkncpv: {:?}, ahbmpv: {:?}, ahb1pv: {:?}, ahb2pv: {:?}, ahb3pv: {:?}, ahb4pv: {:?}, ahb5pv: {:?}, apb1pv: {:?}, apb2pv: {:?}, apb3pv: {:?}, apb4pv: {:?}, apb5pv: {:?}, nocpv: {:?} }}" , self . aclknpv () , self . aclkncpv () , self . ahbmpv () , self . ahb1pv () , self . ahb2pv () , self . ahb3pv () , self . ahb4pv () , self . ahb5pv () , self . apb1pv () , self . apb2pv () , self . apb3pv () , self . apb4pv () , self . apb5pv () , self . nocpv ())
        }
    }
    #[doc = "RCC oscillator privilege configuration register0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgsr0(pub u32);
    impl Privcfgsr0 {
        #[doc = "Defines the privilege protection of the LSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn lsipvs(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the LSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_lsipvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the privilege protection of the LSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn lsepvs(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the LSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_lsepvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the privilege protection of the MSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn msipvs(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the MSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_msipvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the privilege protection of the HSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn hsipvs(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the HSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_hsipvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the privilege protection of the HSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn hsepvs(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the HSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_hsepvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Privcfgsr0 {
        #[inline(always)]
        fn default() -> Privcfgsr0 {
            Privcfgsr0(0)
        }
    }
    impl core::fmt::Debug for Privcfgsr0 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgsr0")
                .field("lsipvs", &self.lsipvs())
                .field("lsepvs", &self.lsepvs())
                .field("msipvs", &self.msipvs())
                .field("hsipvs", &self.hsipvs())
                .field("hsepvs", &self.hsepvs())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgsr0 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Privcfgsr0 {{ lsipvs: {=bool:?}, lsepvs: {=bool:?}, msipvs: {=bool:?}, hsipvs: {=bool:?}, hsepvs: {=bool:?} }}" , self . lsipvs () , self . lsepvs () , self . msipvs () , self . hsipvs () , self . hsepvs ())
        }
    }
    #[doc = "RCC PLL privilege configuration register1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgsr1(pub u32);
    impl Privcfgsr1 {
        #[doc = "Defines the privilege protection of the PLL1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn pllpvs(&self, n: usize) -> bool {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the PLL1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_pllpvs(&mut self, n: usize, val: bool) {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Privcfgsr1 {
        #[inline(always)]
        fn default() -> Privcfgsr1 {
            Privcfgsr1(0)
        }
    }
    impl core::fmt::Debug for Privcfgsr1 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgsr1")
                .field("pllpvs[0]", &self.pllpvs(0usize))
                .field("pllpvs[1]", &self.pllpvs(1usize))
                .field("pllpvs[2]", &self.pllpvs(2usize))
                .field("pllpvs[3]", &self.pllpvs(3usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgsr1 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Privcfgsr1 {{ pllpvs[0]: {=bool:?}, pllpvs[1]: {=bool:?}, pllpvs[2]: {=bool:?}, pllpvs[3]: {=bool:?} }}" , self . pllpvs (0usize) , self . pllpvs (1usize) , self . pllpvs (2usize) , self . pllpvs (3usize))
        }
    }
    #[doc = "RCC divider privilege configuration register2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgsr2(pub u32);
    impl Privcfgsr2 {
        #[doc = "Defines the privilege protection of the IC1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic1pvs(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic1pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the privilege protection of the IC2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic2pvs(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic2pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the privilege protection of the IC3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic3pvs(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic3pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the privilege protection of the IC4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic4pvs(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic4pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the privilege protection of the IC5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic5pvs(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic5pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the privilege protection of the IC6 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic6pvs(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC6 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic6pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the privilege protection of the IC7 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic7pvs(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC7 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic7pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the privilege protection of the IC8 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic8pvs(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC8 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic8pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the privilege protection of the IC9 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic9pvs(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC9 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic9pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the privilege protection of the IC10 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic10pvs(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC10 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic10pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the privilege protection of the IC11 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic11pvs(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC11 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic11pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the privilege protection of the IC12 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic12pvs(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC12 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic12pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the privilege protection of the IC13 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic13pvs(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC13 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic13pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the privilege protection of the IC14 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic14pvs(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC14 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic14pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "Defines the privilege protection of the IC15 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic15pvs(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC15 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic15pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "Defines the privilege protection of the IC16 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic16pvs(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC16 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic16pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "Defines the privilege protection of the IC17 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic17pvs(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC17 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic17pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "Defines the privilege protection of the IC18 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic18pvs(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC18 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic18pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "Defines the privilege protection of the IC19 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic19pvs(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC19 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic19pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "Defines the privilege protection of the IC20 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic20pvs(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the IC20 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic20pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Privcfgsr2 {
        #[inline(always)]
        fn default() -> Privcfgsr2 {
            Privcfgsr2(0)
        }
    }
    impl core::fmt::Debug for Privcfgsr2 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgsr2")
                .field("ic1pvs", &self.ic1pvs())
                .field("ic2pvs", &self.ic2pvs())
                .field("ic3pvs", &self.ic3pvs())
                .field("ic4pvs", &self.ic4pvs())
                .field("ic5pvs", &self.ic5pvs())
                .field("ic6pvs", &self.ic6pvs())
                .field("ic7pvs", &self.ic7pvs())
                .field("ic8pvs", &self.ic8pvs())
                .field("ic9pvs", &self.ic9pvs())
                .field("ic10pvs", &self.ic10pvs())
                .field("ic11pvs", &self.ic11pvs())
                .field("ic12pvs", &self.ic12pvs())
                .field("ic13pvs", &self.ic13pvs())
                .field("ic14pvs", &self.ic14pvs())
                .field("ic15pvs", &self.ic15pvs())
                .field("ic16pvs", &self.ic16pvs())
                .field("ic17pvs", &self.ic17pvs())
                .field("ic18pvs", &self.ic18pvs())
                .field("ic19pvs", &self.ic19pvs())
                .field("ic20pvs", &self.ic20pvs())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgsr2 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Privcfgsr2 {{ ic1pvs: {=bool:?}, ic2pvs: {=bool:?}, ic3pvs: {=bool:?}, ic4pvs: {=bool:?}, ic5pvs: {=bool:?}, ic6pvs: {=bool:?}, ic7pvs: {=bool:?}, ic8pvs: {=bool:?}, ic9pvs: {=bool:?}, ic10pvs: {=bool:?}, ic11pvs: {=bool:?}, ic12pvs: {=bool:?}, ic13pvs: {=bool:?}, ic14pvs: {=bool:?}, ic15pvs: {=bool:?}, ic16pvs: {=bool:?}, ic17pvs: {=bool:?}, ic18pvs: {=bool:?}, ic19pvs: {=bool:?}, ic20pvs: {=bool:?} }}" , self . ic1pvs () , self . ic2pvs () , self . ic3pvs () , self . ic4pvs () , self . ic5pvs () , self . ic6pvs () , self . ic7pvs () , self . ic8pvs () , self . ic9pvs () , self . ic10pvs () , self . ic11pvs () , self . ic12pvs () , self . ic13pvs () , self . ic14pvs () , self . ic15pvs () , self . ic16pvs () , self . ic17pvs () , self . ic18pvs () , self . ic19pvs () , self . ic20pvs ())
        }
    }
    #[doc = "RCC system privilege configuration register3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgsr3(pub u32);
    impl Privcfgsr3 {
        #[doc = "Defines the privilege protection of the MOD configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn modpvs(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the MOD configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_modpvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the privilege protection of the SYS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn syspvs(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the SYS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_syspvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the privilege protection of the BUS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn buspvs(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the BUS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_buspvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the privilege protection of the PER configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn perpvs(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the PER configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_perpvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the privilege protection of the INT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn intpvs(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the INT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_intpvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the privilege protection of the RST configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn rstpvs(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the RST configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_rstpvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the privilege protection of the DFT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn dftpvs(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the DFT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_dftpvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Privcfgsr3 {
        #[inline(always)]
        fn default() -> Privcfgsr3 {
            Privcfgsr3(0)
        }
    }
    impl core::fmt::Debug for Privcfgsr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgsr3")
                .field("modpvs", &self.modpvs())
                .field("syspvs", &self.syspvs())
                .field("buspvs", &self.buspvs())
                .field("perpvs", &self.perpvs())
                .field("intpvs", &self.intpvs())
                .field("rstpvs", &self.rstpvs())
                .field("dftpvs", &self.dftpvs())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgsr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Privcfgsr3 {{ modpvs: {=bool:?}, syspvs: {=bool:?}, buspvs: {=bool:?}, perpvs: {=bool:?}, intpvs: {=bool:?}, rstpvs: {=bool:?}, dftpvs: {=bool:?} }}" , self . modpvs () , self . syspvs () , self . buspvs () , self . perpvs () , self . intpvs () , self . rstpvs () , self . dftpvs ())
        }
    }
    #[doc = "RCC privilege configuration register4."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Privcfgsr4(pub u32);
    impl Privcfgsr4 {
        #[doc = "Defines the privilege protection of the ACLKN configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn aclknpvs(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the ACLKN configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_aclknpvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the privilege protection of the ACLKNC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn aclkncpvs(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the ACLKNC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_aclkncpvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the privilege protection of the AHBM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahbmpvs(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the AHBM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahbmpvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the privilege protection of the AHB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb1pvs(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the AHB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb1pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the privilege protection of the AHB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb2pvs(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the AHB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb2pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the privilege protection of the AHB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb3pvs(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the AHB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb3pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the privilege protection of the AHB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb4pvs(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the AHB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb4pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the privilege protection of the AHB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb5pvs(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the AHB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb5pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the privilege protection of the APB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb1pvs(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the APB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb1pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the privilege protection of the APB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb2pvs(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the APB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb2pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the privilege protection of the APB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb3pvs(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the APB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb3pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the privilege protection of the APB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb4pvs(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the APB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb4pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the privilege protection of the APB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb5pvs(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the APB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb5pvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the privilege protection of the NOC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn nocpvs(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the privilege protection of the NOC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_nocpvs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
    }
    impl Default for Privcfgsr4 {
        #[inline(always)]
        fn default() -> Privcfgsr4 {
            Privcfgsr4(0)
        }
    }
    impl core::fmt::Debug for Privcfgsr4 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Privcfgsr4")
                .field("aclknpvs", &self.aclknpvs())
                .field("aclkncpvs", &self.aclkncpvs())
                .field("ahbmpvs", &self.ahbmpvs())
                .field("ahb1pvs", &self.ahb1pvs())
                .field("ahb2pvs", &self.ahb2pvs())
                .field("ahb3pvs", &self.ahb3pvs())
                .field("ahb4pvs", &self.ahb4pvs())
                .field("ahb5pvs", &self.ahb5pvs())
                .field("apb1pvs", &self.apb1pvs())
                .field("apb2pvs", &self.apb2pvs())
                .field("apb3pvs", &self.apb3pvs())
                .field("apb4pvs", &self.apb4pvs())
                .field("apb5pvs", &self.apb5pvs())
                .field("nocpvs", &self.nocpvs())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Privcfgsr4 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Privcfgsr4 {{ aclknpvs: {=bool:?}, aclkncpvs: {=bool:?}, ahbmpvs: {=bool:?}, ahb1pvs: {=bool:?}, ahb2pvs: {=bool:?}, ahb3pvs: {=bool:?}, ahb4pvs: {=bool:?}, ahb5pvs: {=bool:?}, apb1pvs: {=bool:?}, apb2pvs: {=bool:?}, apb3pvs: {=bool:?}, apb4pvs: {=bool:?}, apb5pvs: {=bool:?}, nocpvs: {=bool:?} }}" , self . aclknpvs () , self . aclkncpvs () , self . ahbmpvs () , self . ahb1pvs () , self . ahb2pvs () , self . ahb3pvs () , self . ahb4pvs () , self . ahb5pvs () , self . apb1pvs () , self . apb2pvs () , self . apb3pvs () , self . apb4pvs () , self . apb5pvs () , self . nocpvs ())
        }
    }
    #[doc = "RCC oscillator public configuration register0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgcr0(pub u32);
    impl Pubcfgcr0 {
        #[doc = "Defines the public protection of the LSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn lsipubc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the LSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_lsipubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the LSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn lsepubc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the LSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_lsepubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the MSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn msipubc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the MSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_msipubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the HSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn hsipubc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the HSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_hsipubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the HSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn hsepubc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the HSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_hsepubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Pubcfgcr0 {
        #[inline(always)]
        fn default() -> Pubcfgcr0 {
            Pubcfgcr0(0)
        }
    }
    impl core::fmt::Debug for Pubcfgcr0 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgcr0")
                .field("lsipubc", &self.lsipubc())
                .field("lsepubc", &self.lsepubc())
                .field("msipubc", &self.msipubc())
                .field("hsipubc", &self.hsipubc())
                .field("hsepubc", &self.hsepubc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgcr0 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgcr0 {{ lsipubc: {=bool:?}, lsepubc: {=bool:?}, msipubc: {=bool:?}, hsipubc: {=bool:?}, hsepubc: {=bool:?} }}" , self . lsipubc () , self . lsepubc () , self . msipubc () , self . hsipubc () , self . hsepubc ())
        }
    }
    #[doc = "RCC PLL public configuration register1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgcr1(pub u32);
    impl Pubcfgcr1 {
        #[doc = "Defines the public protection of the PLL1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn pllpubc(&self, n: usize) -> bool {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the PLL1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_pllpubc(&mut self, n: usize, val: bool) {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Pubcfgcr1 {
        #[inline(always)]
        fn default() -> Pubcfgcr1 {
            Pubcfgcr1(0)
        }
    }
    impl core::fmt::Debug for Pubcfgcr1 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgcr1")
                .field("pllpubc[0]", &self.pllpubc(0usize))
                .field("pllpubc[1]", &self.pllpubc(1usize))
                .field("pllpubc[2]", &self.pllpubc(2usize))
                .field("pllpubc[3]", &self.pllpubc(3usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgcr1 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgcr1 {{ pllpubc[0]: {=bool:?}, pllpubc[1]: {=bool:?}, pllpubc[2]: {=bool:?}, pllpubc[3]: {=bool:?} }}" , self . pllpubc (0usize) , self . pllpubc (1usize) , self . pllpubc (2usize) , self . pllpubc (3usize))
        }
    }
    #[doc = "RCC divider public configuration register2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgcr2(pub u32);
    impl Pubcfgcr2 {
        #[doc = "Defines the public protection of the IC1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic1pubc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic1pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the IC2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic2pubc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic2pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the IC3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic3pubc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic3pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the IC4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic4pubc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic4pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the IC5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic5pubc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic5pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the public protection of the IC6 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic6pubc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC6 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic6pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the public protection of the IC7 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic7pubc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC7 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic7pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the public protection of the IC8 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic8pubc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC8 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic8pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the public protection of the IC9 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic9pubc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC9 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic9pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the public protection of the IC10 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic10pubc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC10 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic10pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the public protection of the IC11 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic11pubc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC11 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic11pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the public protection of the IC12 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic12pubc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC12 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic12pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the public protection of the IC13 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic13pubc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC13 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic13pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the public protection of the IC14 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic14pubc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC14 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic14pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "Defines the public protection of the IC15 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic15pubc(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC15 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic15pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "Defines the public protection of the IC16 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic16pubc(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC16 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic16pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "Defines the public protection of the IC17 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic17pubc(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC17 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic17pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "Defines the public protection of the IC18 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic18pubc(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC18 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic18pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "Defines the public protection of the IC19 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic19pubc(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC19 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic19pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "Defines the public protection of the IC20 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic20pubc(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC20 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic20pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Pubcfgcr2 {
        #[inline(always)]
        fn default() -> Pubcfgcr2 {
            Pubcfgcr2(0)
        }
    }
    impl core::fmt::Debug for Pubcfgcr2 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgcr2")
                .field("ic1pubc", &self.ic1pubc())
                .field("ic2pubc", &self.ic2pubc())
                .field("ic3pubc", &self.ic3pubc())
                .field("ic4pubc", &self.ic4pubc())
                .field("ic5pubc", &self.ic5pubc())
                .field("ic6pubc", &self.ic6pubc())
                .field("ic7pubc", &self.ic7pubc())
                .field("ic8pubc", &self.ic8pubc())
                .field("ic9pubc", &self.ic9pubc())
                .field("ic10pubc", &self.ic10pubc())
                .field("ic11pubc", &self.ic11pubc())
                .field("ic12pubc", &self.ic12pubc())
                .field("ic13pubc", &self.ic13pubc())
                .field("ic14pubc", &self.ic14pubc())
                .field("ic15pubc", &self.ic15pubc())
                .field("ic16pubc", &self.ic16pubc())
                .field("ic17pubc", &self.ic17pubc())
                .field("ic18pubc", &self.ic18pubc())
                .field("ic19pubc", &self.ic19pubc())
                .field("ic20pubc", &self.ic20pubc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgcr2 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgcr2 {{ ic1pubc: {=bool:?}, ic2pubc: {=bool:?}, ic3pubc: {=bool:?}, ic4pubc: {=bool:?}, ic5pubc: {=bool:?}, ic6pubc: {=bool:?}, ic7pubc: {=bool:?}, ic8pubc: {=bool:?}, ic9pubc: {=bool:?}, ic10pubc: {=bool:?}, ic11pubc: {=bool:?}, ic12pubc: {=bool:?}, ic13pubc: {=bool:?}, ic14pubc: {=bool:?}, ic15pubc: {=bool:?}, ic16pubc: {=bool:?}, ic17pubc: {=bool:?}, ic18pubc: {=bool:?}, ic19pubc: {=bool:?}, ic20pubc: {=bool:?} }}" , self . ic1pubc () , self . ic2pubc () , self . ic3pubc () , self . ic4pubc () , self . ic5pubc () , self . ic6pubc () , self . ic7pubc () , self . ic8pubc () , self . ic9pubc () , self . ic10pubc () , self . ic11pubc () , self . ic12pubc () , self . ic13pubc () , self . ic14pubc () , self . ic15pubc () , self . ic16pubc () , self . ic17pubc () , self . ic18pubc () , self . ic19pubc () , self . ic20pubc ())
        }
    }
    #[doc = "RCC system public configuration register3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgcr3(pub u32);
    impl Pubcfgcr3 {
        #[doc = "Defines the public protection of the MOD configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn modpubc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the MOD configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_modpubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the SYS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn syspubc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the SYS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_syspubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the BUS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn buspubc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the BUS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_buspubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the PER configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn perpubc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the PER configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_perpubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the INT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn intpubc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the INT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_intpubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the public protection of the RST configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn rstpubc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the RST configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_rstpubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the public protection of the DFT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn dftpubc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the DFT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_dftpubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Pubcfgcr3 {
        #[inline(always)]
        fn default() -> Pubcfgcr3 {
            Pubcfgcr3(0)
        }
    }
    impl core::fmt::Debug for Pubcfgcr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgcr3")
                .field("modpubc", &self.modpubc())
                .field("syspubc", &self.syspubc())
                .field("buspubc", &self.buspubc())
                .field("perpubc", &self.perpubc())
                .field("intpubc", &self.intpubc())
                .field("rstpubc", &self.rstpubc())
                .field("dftpubc", &self.dftpubc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgcr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgcr3 {{ modpubc: {=bool:?}, syspubc: {=bool:?}, buspubc: {=bool:?}, perpubc: {=bool:?}, intpubc: {=bool:?}, rstpubc: {=bool:?}, dftpubc: {=bool:?} }}" , self . modpubc () , self . syspubc () , self . buspubc () , self . perpubc () , self . intpubc () , self . rstpubc () , self . dftpubc ())
        }
    }
    #[doc = "RCC public configuration register4."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgcr4(pub u32);
    impl Pubcfgcr4 {
        #[doc = "Defines the public protection of the ACLKN configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn aclknpubc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the ACLKN configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_aclknpubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the ACLKNC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn aclkncpubc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the ACLKNC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_aclkncpubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the AHBM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahbmpubc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHBM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahbmpubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the AHB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb1pubc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb1pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the AHB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb2pubc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb2pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the public protection of the AHB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb3pubc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb3pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the public protection of the AHB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb4pubc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb4pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the public protection of the AHB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb5pubc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb5pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the public protection of the APB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb1pubc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the APB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb1pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the public protection of the APB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb2pubc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the APB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb2pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the public protection of the APB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb3pubc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the APB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb3pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the public protection of the APB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb4pubc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the APB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb4pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the public protection of the APB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb5pubc(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the APB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb5pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the public protection of the NOC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn nocpubc(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the NOC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_nocpubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
    }
    impl Default for Pubcfgcr4 {
        #[inline(always)]
        fn default() -> Pubcfgcr4 {
            Pubcfgcr4(0)
        }
    }
    impl core::fmt::Debug for Pubcfgcr4 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgcr4")
                .field("aclknpubc", &self.aclknpubc())
                .field("aclkncpubc", &self.aclkncpubc())
                .field("ahbmpubc", &self.ahbmpubc())
                .field("ahb1pubc", &self.ahb1pubc())
                .field("ahb2pubc", &self.ahb2pubc())
                .field("ahb3pubc", &self.ahb3pubc())
                .field("ahb4pubc", &self.ahb4pubc())
                .field("ahb5pubc", &self.ahb5pubc())
                .field("apb1pubc", &self.apb1pubc())
                .field("apb2pubc", &self.apb2pubc())
                .field("apb3pubc", &self.apb3pubc())
                .field("apb4pubc", &self.apb4pubc())
                .field("apb5pubc", &self.apb5pubc())
                .field("nocpubc", &self.nocpubc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgcr4 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgcr4 {{ aclknpubc: {=bool:?}, aclkncpubc: {=bool:?}, ahbmpubc: {=bool:?}, ahb1pubc: {=bool:?}, ahb2pubc: {=bool:?}, ahb3pubc: {=bool:?}, ahb4pubc: {=bool:?}, ahb5pubc: {=bool:?}, apb1pubc: {=bool:?}, apb2pubc: {=bool:?}, apb3pubc: {=bool:?}, apb4pubc: {=bool:?}, apb5pubc: {=bool:?}, nocpubc: {=bool:?} }}" , self . aclknpubc () , self . aclkncpubc () , self . ahbmpubc () , self . ahb1pubc () , self . ahb2pubc () , self . ahb3pubc () , self . ahb4pubc () , self . ahb5pubc () , self . apb1pubc () , self . apb2pubc () , self . apb3pubc () , self . apb4pubc () , self . apb5pubc () , self . nocpubc ())
        }
    }
    #[doc = "RCC public configuration register4."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgcr5(pub u32);
    impl Pubcfgcr5 {
        #[doc = "Defines the public protection of the AXISRAM3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn axisram3pubc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AXISRAM3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_axisram3pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the AXISRAM4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn axisram4pubc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AXISRAM4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_axisram4pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the AXISRAM5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn axisram5pubc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AXISRAM5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_axisram5pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the AXISRAM6 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn axisram6pubc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AXISRAM6 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_axisram6pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the AHBSRAM1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahbsram1pubc(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHBSRAM1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahbsram1pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the public protection of the AHBSRAM2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahbsram2pubc(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHBSRAM2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahbsram2pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the public protection of the BKPSRAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn bkpsrampubc(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the BKPSRAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_bkpsrampubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the public protection of the AXISRAM1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn axisram1pubc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AXISRAM1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_axisram1pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the public protection of the AXISRAM2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn axisram2pubc(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AXISRAM2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_axisram2pubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the public protection of the FLEXRAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn flexrampubc(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the FLEXRAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_flexrampubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the public protection of the NPUCACHERAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn cacheaxirampubc(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the NPUCACHERAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_cacheaxirampubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the public protection of the VENCRAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn vencrampubc(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the VENCRAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_vencrampubc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
    }
    impl Default for Pubcfgcr5 {
        #[inline(always)]
        fn default() -> Pubcfgcr5 {
            Pubcfgcr5(0)
        }
    }
    impl core::fmt::Debug for Pubcfgcr5 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgcr5")
                .field("axisram3pubc", &self.axisram3pubc())
                .field("axisram4pubc", &self.axisram4pubc())
                .field("axisram5pubc", &self.axisram5pubc())
                .field("axisram6pubc", &self.axisram6pubc())
                .field("ahbsram1pubc", &self.ahbsram1pubc())
                .field("ahbsram2pubc", &self.ahbsram2pubc())
                .field("bkpsrampubc", &self.bkpsrampubc())
                .field("axisram1pubc", &self.axisram1pubc())
                .field("axisram2pubc", &self.axisram2pubc())
                .field("flexrampubc", &self.flexrampubc())
                .field("cacheaxirampubc", &self.cacheaxirampubc())
                .field("vencrampubc", &self.vencrampubc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgcr5 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgcr5 {{ axisram3pubc: {=bool:?}, axisram4pubc: {=bool:?}, axisram5pubc: {=bool:?}, axisram6pubc: {=bool:?}, ahbsram1pubc: {=bool:?}, ahbsram2pubc: {=bool:?}, bkpsrampubc: {=bool:?}, axisram1pubc: {=bool:?}, axisram2pubc: {=bool:?}, flexrampubc: {=bool:?}, cacheaxirampubc: {=bool:?}, vencrampubc: {=bool:?} }}" , self . axisram3pubc () , self . axisram4pubc () , self . axisram5pubc () , self . axisram6pubc () , self . ahbsram1pubc () , self . ahbsram2pubc () , self . bkpsrampubc () , self . axisram1pubc () , self . axisram2pubc () , self . flexrampubc () , self . cacheaxirampubc () , self . vencrampubc ())
        }
    }
    #[doc = "RCC oscillator public configuration register0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgr0(pub u32);
    impl Pubcfgr0 {
        #[doc = "Defines the public protection of the LSI oscillator configuration bits."]
        #[inline(always)]
        pub const fn lsipub(&self) -> super::vals::Lsipub {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Lsipub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the LSI oscillator configuration bits."]
        #[inline(always)]
        pub fn set_lsipub(&mut self, val: super::vals::Lsipub) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the LSE oscillator configuration bits."]
        #[inline(always)]
        pub const fn lsepub(&self) -> super::vals::Lsepub {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Lsepub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the LSE oscillator configuration bits."]
        #[inline(always)]
        pub fn set_lsepub(&mut self, val: super::vals::Lsepub) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the MSI oscillator configuration bits."]
        #[inline(always)]
        pub const fn msipub(&self) -> super::vals::Msipub {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Msipub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the MSI oscillator configuration bits."]
        #[inline(always)]
        pub fn set_msipub(&mut self, val: super::vals::Msipub) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the HSI oscillator configuration bits."]
        #[inline(always)]
        pub const fn hsipub(&self) -> super::vals::Hsipub {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Hsipub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the HSI oscillator configuration bits."]
        #[inline(always)]
        pub fn set_hsipub(&mut self, val: super::vals::Hsipub) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the HSE oscillator configuration bits."]
        #[inline(always)]
        pub const fn hsepub(&self) -> super::vals::Hsepub {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Hsepub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the HSE oscillator configuration bits."]
        #[inline(always)]
        pub fn set_hsepub(&mut self, val: super::vals::Hsepub) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Pubcfgr0 {
        #[inline(always)]
        fn default() -> Pubcfgr0 {
            Pubcfgr0(0)
        }
    }
    impl core::fmt::Debug for Pubcfgr0 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgr0")
                .field("lsipub", &self.lsipub())
                .field("lsepub", &self.lsepub())
                .field("msipub", &self.msipub())
                .field("hsipub", &self.hsipub())
                .field("hsepub", &self.hsepub())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgr0 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Pubcfgr0 {{ lsipub: {:?}, lsepub: {:?}, msipub: {:?}, hsipub: {:?}, hsepub: {:?} }}",
                self.lsipub(),
                self.lsepub(),
                self.msipub(),
                self.hsipub(),
                self.hsepub()
            )
        }
    }
    #[doc = "RCC PLL public configuration register1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgr1(pub u32);
    impl Pubcfgr1 {
        #[doc = "Defines the public protection of the PLL1 PLL configuration bits."]
        #[inline(always)]
        pub const fn pllpub(&self, n: usize) -> super::vals::Pllpub {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the PLL1 PLL configuration bits."]
        #[inline(always)]
        pub fn set_pllpub(&mut self, n: usize, val: super::vals::Pllpub) {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
    }
    impl Default for Pubcfgr1 {
        #[inline(always)]
        fn default() -> Pubcfgr1 {
            Pubcfgr1(0)
        }
    }
    impl core::fmt::Debug for Pubcfgr1 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgr1")
                .field("pllpub[0]", &self.pllpub(0usize))
                .field("pllpub[1]", &self.pllpub(1usize))
                .field("pllpub[2]", &self.pllpub(2usize))
                .field("pllpub[3]", &self.pllpub(3usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgr1 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Pubcfgr1 {{ pllpub[0]: {:?}, pllpub[1]: {:?}, pllpub[2]: {:?}, pllpub[3]: {:?} }}",
                self.pllpub(0usize),
                self.pllpub(1usize),
                self.pllpub(2usize),
                self.pllpub(3usize)
            )
        }
    }
    #[doc = "RCC divider public configuration register2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgr2(pub u32);
    impl Pubcfgr2 {
        #[doc = "Defines the public protection of the IC1 divider configuration bits."]
        #[inline(always)]
        pub const fn ic1pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC1 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic1pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the IC2 divider configuration bits."]
        #[inline(always)]
        pub const fn ic2pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC2 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic2pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the IC3 divider configuration bits."]
        #[inline(always)]
        pub const fn ic3pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC3 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic3pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the IC4 divider configuration bits."]
        #[inline(always)]
        pub const fn ic4pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC4 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic4pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the IC5 divider configuration bits."]
        #[inline(always)]
        pub const fn ic5pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC5 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic5pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the public protection of the IC6 divider configuration bits."]
        #[inline(always)]
        pub const fn ic6pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 5usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC6 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic6pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the public protection of the IC7 divider configuration bits."]
        #[inline(always)]
        pub const fn ic7pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC7 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic7pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the public protection of the IC8 divider configuration bits."]
        #[inline(always)]
        pub const fn ic8pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 7usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC8 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic8pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the public protection of the IC9 divider configuration bits."]
        #[inline(always)]
        pub const fn ic9pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC9 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic9pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the public protection of the IC10 divider configuration bits."]
        #[inline(always)]
        pub const fn ic10pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC10 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic10pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the public protection of the IC11 divider configuration bits."]
        #[inline(always)]
        pub const fn ic11pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 10usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC11 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic11pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the public protection of the IC12 divider configuration bits."]
        #[inline(always)]
        pub const fn ic12pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 11usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC12 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic12pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the public protection of the IC13 divider configuration bits."]
        #[inline(always)]
        pub const fn ic13pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 12usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC13 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic13pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the public protection of the IC14 divider configuration bits."]
        #[inline(always)]
        pub const fn ic14pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 13usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC14 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic14pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
        }
        #[doc = "Defines the public protection of the IC15 divider configuration bits."]
        #[inline(always)]
        pub const fn ic15pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 14usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC15 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic15pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
        }
        #[doc = "Defines the public protection of the IC16 divider configuration bits."]
        #[inline(always)]
        pub const fn ic16pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 15usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC16 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic16pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
        }
        #[doc = "Defines the public protection of the IC17 divider configuration bits."]
        #[inline(always)]
        pub const fn ic17pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC17 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic17pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
        #[doc = "Defines the public protection of the IC18 divider configuration bits."]
        #[inline(always)]
        pub const fn ic18pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 17usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC18 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic18pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
        }
        #[doc = "Defines the public protection of the IC19 divider configuration bits."]
        #[inline(always)]
        pub const fn ic19pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 18usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC19 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic19pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
        }
        #[doc = "Defines the public protection of the IC20 divider configuration bits."]
        #[inline(always)]
        pub const fn ic20pub(&self) -> super::vals::Icpub {
            let val = (self.0 >> 19usize) & 0x01;
            super::vals::Icpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the IC20 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic20pub(&mut self, val: super::vals::Icpub) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Pubcfgr2 {
        #[inline(always)]
        fn default() -> Pubcfgr2 {
            Pubcfgr2(0)
        }
    }
    impl core::fmt::Debug for Pubcfgr2 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgr2")
                .field("ic1pub", &self.ic1pub())
                .field("ic2pub", &self.ic2pub())
                .field("ic3pub", &self.ic3pub())
                .field("ic4pub", &self.ic4pub())
                .field("ic5pub", &self.ic5pub())
                .field("ic6pub", &self.ic6pub())
                .field("ic7pub", &self.ic7pub())
                .field("ic8pub", &self.ic8pub())
                .field("ic9pub", &self.ic9pub())
                .field("ic10pub", &self.ic10pub())
                .field("ic11pub", &self.ic11pub())
                .field("ic12pub", &self.ic12pub())
                .field("ic13pub", &self.ic13pub())
                .field("ic14pub", &self.ic14pub())
                .field("ic15pub", &self.ic15pub())
                .field("ic16pub", &self.ic16pub())
                .field("ic17pub", &self.ic17pub())
                .field("ic18pub", &self.ic18pub())
                .field("ic19pub", &self.ic19pub())
                .field("ic20pub", &self.ic20pub())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgr2 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgr2 {{ ic1pub: {:?}, ic2pub: {:?}, ic3pub: {:?}, ic4pub: {:?}, ic5pub: {:?}, ic6pub: {:?}, ic7pub: {:?}, ic8pub: {:?}, ic9pub: {:?}, ic10pub: {:?}, ic11pub: {:?}, ic12pub: {:?}, ic13pub: {:?}, ic14pub: {:?}, ic15pub: {:?}, ic16pub: {:?}, ic17pub: {:?}, ic18pub: {:?}, ic19pub: {:?}, ic20pub: {:?} }}" , self . ic1pub () , self . ic2pub () , self . ic3pub () , self . ic4pub () , self . ic5pub () , self . ic6pub () , self . ic7pub () , self . ic8pub () , self . ic9pub () , self . ic10pub () , self . ic11pub () , self . ic12pub () , self . ic13pub () , self . ic14pub () , self . ic15pub () , self . ic16pub () , self . ic17pub () , self . ic18pub () , self . ic19pub () , self . ic20pub ())
        }
    }
    #[doc = "RCC system public configuration register3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgr3(pub u32);
    impl Pubcfgr3 {
        #[doc = "Defines the public protection of the MOD system configuration bits."]
        #[inline(always)]
        pub const fn modpub(&self) -> super::vals::Modpub {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Modpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the MOD system configuration bits."]
        #[inline(always)]
        pub fn set_modpub(&mut self, val: super::vals::Modpub) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the SYS system configuration bits."]
        #[inline(always)]
        pub const fn syspub(&self) -> super::vals::Syspub {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Syspub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the SYS system configuration bits."]
        #[inline(always)]
        pub fn set_syspub(&mut self, val: super::vals::Syspub) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the BUS system configuration bits."]
        #[inline(always)]
        pub const fn buspub(&self) -> super::vals::Buspub {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Buspub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the BUS system configuration bits."]
        #[inline(always)]
        pub fn set_buspub(&mut self, val: super::vals::Buspub) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the PER system configuration bits."]
        #[inline(always)]
        pub const fn perpub(&self) -> super::vals::Perpub {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Perpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the PER system configuration bits."]
        #[inline(always)]
        pub fn set_perpub(&mut self, val: super::vals::Perpub) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the INT system configuration bits."]
        #[inline(always)]
        pub const fn intpub(&self) -> super::vals::Intpub {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Intpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the INT system configuration bits."]
        #[inline(always)]
        pub fn set_intpub(&mut self, val: super::vals::Intpub) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the public protection of the RST system configuration bits."]
        #[inline(always)]
        pub const fn rstpub(&self) -> super::vals::Rstpub {
            let val = (self.0 >> 5usize) & 0x01;
            super::vals::Rstpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the RST system configuration bits."]
        #[inline(always)]
        pub fn set_rstpub(&mut self, val: super::vals::Rstpub) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the public protection of the DFT system configuration bits."]
        #[inline(always)]
        pub const fn dftpub(&self) -> super::vals::Dftpub {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Dftpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the DFT system configuration bits."]
        #[inline(always)]
        pub fn set_dftpub(&mut self, val: super::vals::Dftpub) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Pubcfgr3 {
        #[inline(always)]
        fn default() -> Pubcfgr3 {
            Pubcfgr3(0)
        }
    }
    impl core::fmt::Debug for Pubcfgr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgr3")
                .field("modpub", &self.modpub())
                .field("syspub", &self.syspub())
                .field("buspub", &self.buspub())
                .field("perpub", &self.perpub())
                .field("intpub", &self.intpub())
                .field("rstpub", &self.rstpub())
                .field("dftpub", &self.dftpub())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgr3 {{ modpub: {:?}, syspub: {:?}, buspub: {:?}, perpub: {:?}, intpub: {:?}, rstpub: {:?}, dftpub: {:?} }}" , self . modpub () , self . syspub () , self . buspub () , self . perpub () , self . intpub () , self . rstpub () , self . dftpub ())
        }
    }
    #[doc = "RCC bus public configuration register4."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgr4(pub u32);
    impl Pubcfgr4 {
        #[doc = "Defines the public protection of the ACLKN bus configuration bits."]
        #[inline(always)]
        pub const fn aclknpub(&self) -> super::vals::Aclknpub {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Aclknpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the ACLKN bus configuration bits."]
        #[inline(always)]
        pub fn set_aclknpub(&mut self, val: super::vals::Aclknpub) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the ACLKNC bus configuration bits."]
        #[inline(always)]
        pub const fn aclkncpub(&self) -> super::vals::Aclkncpub {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Aclkncpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the ACLKNC bus configuration bits."]
        #[inline(always)]
        pub fn set_aclkncpub(&mut self, val: super::vals::Aclkncpub) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the AHBM bus configuration bits."]
        #[inline(always)]
        pub const fn ahbmpub(&self) -> super::vals::Ahbmpub {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Ahbmpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the AHBM bus configuration bits."]
        #[inline(always)]
        pub fn set_ahbmpub(&mut self, val: super::vals::Ahbmpub) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the AHB1 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb1pub(&self) -> super::vals::Ahbpub {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Ahbpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the AHB1 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb1pub(&mut self, val: super::vals::Ahbpub) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the AHB2 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb2pub(&self) -> super::vals::Ahbpub {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Ahbpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the AHB2 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb2pub(&mut self, val: super::vals::Ahbpub) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the public protection of the AHB3 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb3pub(&self) -> super::vals::Ahbpub {
            let val = (self.0 >> 5usize) & 0x01;
            super::vals::Ahbpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the AHB3 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb3pub(&mut self, val: super::vals::Ahbpub) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the public protection of the AHB4 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb4pub(&self) -> super::vals::Ahbpub {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Ahbpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the AHB4 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb4pub(&mut self, val: super::vals::Ahbpub) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the public protection of the AHB5 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb5pub(&self) -> super::vals::Ahbpub {
            let val = (self.0 >> 7usize) & 0x01;
            super::vals::Ahbpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the AHB5 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb5pub(&mut self, val: super::vals::Ahbpub) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the public protection of the APB1 bus configuration bits."]
        #[inline(always)]
        pub const fn apb1pub(&self) -> super::vals::Apbpub {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Apbpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the APB1 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb1pub(&mut self, val: super::vals::Apbpub) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the public protection of the APB2 bus configuration bits."]
        #[inline(always)]
        pub const fn apb2pub(&self) -> super::vals::Apbpub {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Apbpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the APB2 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb2pub(&mut self, val: super::vals::Apbpub) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the public protection of the APB3 bus configuration bits."]
        #[inline(always)]
        pub const fn apb3pub(&self) -> super::vals::Apbpub {
            let val = (self.0 >> 10usize) & 0x01;
            super::vals::Apbpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the APB3 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb3pub(&mut self, val: super::vals::Apbpub) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the public protection of the APB4 bus configuration bits."]
        #[inline(always)]
        pub const fn apb4pub(&self) -> super::vals::Apbpub {
            let val = (self.0 >> 11usize) & 0x01;
            super::vals::Apbpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the APB4 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb4pub(&mut self, val: super::vals::Apbpub) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the public protection of the APB5 bus configuration bits."]
        #[inline(always)]
        pub const fn apb5pub(&self) -> super::vals::Apbpub {
            let val = (self.0 >> 12usize) & 0x01;
            super::vals::Apbpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the APB5 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb5pub(&mut self, val: super::vals::Apbpub) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the public protection of the NOC bus configuration bits."]
        #[inline(always)]
        pub const fn nocpub(&self) -> super::vals::Nocpub {
            let val = (self.0 >> 13usize) & 0x01;
            super::vals::Nocpub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the NOC bus configuration bits."]
        #[inline(always)]
        pub fn set_nocpub(&mut self, val: super::vals::Nocpub) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
        }
    }
    impl Default for Pubcfgr4 {
        #[inline(always)]
        fn default() -> Pubcfgr4 {
            Pubcfgr4(0)
        }
    }
    impl core::fmt::Debug for Pubcfgr4 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgr4")
                .field("aclknpub", &self.aclknpub())
                .field("aclkncpub", &self.aclkncpub())
                .field("ahbmpub", &self.ahbmpub())
                .field("ahb1pub", &self.ahb1pub())
                .field("ahb2pub", &self.ahb2pub())
                .field("ahb3pub", &self.ahb3pub())
                .field("ahb4pub", &self.ahb4pub())
                .field("ahb5pub", &self.ahb5pub())
                .field("apb1pub", &self.apb1pub())
                .field("apb2pub", &self.apb2pub())
                .field("apb3pub", &self.apb3pub())
                .field("apb4pub", &self.apb4pub())
                .field("apb5pub", &self.apb5pub())
                .field("nocpub", &self.nocpub())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgr4 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgr4 {{ aclknpub: {:?}, aclkncpub: {:?}, ahbmpub: {:?}, ahb1pub: {:?}, ahb2pub: {:?}, ahb3pub: {:?}, ahb4pub: {:?}, ahb5pub: {:?}, apb1pub: {:?}, apb2pub: {:?}, apb3pub: {:?}, apb4pub: {:?}, apb5pub: {:?}, nocpub: {:?} }}" , self . aclknpub () , self . aclkncpub () , self . ahbmpub () , self . ahb1pub () , self . ahb2pub () , self . ahb3pub () , self . ahb4pub () , self . ahb5pub () , self . apb1pub () , self . apb2pub () , self . apb3pub () , self . apb4pub () , self . apb5pub () , self . nocpub ())
        }
    }
    #[doc = "RCC bus public configuration register4."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgr5(pub u32);
    impl Pubcfgr5 {
        #[doc = "Defines the public protection of the AXISRAM3 bus configuration bits."]
        #[inline(always)]
        pub const fn axisram3pub(&self) -> super::vals::Axisrampub {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Axisrampub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the AXISRAM3 bus configuration bits."]
        #[inline(always)]
        pub fn set_axisram3pub(&mut self, val: super::vals::Axisrampub) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the AXISRAM4 bus configuration bits."]
        #[inline(always)]
        pub const fn axisram4pub(&self) -> super::vals::Axisrampub {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Axisrampub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the AXISRAM4 bus configuration bits."]
        #[inline(always)]
        pub fn set_axisram4pub(&mut self, val: super::vals::Axisrampub) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the AXISRAM5 bus configuration bits."]
        #[inline(always)]
        pub const fn axisram5pub(&self) -> super::vals::Axisrampub {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Axisrampub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the AXISRAM5 bus configuration bits."]
        #[inline(always)]
        pub fn set_axisram5pub(&mut self, val: super::vals::Axisrampub) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the AXISRAM6 bus configuration bits."]
        #[inline(always)]
        pub const fn axisram6pub(&self) -> super::vals::Axisrampub {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Axisrampub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the AXISRAM6 bus configuration bits."]
        #[inline(always)]
        pub fn set_axisram6pub(&mut self, val: super::vals::Axisrampub) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the AHBSRAM1 bus configuration bits."]
        #[inline(always)]
        pub const fn ahbsram1pub(&self) -> super::vals::Ahbsrampub {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Ahbsrampub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the AHBSRAM1 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahbsram1pub(&mut self, val: super::vals::Ahbsrampub) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the public protection of the AHBSRAM2 bus configuration bits."]
        #[inline(always)]
        pub const fn ahbsram2pub(&self) -> super::vals::Ahbsrampub {
            let val = (self.0 >> 5usize) & 0x01;
            super::vals::Ahbsrampub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the AHBSRAM2 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahbsram2pub(&mut self, val: super::vals::Ahbsrampub) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the public protection of the BKPSRAM bus configuration bits."]
        #[inline(always)]
        pub const fn bkpsrampub(&self) -> super::vals::Bkpsrampub {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Bkpsrampub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the BKPSRAM bus configuration bits."]
        #[inline(always)]
        pub fn set_bkpsrampub(&mut self, val: super::vals::Bkpsrampub) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the public protection of the AXISRAM1 bus configuration bits."]
        #[inline(always)]
        pub const fn axisram1pub(&self) -> super::vals::Axisrampub {
            let val = (self.0 >> 7usize) & 0x01;
            super::vals::Axisrampub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the AXISRAM1 bus configuration bits."]
        #[inline(always)]
        pub fn set_axisram1pub(&mut self, val: super::vals::Axisrampub) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the public protection of the AXISRAM2 bus configuration bits."]
        #[inline(always)]
        pub const fn axisram2pub(&self) -> super::vals::Axisrampub {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Axisrampub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the AXISRAM2 bus configuration bits."]
        #[inline(always)]
        pub fn set_axisram2pub(&mut self, val: super::vals::Axisrampub) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the public protection of the FLEXRAM bus configuration bits."]
        #[inline(always)]
        pub const fn flexrampub(&self) -> super::vals::Flexrampub {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Flexrampub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the FLEXRAM bus configuration bits."]
        #[inline(always)]
        pub fn set_flexrampub(&mut self, val: super::vals::Flexrampub) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the public protection of the NPUCACHERAM bus configuration bits."]
        #[inline(always)]
        pub const fn npucacherampub(&self) -> super::vals::Npucacherampub {
            let val = (self.0 >> 10usize) & 0x01;
            super::vals::Npucacherampub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the NPUCACHERAM bus configuration bits."]
        #[inline(always)]
        pub fn set_npucacherampub(&mut self, val: super::vals::Npucacherampub) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the public protection of the VENCRAM bus configuration bits."]
        #[inline(always)]
        pub const fn vencrampub(&self) -> super::vals::Vencrampub {
            let val = (self.0 >> 11usize) & 0x01;
            super::vals::Vencrampub::from_bits(val as u8)
        }
        #[doc = "Defines the public protection of the VENCRAM bus configuration bits."]
        #[inline(always)]
        pub fn set_vencrampub(&mut self, val: super::vals::Vencrampub) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
        }
    }
    impl Default for Pubcfgr5 {
        #[inline(always)]
        fn default() -> Pubcfgr5 {
            Pubcfgr5(0)
        }
    }
    impl core::fmt::Debug for Pubcfgr5 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgr5")
                .field("axisram3pub", &self.axisram3pub())
                .field("axisram4pub", &self.axisram4pub())
                .field("axisram5pub", &self.axisram5pub())
                .field("axisram6pub", &self.axisram6pub())
                .field("ahbsram1pub", &self.ahbsram1pub())
                .field("ahbsram2pub", &self.ahbsram2pub())
                .field("bkpsrampub", &self.bkpsrampub())
                .field("axisram1pub", &self.axisram1pub())
                .field("axisram2pub", &self.axisram2pub())
                .field("flexrampub", &self.flexrampub())
                .field("npucacherampub", &self.npucacherampub())
                .field("vencrampub", &self.vencrampub())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgr5 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgr5 {{ axisram3pub: {:?}, axisram4pub: {:?}, axisram5pub: {:?}, axisram6pub: {:?}, ahbsram1pub: {:?}, ahbsram2pub: {:?}, bkpsrampub: {:?}, axisram1pub: {:?}, axisram2pub: {:?}, flexrampub: {:?}, npucacherampub: {:?}, vencrampub: {:?} }}" , self . axisram3pub () , self . axisram4pub () , self . axisram5pub () , self . axisram6pub () , self . ahbsram1pub () , self . ahbsram2pub () , self . bkpsrampub () , self . axisram1pub () , self . axisram2pub () , self . flexrampub () , self . npucacherampub () , self . vencrampub ())
        }
    }
    #[doc = "RCC oscillator public configuration register0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgsr0(pub u32);
    impl Pubcfgsr0 {
        #[doc = "Defines the public protection of the LSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn lsipubs(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the LSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_lsipubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the LSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn lsepubs(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the LSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_lsepubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the MSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn msipubs(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the MSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_msipubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the HSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn hsipubs(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the HSI configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_hsipubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the HSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn hsepubs(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the HSE configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_hsepubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Pubcfgsr0 {
        #[inline(always)]
        fn default() -> Pubcfgsr0 {
            Pubcfgsr0(0)
        }
    }
    impl core::fmt::Debug for Pubcfgsr0 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgsr0")
                .field("lsipubs", &self.lsipubs())
                .field("lsepubs", &self.lsepubs())
                .field("msipubs", &self.msipubs())
                .field("hsipubs", &self.hsipubs())
                .field("hsepubs", &self.hsepubs())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgsr0 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgsr0 {{ lsipubs: {=bool:?}, lsepubs: {=bool:?}, msipubs: {=bool:?}, hsipubs: {=bool:?}, hsepubs: {=bool:?} }}" , self . lsipubs () , self . lsepubs () , self . msipubs () , self . hsipubs () , self . hsepubs ())
        }
    }
    #[doc = "RCC PLL public configuration register1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgsr1(pub u32);
    impl Pubcfgsr1 {
        #[doc = "Defines the public protection of the PLL1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn pllpubs(&self, n: usize) -> bool {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the PLL1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_pllpubs(&mut self, n: usize, val: bool) {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Pubcfgsr1 {
        #[inline(always)]
        fn default() -> Pubcfgsr1 {
            Pubcfgsr1(0)
        }
    }
    impl core::fmt::Debug for Pubcfgsr1 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgsr1")
                .field("pllpubs[0]", &self.pllpubs(0usize))
                .field("pllpubs[1]", &self.pllpubs(1usize))
                .field("pllpubs[2]", &self.pllpubs(2usize))
                .field("pllpubs[3]", &self.pllpubs(3usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgsr1 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgsr1 {{ pllpubs[0]: {=bool:?}, pllpubs[1]: {=bool:?}, pllpubs[2]: {=bool:?}, pllpubs[3]: {=bool:?} }}" , self . pllpubs (0usize) , self . pllpubs (1usize) , self . pllpubs (2usize) , self . pllpubs (3usize))
        }
    }
    #[doc = "RCC divider public configuration register2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgsr2(pub u32);
    impl Pubcfgsr2 {
        #[doc = "Defines the public protection of the IC1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic1pubs(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic1pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the IC2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic2pubs(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic2pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the IC3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic3pubs(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic3pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the IC4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic4pubs(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic4pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the IC5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic5pubs(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic5pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the public protection of the IC6 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic6pubs(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC6 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic6pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the public protection of the IC7 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic7pubs(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC7 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic7pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the public protection of the IC8 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic8pubs(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC8 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic8pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the public protection of the IC9 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic9pubs(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC9 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic9pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the public protection of the IC10 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic10pubs(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC10 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic10pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the public protection of the IC11 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic11pubs(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC11 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic11pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the public protection of the IC12 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic12pubs(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC12 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic12pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the public protection of the IC13 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic13pubs(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC13 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic13pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the public protection of the IC14 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic14pubs(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC14 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic14pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "Defines the public protection of the IC15 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic15pubs(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC15 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic15pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "Defines the public protection of the IC16 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic16pubs(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC16 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic16pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "Defines the public protection of the IC17 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic17pubs(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC17 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic17pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "Defines the public protection of the IC18 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic18pubs(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC18 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic18pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "Defines the public protection of the IC19 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic19pubs(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC19 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic19pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "Defines the public protection of the IC20 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ic20pubs(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the IC20 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ic20pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Pubcfgsr2 {
        #[inline(always)]
        fn default() -> Pubcfgsr2 {
            Pubcfgsr2(0)
        }
    }
    impl core::fmt::Debug for Pubcfgsr2 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgsr2")
                .field("ic1pubs", &self.ic1pubs())
                .field("ic2pubs", &self.ic2pubs())
                .field("ic3pubs", &self.ic3pubs())
                .field("ic4pubs", &self.ic4pubs())
                .field("ic5pubs", &self.ic5pubs())
                .field("ic6pubs", &self.ic6pubs())
                .field("ic7pubs", &self.ic7pubs())
                .field("ic8pubs", &self.ic8pubs())
                .field("ic9pubs", &self.ic9pubs())
                .field("ic10pubs", &self.ic10pubs())
                .field("ic11pubs", &self.ic11pubs())
                .field("ic12pubs", &self.ic12pubs())
                .field("ic13pubs", &self.ic13pubs())
                .field("ic14pubs", &self.ic14pubs())
                .field("ic15pubs", &self.ic15pubs())
                .field("ic16pubs", &self.ic16pubs())
                .field("ic17pubs", &self.ic17pubs())
                .field("ic18pubs", &self.ic18pubs())
                .field("ic19pubs", &self.ic19pubs())
                .field("ic20pubs", &self.ic20pubs())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgsr2 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgsr2 {{ ic1pubs: {=bool:?}, ic2pubs: {=bool:?}, ic3pubs: {=bool:?}, ic4pubs: {=bool:?}, ic5pubs: {=bool:?}, ic6pubs: {=bool:?}, ic7pubs: {=bool:?}, ic8pubs: {=bool:?}, ic9pubs: {=bool:?}, ic10pubs: {=bool:?}, ic11pubs: {=bool:?}, ic12pubs: {=bool:?}, ic13pubs: {=bool:?}, ic14pubs: {=bool:?}, ic15pubs: {=bool:?}, ic16pubs: {=bool:?}, ic17pubs: {=bool:?}, ic18pubs: {=bool:?}, ic19pubs: {=bool:?}, ic20pubs: {=bool:?} }}" , self . ic1pubs () , self . ic2pubs () , self . ic3pubs () , self . ic4pubs () , self . ic5pubs () , self . ic6pubs () , self . ic7pubs () , self . ic8pubs () , self . ic9pubs () , self . ic10pubs () , self . ic11pubs () , self . ic12pubs () , self . ic13pubs () , self . ic14pubs () , self . ic15pubs () , self . ic16pubs () , self . ic17pubs () , self . ic18pubs () , self . ic19pubs () , self . ic20pubs ())
        }
    }
    #[doc = "RCC system public configuration register3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgsr3(pub u32);
    impl Pubcfgsr3 {
        #[doc = "Defines the public protection of the MOD configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn modpubs(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the MOD configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_modpubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the SYS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn syspubs(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the SYS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_syspubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the BUS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn buspubs(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the BUS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_buspubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the PER configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn perpubs(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the PER configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_perpubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the INT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn intpubs(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the INT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_intpubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the public protection of the RST configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn rstpubs(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the RST configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_rstpubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the public protection of the DFT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn dftpubs(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the DFT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_dftpubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Pubcfgsr3 {
        #[inline(always)]
        fn default() -> Pubcfgsr3 {
            Pubcfgsr3(0)
        }
    }
    impl core::fmt::Debug for Pubcfgsr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgsr3")
                .field("modpubs", &self.modpubs())
                .field("syspubs", &self.syspubs())
                .field("buspubs", &self.buspubs())
                .field("perpubs", &self.perpubs())
                .field("intpubs", &self.intpubs())
                .field("rstpubs", &self.rstpubs())
                .field("dftpubs", &self.dftpubs())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgsr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgsr3 {{ modpubs: {=bool:?}, syspubs: {=bool:?}, buspubs: {=bool:?}, perpubs: {=bool:?}, intpubs: {=bool:?}, rstpubs: {=bool:?}, dftpubs: {=bool:?} }}" , self . modpubs () , self . syspubs () , self . buspubs () , self . perpubs () , self . intpubs () , self . rstpubs () , self . dftpubs ())
        }
    }
    #[doc = "RCC public configuration register4."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgsr4(pub u32);
    impl Pubcfgsr4 {
        #[doc = "Defines the public protection of the ACLKN configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn aclknpubs(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the ACLKN configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_aclknpubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the ACLKNC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn aclkncpubs(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the ACLKNC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_aclkncpubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the AHBM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahbmpubs(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHBM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahbmpubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the AHB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb1pubs(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb1pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the AHB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb2pubs(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb2pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the public protection of the AHB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb3pubs(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb3pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the public protection of the AHB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb4pubs(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb4pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the public protection of the AHB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahb5pubs(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahb5pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the public protection of the APB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb1pubs(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the APB1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb1pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the public protection of the APB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb2pubs(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the APB2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb2pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the public protection of the APB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb3pubs(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the APB3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb3pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the public protection of the APB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb4pubs(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the APB4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb4pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the public protection of the APB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn apb5pubs(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the APB5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_apb5pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the public protection of the NOC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn nocpubs(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the NOC configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_nocpubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
    }
    impl Default for Pubcfgsr4 {
        #[inline(always)]
        fn default() -> Pubcfgsr4 {
            Pubcfgsr4(0)
        }
    }
    impl core::fmt::Debug for Pubcfgsr4 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgsr4")
                .field("aclknpubs", &self.aclknpubs())
                .field("aclkncpubs", &self.aclkncpubs())
                .field("ahbmpubs", &self.ahbmpubs())
                .field("ahb1pubs", &self.ahb1pubs())
                .field("ahb2pubs", &self.ahb2pubs())
                .field("ahb3pubs", &self.ahb3pubs())
                .field("ahb4pubs", &self.ahb4pubs())
                .field("ahb5pubs", &self.ahb5pubs())
                .field("apb1pubs", &self.apb1pubs())
                .field("apb2pubs", &self.apb2pubs())
                .field("apb3pubs", &self.apb3pubs())
                .field("apb4pubs", &self.apb4pubs())
                .field("apb5pubs", &self.apb5pubs())
                .field("nocpubs", &self.nocpubs())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgsr4 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgsr4 {{ aclknpubs: {=bool:?}, aclkncpubs: {=bool:?}, ahbmpubs: {=bool:?}, ahb1pubs: {=bool:?}, ahb2pubs: {=bool:?}, ahb3pubs: {=bool:?}, ahb4pubs: {=bool:?}, ahb5pubs: {=bool:?}, apb1pubs: {=bool:?}, apb2pubs: {=bool:?}, apb3pubs: {=bool:?}, apb4pubs: {=bool:?}, apb5pubs: {=bool:?}, nocpubs: {=bool:?} }}" , self . aclknpubs () , self . aclkncpubs () , self . ahbmpubs () , self . ahb1pubs () , self . ahb2pubs () , self . ahb3pubs () , self . ahb4pubs () , self . ahb5pubs () , self . apb1pubs () , self . apb2pubs () , self . apb3pubs () , self . apb4pubs () , self . apb5pubs () , self . nocpubs ())
        }
    }
    #[doc = "RCC public configuration register4."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubcfgsr5(pub u32);
    impl Pubcfgsr5 {
        #[doc = "Defines the public protection of the AXISRAM3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn axisram3pubs(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AXISRAM3 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_axisram3pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the public protection of the AXISRAM4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn axisram4pubs(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AXISRAM4 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_axisram4pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the public protection of the AXISRAM5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn axisram5pubs(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AXISRAM5 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_axisram5pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the public protection of the AXISRAM6 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn axisram6pubs(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AXISRAM6 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_axisram6pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the public protection of the AHBSRAM1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahbsram1pubs(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHBSRAM1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahbsram1pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the public protection of the AHBSRAM2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn ahbsram2pubs(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AHBSRAM2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_ahbsram2pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the public protection of the BKPSRAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn bkpsrampubs(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the BKPSRAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_bkpsrampubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the public protection of the AXISRAM1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn axisram1pubs(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AXISRAM1 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_axisram1pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the public protection of the AXISRAM2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn axisram2pubs(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the AXISRAM2 configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_axisram2pubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the public protection of the FLEXRAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn flexrampubs(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the FLEXRAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_flexrampubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the public protection of the NPUCACHERAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn npucacherampubs(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the NPUCACHERAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_npucacherampubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the public protection of the VENCRAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn vencrampubs(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the public protection of the VENCRAM configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_vencrampubs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
    }
    impl Default for Pubcfgsr5 {
        #[inline(always)]
        fn default() -> Pubcfgsr5 {
            Pubcfgsr5(0)
        }
    }
    impl core::fmt::Debug for Pubcfgsr5 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Pubcfgsr5")
                .field("axisram3pubs", &self.axisram3pubs())
                .field("axisram4pubs", &self.axisram4pubs())
                .field("axisram5pubs", &self.axisram5pubs())
                .field("axisram6pubs", &self.axisram6pubs())
                .field("ahbsram1pubs", &self.ahbsram1pubs())
                .field("ahbsram2pubs", &self.ahbsram2pubs())
                .field("bkpsrampubs", &self.bkpsrampubs())
                .field("axisram1pubs", &self.axisram1pubs())
                .field("axisram2pubs", &self.axisram2pubs())
                .field("flexrampubs", &self.flexrampubs())
                .field("npucacherampubs", &self.npucacherampubs())
                .field("vencrampubs", &self.vencrampubs())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Pubcfgsr5 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Pubcfgsr5 {{ axisram3pubs: {=bool:?}, axisram4pubs: {=bool:?}, axisram5pubs: {=bool:?}, axisram6pubs: {=bool:?}, ahbsram1pubs: {=bool:?}, ahbsram2pubs: {=bool:?}, bkpsrampubs: {=bool:?}, axisram1pubs: {=bool:?}, axisram2pubs: {=bool:?}, flexrampubs: {=bool:?}, npucacherampubs: {=bool:?}, vencrampubs: {=bool:?} }}" , self . axisram3pubs () , self . axisram4pubs () , self . axisram5pubs () , self . axisram6pubs () , self . ahbsram1pubs () , self . ahbsram2pubs () , self . bkpsrampubs () , self . axisram1pubs () , self . axisram2pubs () , self . flexrampubs () , self . npucacherampubs () , self . vencrampubs ())
        }
    }
    #[doc = "RCC APB5 Sleep enable register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rdcr(pub u32);
    impl Rdcr {
        #[doc = "BOOTROM sleep enable."]
        #[inline(always)]
        pub const fn mrd(&self) -> super::vals::Mrd {
            let val = (self.0 >> 16usize) & 0x1f;
            super::vals::Mrd::from_bits(val as u8)
        }
        #[doc = "BOOTROM sleep enable."]
        #[inline(always)]
        pub fn set_mrd(&mut self, val: super::vals::Mrd) {
            self.0 = (self.0 & !(0x1f << 16usize)) | (((val.to_bits() as u32) & 0x1f) << 16usize);
        }
        #[doc = "BOOTROM sleep enable."]
        #[inline(always)]
        pub const fn eadly(&self) -> super::vals::Eadly {
            let val = (self.0 >> 24usize) & 0x0f;
            super::vals::Eadly::from_bits(val as u8)
        }
        #[doc = "BOOTROM sleep enable."]
        #[inline(always)]
        pub fn set_eadly(&mut self, val: super::vals::Eadly) {
            self.0 = (self.0 & !(0x0f << 24usize)) | (((val.to_bits() as u32) & 0x0f) << 24usize);
        }
    }
    impl Default for Rdcr {
        #[inline(always)]
        fn default() -> Rdcr {
            Rdcr(0)
        }
    }
    impl core::fmt::Debug for Rdcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Rdcr")
                .field("mrd", &self.mrd())
                .field("eadly", &self.eadly())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Rdcr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(f, "Rdcr {{ mrd: {:?}, eadly: {:?} }}", self.mrd(), self.eadly())
        }
    }
    #[doc = "RCC reset register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rsr(pub u32);
    impl Rsr {
        #[doc = "Remove reset flag."]
        #[inline(always)]
        pub const fn rmvf(&self) -> super::vals::RsrRmvf {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::RsrRmvf::from_bits(val as u8)
        }
        #[doc = "Remove reset flag."]
        #[inline(always)]
        pub fn set_rmvf(&mut self, val: super::vals::RsrRmvf) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
        #[doc = "CPU lockup reset flag."]
        #[inline(always)]
        pub const fn lckrstf(&self) -> super::vals::RsrLckrstf {
            let val = (self.0 >> 17usize) & 0x01;
            super::vals::RsrLckrstf::from_bits(val as u8)
        }
        #[doc = "CPU lockup reset flag."]
        #[inline(always)]
        pub fn set_lckrstf(&mut self, val: super::vals::RsrLckrstf) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
        }
        #[doc = "BOR flag."]
        #[inline(always)]
        pub const fn borrstf(&self) -> super::vals::RsrBorrstf {
            let val = (self.0 >> 21usize) & 0x01;
            super::vals::RsrBorrstf::from_bits(val as u8)
        }
        #[doc = "BOR flag."]
        #[inline(always)]
        pub fn set_borrstf(&mut self, val: super::vals::RsrBorrstf) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
        }
        #[doc = "Pin reset flag (NRST)."]
        #[inline(always)]
        pub const fn pinrstf(&self) -> super::vals::RsrPinrstf {
            let val = (self.0 >> 22usize) & 0x01;
            super::vals::RsrPinrstf::from_bits(val as u8)
        }
        #[doc = "Pin reset flag (NRST)."]
        #[inline(always)]
        pub fn set_pinrstf(&mut self, val: super::vals::RsrPinrstf) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
        }
        #[doc = "POR/PDR flag."]
        #[inline(always)]
        pub const fn porrstf(&self) -> super::vals::RsrPorrstf {
            let val = (self.0 >> 23usize) & 0x01;
            super::vals::RsrPorrstf::from_bits(val as u8)
        }
        #[doc = "POR/PDR flag."]
        #[inline(always)]
        pub fn set_porrstf(&mut self, val: super::vals::RsrPorrstf) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
        }
        #[doc = "Software System reset flag (1)."]
        #[inline(always)]
        pub const fn sftrstf(&self) -> super::vals::RsrSftrstf {
            let val = (self.0 >> 24usize) & 0x01;
            super::vals::RsrSftrstf::from_bits(val as u8)
        }
        #[doc = "Software System reset flag (1)."]
        #[inline(always)]
        pub fn set_sftrstf(&mut self, val: super::vals::RsrSftrstf) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
        }
        #[doc = "Independent Watchdog reset flag."]
        #[inline(always)]
        pub const fn iwdgrstf(&self) -> super::vals::RsrIwdgrstf {
            let val = (self.0 >> 26usize) & 0x01;
            super::vals::RsrIwdgrstf::from_bits(val as u8)
        }
        #[doc = "Independent Watchdog reset flag."]
        #[inline(always)]
        pub fn set_iwdgrstf(&mut self, val: super::vals::RsrIwdgrstf) {
            self.0 = (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
        }
        #[doc = "Window Watchdog reset flag."]
        #[inline(always)]
        pub const fn wwdgrstf(&self) -> super::vals::RsrWwdgrstf {
            let val = (self.0 >> 28usize) & 0x01;
            super::vals::RsrWwdgrstf::from_bits(val as u8)
        }
        #[doc = "Window Watchdog reset flag."]
        #[inline(always)]
        pub fn set_wwdgrstf(&mut self, val: super::vals::RsrWwdgrstf) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
        }
        #[doc = "Illegal Stop or Standby flag."]
        #[inline(always)]
        pub const fn lpwrrstf(&self) -> super::vals::RsrLpwrrstf {
            let val = (self.0 >> 30usize) & 0x01;
            super::vals::RsrLpwrrstf::from_bits(val as u8)
        }
        #[doc = "Illegal Stop or Standby flag."]
        #[inline(always)]
        pub fn set_lpwrrstf(&mut self, val: super::vals::RsrLpwrrstf) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
        }
    }
    impl Default for Rsr {
        #[inline(always)]
        fn default() -> Rsr {
            Rsr(0)
        }
    }
    impl core::fmt::Debug for Rsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Rsr")
                .field("rmvf", &self.rmvf())
                .field("lckrstf", &self.lckrstf())
                .field("borrstf", &self.borrstf())
                .field("pinrstf", &self.pinrstf())
                .field("porrstf", &self.porrstf())
                .field("sftrstf", &self.sftrstf())
                .field("iwdgrstf", &self.iwdgrstf())
                .field("wwdgrstf", &self.wwdgrstf())
                .field("lpwrrstf", &self.lpwrrstf())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Rsr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Rsr {{ rmvf: {:?}, lckrstf: {:?}, borrstf: {:?}, pinrstf: {:?}, porrstf: {:?}, sftrstf: {:?}, iwdgrstf: {:?}, wwdgrstf: {:?}, lpwrrstf: {:?} }}" , self . rmvf () , self . lckrstf () , self . borrstf () , self . pinrstf () , self . porrstf () , self . sftrstf () , self . iwdgrstf () , self . wwdgrstf () , self . lpwrrstf ())
        }
    }
    #[doc = "RCC oscillator secure configuration register0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Seccfgr0(pub u32);
    impl Seccfgr0 {
        #[doc = "Defines the secure protection of the LSI oscillator configuration bits."]
        #[inline(always)]
        pub const fn lsisec(&self) -> super::vals::Lsisec {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Lsisec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the LSI oscillator configuration bits."]
        #[inline(always)]
        pub fn set_lsisec(&mut self, val: super::vals::Lsisec) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the secure protection of the LSE oscillator configuration bits."]
        #[inline(always)]
        pub const fn lsesec(&self) -> super::vals::Lsesec {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Lsesec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the LSE oscillator configuration bits."]
        #[inline(always)]
        pub fn set_lsesec(&mut self, val: super::vals::Lsesec) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the secure protection of the MSI oscillator configuration bits."]
        #[inline(always)]
        pub const fn msisec(&self) -> super::vals::Msisec {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Msisec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the MSI oscillator configuration bits."]
        #[inline(always)]
        pub fn set_msisec(&mut self, val: super::vals::Msisec) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the secure protection of the HSI oscillator configuration bits."]
        #[inline(always)]
        pub const fn hsisec(&self) -> super::vals::Hsisec {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Hsisec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the HSI oscillator configuration bits."]
        #[inline(always)]
        pub fn set_hsisec(&mut self, val: super::vals::Hsisec) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the secure protection of the HSE oscillator configuration bits."]
        #[inline(always)]
        pub const fn hsesec(&self) -> super::vals::Hsesec {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Hsesec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the HSE oscillator configuration bits."]
        #[inline(always)]
        pub fn set_hsesec(&mut self, val: super::vals::Hsesec) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Seccfgr0 {
        #[inline(always)]
        fn default() -> Seccfgr0 {
            Seccfgr0(0)
        }
    }
    impl core::fmt::Debug for Seccfgr0 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Seccfgr0")
                .field("lsisec", &self.lsisec())
                .field("lsesec", &self.lsesec())
                .field("msisec", &self.msisec())
                .field("hsisec", &self.hsisec())
                .field("hsesec", &self.hsesec())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Seccfgr0 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Seccfgr0 {{ lsisec: {:?}, lsesec: {:?}, msisec: {:?}, hsisec: {:?}, hsesec: {:?} }}",
                self.lsisec(),
                self.lsesec(),
                self.msisec(),
                self.hsisec(),
                self.hsesec()
            )
        }
    }
    #[doc = "RCC PLL secure configuration register1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Seccfgr1(pub u32);
    impl Seccfgr1 {
        #[doc = "Defines the secure protection of the PLL1 PLL configuration bits."]
        #[inline(always)]
        pub const fn pllsec(&self, n: usize) -> super::vals::Pllsec {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the PLL1 PLL configuration bits."]
        #[inline(always)]
        pub fn set_pllsec(&mut self, n: usize, val: super::vals::Pllsec) {
            assert!(n < 4usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
    }
    impl Default for Seccfgr1 {
        #[inline(always)]
        fn default() -> Seccfgr1 {
            Seccfgr1(0)
        }
    }
    impl core::fmt::Debug for Seccfgr1 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Seccfgr1")
                .field("pllsec[0]", &self.pllsec(0usize))
                .field("pllsec[1]", &self.pllsec(1usize))
                .field("pllsec[2]", &self.pllsec(2usize))
                .field("pllsec[3]", &self.pllsec(3usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Seccfgr1 {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Seccfgr1 {{ pllsec[0]: {:?}, pllsec[1]: {:?}, pllsec[2]: {:?}, pllsec[3]: {:?} }}",
                self.pllsec(0usize),
                self.pllsec(1usize),
                self.pllsec(2usize),
                self.pllsec(3usize)
            )
        }
    }
    #[doc = "RCC divider secure configuration register2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Seccfgr2(pub u32);
    impl Seccfgr2 {
        #[doc = "Defines the secure protection of the IC1 divider configuration bits."]
        #[inline(always)]
        pub const fn ic1sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC1 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic1sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the secure protection of the IC2 divider configuration bits."]
        #[inline(always)]
        pub const fn ic2sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC2 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic2sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the secure protection of the IC3 divider configuration bits."]
        #[inline(always)]
        pub const fn ic3sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC3 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic3sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the secure protection of the IC4 divider configuration bits."]
        #[inline(always)]
        pub const fn ic4sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC4 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic4sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the secure protection of the IC5 divider configuration bits."]
        #[inline(always)]
        pub const fn ic5sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC5 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic5sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the secure protection of the IC6 divider configuration bits."]
        #[inline(always)]
        pub const fn ic6sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 5usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC6 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic6sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the secure protection of the IC7 divider configuration bits."]
        #[inline(always)]
        pub const fn ic7sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC7 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic7sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the secure protection of the IC8 divider configuration bits."]
        #[inline(always)]
        pub const fn ic8sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 7usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC8 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic8sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the secure protection of the IC9 divider configuration bits."]
        #[inline(always)]
        pub const fn ic9sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC9 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic9sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the secure protection of the IC10 divider configuration bits."]
        #[inline(always)]
        pub const fn ic10sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC10 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic10sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the secure protection of the IC11 divider configuration bits."]
        #[inline(always)]
        pub const fn ic11sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 10usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC11 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic11sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the secure protection of the IC12 divider configuration bits."]
        #[inline(always)]
        pub const fn ic12sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 11usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC12 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic12sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the secure protection of the IC13 divider configuration bits."]
        #[inline(always)]
        pub const fn ic13sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 12usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC13 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic13sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the secure protection of the IC14 divider configuration bits."]
        #[inline(always)]
        pub const fn ic14sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 13usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC14 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic14sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
        }
        #[doc = "Defines the secure protection of the IC15 divider configuration bits."]
        #[inline(always)]
        pub const fn ic15sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 14usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC15 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic15sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
        }
        #[doc = "Defines the secure protection of the IC16 divider configuration bits."]
        #[inline(always)]
        pub const fn ic16sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 15usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC16 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic16sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
        }
        #[doc = "Defines the secure protection of the IC17 divider configuration bits."]
        #[inline(always)]
        pub const fn ic17sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC17 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic17sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
        #[doc = "Defines the secure protection of the IC18 divider configuration bits."]
        #[inline(always)]
        pub const fn ic18sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 17usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC18 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic18sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
        }
        #[doc = "Defines the secure protection of the IC19 divider configuration bits."]
        #[inline(always)]
        pub const fn ic19sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 18usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC19 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic19sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
        }
        #[doc = "Defines the secure protection of the IC20 divider configuration bits."]
        #[inline(always)]
        pub const fn ic20sec(&self) -> super::vals::Icsec {
            let val = (self.0 >> 19usize) & 0x01;
            super::vals::Icsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the IC20 divider configuration bits."]
        #[inline(always)]
        pub fn set_ic20sec(&mut self, val: super::vals::Icsec) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Seccfgr2 {
        #[inline(always)]
        fn default() -> Seccfgr2 {
            Seccfgr2(0)
        }
    }
    impl core::fmt::Debug for Seccfgr2 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Seccfgr2")
                .field("ic1sec", &self.ic1sec())
                .field("ic2sec", &self.ic2sec())
                .field("ic3sec", &self.ic3sec())
                .field("ic4sec", &self.ic4sec())
                .field("ic5sec", &self.ic5sec())
                .field("ic6sec", &self.ic6sec())
                .field("ic7sec", &self.ic7sec())
                .field("ic8sec", &self.ic8sec())
                .field("ic9sec", &self.ic9sec())
                .field("ic10sec", &self.ic10sec())
                .field("ic11sec", &self.ic11sec())
                .field("ic12sec", &self.ic12sec())
                .field("ic13sec", &self.ic13sec())
                .field("ic14sec", &self.ic14sec())
                .field("ic15sec", &self.ic15sec())
                .field("ic16sec", &self.ic16sec())
                .field("ic17sec", &self.ic17sec())
                .field("ic18sec", &self.ic18sec())
                .field("ic19sec", &self.ic19sec())
                .field("ic20sec", &self.ic20sec())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Seccfgr2 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Seccfgr2 {{ ic1sec: {:?}, ic2sec: {:?}, ic3sec: {:?}, ic4sec: {:?}, ic5sec: {:?}, ic6sec: {:?}, ic7sec: {:?}, ic8sec: {:?}, ic9sec: {:?}, ic10sec: {:?}, ic11sec: {:?}, ic12sec: {:?}, ic13sec: {:?}, ic14sec: {:?}, ic15sec: {:?}, ic16sec: {:?}, ic17sec: {:?}, ic18sec: {:?}, ic19sec: {:?}, ic20sec: {:?} }}" , self . ic1sec () , self . ic2sec () , self . ic3sec () , self . ic4sec () , self . ic5sec () , self . ic6sec () , self . ic7sec () , self . ic8sec () , self . ic9sec () , self . ic10sec () , self . ic11sec () , self . ic12sec () , self . ic13sec () , self . ic14sec () , self . ic15sec () , self . ic16sec () , self . ic17sec () , self . ic18sec () , self . ic19sec () , self . ic20sec ())
        }
    }
    #[doc = "RCC system secure configuration register3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Seccfgr3(pub u32);
    impl Seccfgr3 {
        #[doc = "Defines the secure protection of the MOD system configuration bits."]
        #[inline(always)]
        pub const fn modsec(&self) -> super::vals::Modsec {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Modsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the MOD system configuration bits."]
        #[inline(always)]
        pub fn set_modsec(&mut self, val: super::vals::Modsec) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the secure protection of the SYS system configuration bits."]
        #[inline(always)]
        pub const fn syssec(&self) -> super::vals::Syssec {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Syssec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the SYS system configuration bits."]
        #[inline(always)]
        pub fn set_syssec(&mut self, val: super::vals::Syssec) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the secure protection of the BUS system configuration bits."]
        #[inline(always)]
        pub const fn bussec(&self) -> super::vals::Bussec {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Bussec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the BUS system configuration bits."]
        #[inline(always)]
        pub fn set_bussec(&mut self, val: super::vals::Bussec) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the secure protection of the PER system configuration bits."]
        #[inline(always)]
        pub const fn persec(&self) -> super::vals::Persec {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Persec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the PER system configuration bits."]
        #[inline(always)]
        pub fn set_persec(&mut self, val: super::vals::Persec) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the secure protection of the INT system configuration bits."]
        #[inline(always)]
        pub const fn intsec(&self) -> super::vals::Intsec {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Intsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the INT system configuration bits."]
        #[inline(always)]
        pub fn set_intsec(&mut self, val: super::vals::Intsec) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the secure protection of the RST system configuration bits."]
        #[inline(always)]
        pub const fn rstsec(&self) -> super::vals::Rstsec {
            let val = (self.0 >> 5usize) & 0x01;
            super::vals::Rstsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the RST system configuration bits."]
        #[inline(always)]
        pub fn set_rstsec(&mut self, val: super::vals::Rstsec) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the secure protection of the DFT system configuration bits."]
        #[inline(always)]
        pub const fn dftsec(&self) -> super::vals::Dftsec {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Dftsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the DFT system configuration bits."]
        #[inline(always)]
        pub fn set_dftsec(&mut self, val: super::vals::Dftsec) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Seccfgr3 {
        #[inline(always)]
        fn default() -> Seccfgr3 {
            Seccfgr3(0)
        }
    }
    impl core::fmt::Debug for Seccfgr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Seccfgr3")
                .field("modsec", &self.modsec())
                .field("syssec", &self.syssec())
                .field("bussec", &self.bussec())
                .field("persec", &self.persec())
                .field("intsec", &self.intsec())
                .field("rstsec", &self.rstsec())
                .field("dftsec", &self.dftsec())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Seccfgr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Seccfgr3 {{ modsec: {:?}, syssec: {:?}, bussec: {:?}, persec: {:?}, intsec: {:?}, rstsec: {:?}, dftsec: {:?} }}" , self . modsec () , self . syssec () , self . bussec () , self . persec () , self . intsec () , self . rstsec () , self . dftsec ())
        }
    }
    #[doc = "RCC bus secure configuration register4."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Seccfgr4(pub u32);
    impl Seccfgr4 {
        #[doc = "Defines the secure protection of the ACLKN bus configuration bits."]
        #[inline(always)]
        pub const fn aclknsec(&self) -> super::vals::Aclknsec {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Aclknsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the ACLKN bus configuration bits."]
        #[inline(always)]
        pub fn set_aclknsec(&mut self, val: super::vals::Aclknsec) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the secure protection of the ACLKNC bus configuration bits."]
        #[inline(always)]
        pub const fn aclkncsec(&self) -> super::vals::Aclkncsec {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Aclkncsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the ACLKNC bus configuration bits."]
        #[inline(always)]
        pub fn set_aclkncsec(&mut self, val: super::vals::Aclkncsec) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the secure protection of the AHBM bus configuration bits."]
        #[inline(always)]
        pub const fn ahbmsec(&self) -> super::vals::Ahbmsec {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Ahbmsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the AHBM bus configuration bits."]
        #[inline(always)]
        pub fn set_ahbmsec(&mut self, val: super::vals::Ahbmsec) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the secure protection of the AHB1 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb1sec(&self) -> super::vals::Ahbsec {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Ahbsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the AHB1 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb1sec(&mut self, val: super::vals::Ahbsec) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the secure protection of the AHB2 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb2sec(&self) -> super::vals::Ahbsec {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Ahbsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the AHB2 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb2sec(&mut self, val: super::vals::Ahbsec) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the secure protection of the AHB3 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb3sec(&self) -> super::vals::Ahbsec {
            let val = (self.0 >> 5usize) & 0x01;
            super::vals::Ahbsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the AHB3 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb3sec(&mut self, val: super::vals::Ahbsec) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the secure protection of the AHB4 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb4sec(&self) -> super::vals::Ahbsec {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Ahbsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the AHB4 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb4sec(&mut self, val: super::vals::Ahbsec) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
        #[doc = "Defines the secure protection of the AHB5 bus configuration bits."]
        #[inline(always)]
        pub const fn ahb5sec(&self) -> super::vals::Ahbsec {
            let val = (self.0 >> 7usize) & 0x01;
            super::vals::Ahbsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the AHB5 bus configuration bits."]
        #[inline(always)]
        pub fn set_ahb5sec(&mut self, val: super::vals::Ahbsec) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the secure protection of the APB1 bus configuration bits."]
        #[inline(always)]
        pub const fn apb1sec(&self) -> super::vals::Apbsec {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Apbsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the APB1 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb1sec(&mut self, val: super::vals::Apbsec) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
        #[doc = "Defines the secure protection of the APB2 bus configuration bits."]
        #[inline(always)]
        pub const fn apb2sec(&self) -> super::vals::Apbsec {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Apbsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the APB2 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb2sec(&mut self, val: super::vals::Apbsec) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
        #[doc = "Defines the secure protection of the APB3 bus configuration bits."]
        #[inline(always)]
        pub const fn apb3sec(&self) -> super::vals::Apbsec {
            let val = (self.0 >> 10usize) & 0x01;
            super::vals::Apbsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the APB3 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb3sec(&mut self, val: super::vals::Apbsec) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
        }
        #[doc = "Defines the secure protection of the APB4 bus configuration bits."]
        #[inline(always)]
        pub const fn apb4sec(&self) -> super::vals::Apbsec {
            let val = (self.0 >> 11usize) & 0x01;
            super::vals::Apbsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the APB4 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb4sec(&mut self, val: super::vals::Apbsec) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
        }
        #[doc = "Defines the secure protection of the APB5 bus configuration bits."]
        #[inline(always)]
        pub const fn apb5sec(&self) -> super::vals::Apbsec {
            let val = (self.0 >> 12usize) & 0x01;
            super::vals::Apbsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the APB5 bus configuration bits."]
        #[inline(always)]
        pub fn set_apb5sec(&mut self, val: super::vals::Apbsec) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
        }
        #[doc = "Defines the secure protection of the NOC bus configuration bits."]
        #[inline(always)]
        pub const fn nocsec(&self) -> super::vals::Nocsec {
            let val = (self.0 >> 13usize) & 0x01;
            super::vals::Nocsec::from_bits(val as u8)
        }
        #[doc = "Defines the secure protection of the NOC bus configuration bits."]
        #[inline(always)]
        pub fn set_nocsec(&mut self, val: super::vals::Nocsec) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
        }
    }
    impl Default for Seccfgr4 {
        #[inline(always)]
        fn default() -> Seccfgr4 {
            Seccfgr4(0)
        }
    }
    impl core::fmt::Debug for Seccfgr4 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Seccfgr4")
                .field("aclknsec", &self.aclknsec())
                .field("aclkncsec", &self.aclkncsec())
                .field("ahbmsec", &self.ahbmsec())
                .field("ahb1sec", &self.ahb1sec())
                .field("ahb2sec", &self.ahb2sec())
                .field("ahb3sec", &self.ahb3sec())
                .field("ahb4sec", &self.ahb4sec())
                .field("ahb5sec", &self.ahb5sec())
                .field("apb1sec", &self.apb1sec())
                .field("apb2sec", &self.apb2sec())
                .field("apb3sec", &self.apb3sec())
                .field("apb4sec", &self.apb4sec())
                .field("apb5sec", &self.apb5sec())
                .field("nocsec", &self.nocsec())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Seccfgr4 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Seccfgr4 {{ aclknsec: {:?}, aclkncsec: {:?}, ahbmsec: {:?}, ahb1sec: {:?}, ahb2sec: {:?}, ahb3sec: {:?}, ahb4sec: {:?}, ahb5sec: {:?}, apb1sec: {:?}, apb2sec: {:?}, apb3sec: {:?}, apb4sec: {:?}, apb5sec: {:?}, nocsec: {:?} }}" , self . aclknsec () , self . aclkncsec () , self . ahbmsec () , self . ahb1sec () , self . ahb2sec () , self . ahb3sec () , self . ahb4sec () , self . ahb5sec () , self . apb1sec () , self . apb2sec () , self . apb3sec () , self . apb4sec () , self . apb5sec () , self . nocsec ())
        }
    }
    #[doc = "RCC system secure configuration register3."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Seccfgsr3(pub u32);
    impl Seccfgsr3 {
        #[doc = "Defines the secure protection of the MOD configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn modsecs(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the secure protection of the MOD configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_modsecs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Defines the secure protection of the SYS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn syssecs(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the secure protection of the SYS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_syssecs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Defines the secure protection of the BUS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn bussecs(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the secure protection of the BUS configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_bussecs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Defines the secure protection of the PER configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn persecs(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the secure protection of the PER configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_persecs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Defines the secure protection of the INT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn intsecs(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the secure protection of the INT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_intsecs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Defines the secure protection of the RST configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn rstsecs(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the secure protection of the RST configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_rstsecs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Defines the secure protection of the DFT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub const fn dftsecs(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Defines the secure protection of the DFT configuration bits (enable, ready, divider)."]
        #[inline(always)]
        pub fn set_dftsecs(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Seccfgsr3 {
        #[inline(always)]
        fn default() -> Seccfgsr3 {
            Seccfgsr3(0)
        }
    }
    impl core::fmt::Debug for Seccfgsr3 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Seccfgsr3")
                .field("modsecs", &self.modsecs())
                .field("syssecs", &self.syssecs())
                .field("bussecs", &self.bussecs())
                .field("persecs", &self.persecs())
                .field("intsecs", &self.intsecs())
                .field("rstsecs", &self.rstsecs())
                .field("dftsecs", &self.dftsecs())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Seccfgsr3 {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Seccfgsr3 {{ modsecs: {=bool:?}, syssecs: {=bool:?}, bussecs: {=bool:?}, persecs: {=bool:?}, intsecs: {=bool:?}, rstsecs: {=bool:?}, dftsecs: {=bool:?} }}" , self . modsecs () , self . syssecs () , self . bussecs () , self . persecs () , self . intsecs () , self . rstsecs () , self . dftsecs ())
        }
    }
    #[doc = "RCC status register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sr(pub u32);
    impl Sr {
        #[doc = "LSI clock ready flag."]
        #[inline(always)]
        pub const fn lsirdy(&self) -> super::vals::Lsirdy {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Lsirdy::from_bits(val as u8)
        }
        #[doc = "LSI clock ready flag."]
        #[inline(always)]
        pub fn set_lsirdy(&mut self, val: super::vals::Lsirdy) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "LSE clock ready flag."]
        #[inline(always)]
        pub const fn lserdy(&self) -> super::vals::Lserdy {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Lserdy::from_bits(val as u8)
        }
        #[doc = "LSE clock ready flag."]
        #[inline(always)]
        pub fn set_lserdy(&mut self, val: super::vals::Lserdy) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "MSI clock ready flag."]
        #[inline(always)]
        pub const fn msirdy(&self) -> super::vals::Msirdy {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Msirdy::from_bits(val as u8)
        }
        #[doc = "MSI clock ready flag."]
        #[inline(always)]
        pub fn set_msirdy(&mut self, val: super::vals::Msirdy) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "HSI clock ready flag."]
        #[inline(always)]
        pub const fn hsirdy(&self) -> super::vals::Hsirdy {
            let val = (self.0 >> 3usize) & 0x01;
            super::vals::Hsirdy::from_bits(val as u8)
        }
        #[doc = "HSI clock ready flag."]
        #[inline(always)]
        pub fn set_hsirdy(&mut self, val: super::vals::Hsirdy) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
        }
        #[doc = "HSE clock ready flag."]
        #[inline(always)]
        pub const fn hserdy(&self) -> super::vals::Hserdy {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Hserdy::from_bits(val as u8)
        }
        #[doc = "HSE clock ready flag."]
        #[inline(always)]
        pub fn set_hserdy(&mut self, val: super::vals::Hserdy) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "PLL1 clock ready flag."]
        #[inline(always)]
        pub const fn pllrdy(&self, n: usize) -> super::vals::Pllrdy {
            assert!(n < 4usize);
            let offs = 8usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            super::vals::Pllrdy::from_bits(val as u8)
        }
        #[doc = "PLL1 clock ready flag."]
        #[inline(always)]
        pub fn set_pllrdy(&mut self, n: usize, val: super::vals::Pllrdy) {
            assert!(n < 4usize);
            let offs = 8usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
        }
    }
    impl Default for Sr {
        #[inline(always)]
        fn default() -> Sr {
            Sr(0)
        }
    }
    impl core::fmt::Debug for Sr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Sr")
                .field("lsirdy", &self.lsirdy())
                .field("lserdy", &self.lserdy())
                .field("msirdy", &self.msirdy())
                .field("hsirdy", &self.hsirdy())
                .field("hserdy", &self.hserdy())
                .field("pllrdy[0]", &self.pllrdy(0usize))
                .field("pllrdy[1]", &self.pllrdy(1usize))
                .field("pllrdy[2]", &self.pllrdy(2usize))
                .field("pllrdy[3]", &self.pllrdy(3usize))
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Sr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Sr {{ lsirdy: {:?}, lserdy: {:?}, msirdy: {:?}, hsirdy: {:?}, hserdy: {:?}, pllrdy[0]: {:?}, pllrdy[1]: {:?}, pllrdy[2]: {:?}, pllrdy[3]: {:?} }}" , self . lsirdy () , self . lserdy () , self . msirdy () , self . hsirdy () , self . hserdy () , self . pllrdy (0usize) , self . pllrdy (1usize) , self . pllrdy (2usize) , self . pllrdy (3usize))
        }
    }
    #[doc = "RCC StopCCR configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Stopccr(pub u32);
    impl Stopccr {
        #[doc = "LSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn lsistopenc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "LSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_lsistopenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "LSE oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn lsestopenc(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "LSE oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_lsestopenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "MSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn msistopenc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "MSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_msistopenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "HSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub const fn hsistopenc(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "HSI oscillator enable in Run/Sleep mode."]
        #[inline(always)]
        pub fn set_hsistopenc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
    }
    impl Default for Stopccr {
        #[inline(always)]
        fn default() -> Stopccr {
            Stopccr(0)
        }
    }
    impl core::fmt::Debug for Stopccr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Stopccr")
                .field("lsistopenc", &self.lsistopenc())
                .field("lsestopenc", &self.lsestopenc())
                .field("msistopenc", &self.msistopenc())
                .field("hsistopenc", &self.hsistopenc())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Stopccr {
        fn format(&self, f: defmt::Formatter) {
            defmt :: write ! (f , "Stopccr {{ lsistopenc: {=bool:?}, lsestopenc: {=bool:?}, msistopenc: {=bool:?}, hsistopenc: {=bool:?} }}" , self . lsistopenc () , self . lsestopenc () , self . msistopenc () , self . hsistopenc ())
        }
    }
    #[doc = "RCC Stop mode control register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Stopcr(pub u32);
    impl Stopcr {
        #[doc = "LSI oscillator enable in Stop mode."]
        #[inline(always)]
        pub const fn lsistopen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "LSI oscillator enable in Stop mode."]
        #[inline(always)]
        pub fn set_lsistopen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "LSE oscillator enable in Stop mode."]
        #[inline(always)]
        pub const fn lsestopen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "LSE oscillator enable in Stop mode."]
        #[inline(always)]
        pub fn set_lsestopen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "MSI oscillator enable in Stop mode."]
        #[inline(always)]
        pub const fn msistopen(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "MSI oscillator enable in Stop mode."]
        #[inline(always)]
        pub fn set_msistopen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "HSI oscillator enable in Stop mode."]
        #[inline(always)]
        pub const fn hsistopen(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "HSI oscillator enable in Stop mode."]
        #[inline(always)]
        pub fn set_hsistopen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
    }
    impl Default for Stopcr {
        #[inline(always)]
        fn default() -> Stopcr {
            Stopcr(0)
        }
    }
    impl core::fmt::Debug for Stopcr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Stopcr")
                .field("lsistopen", &self.lsistopen())
                .field("lsestopen", &self.lsestopen())
                .field("msistopen", &self.msistopen())
                .field("hsistopen", &self.hsistopen())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Stopcr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Stopcr {{ lsistopen: {=bool:?}, lsestopen: {=bool:?}, msistopen: {=bool:?}, hsistopen: {=bool:?} }}",
                self.lsistopen(),
                self.lsestopen(),
                self.msistopen(),
                self.hsistopen()
            )
        }
    }
    #[doc = "RCC Stop configuration register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Stopcsr(pub u32);
    impl Stopcsr {
        #[doc = "MSISTOPENS."]
        #[inline(always)]
        pub const fn msistopens(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "MSISTOPENS."]
        #[inline(always)]
        pub fn set_msistopens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "HSISTOPENS."]
        #[inline(always)]
        pub const fn hsistopens(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "HSISTOPENS."]
        #[inline(always)]
        pub fn set_hsistopens(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
    }
    impl Default for Stopcsr {
        #[inline(always)]
        fn default() -> Stopcsr {
            Stopcsr(0)
        }
    }
    impl core::fmt::Debug for Stopcsr {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Stopcsr")
                .field("msistopens", &self.msistopens())
                .field("hsistopens", &self.hsistopens())
                .finish()
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Stopcsr {
        fn format(&self, f: defmt::Formatter) {
            defmt::write!(
                f,
                "Stopcsr {{ msistopens: {=bool:?}, hsistopens: {=bool:?} }}",
                self.msistopens(),
                self.hsistopens()
            )
        }
    }
}
pub mod vals {
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Aclknclock {
        #[doc = "ACLKNC configuration bits are accessible by non-lock software only (default after reset)."]
        B_0X0 = 0x0,
        #[doc = "ACLKNC configuration bits are accessible by lock software only."]
        B_0X1 = 0x01,
    }
    impl Aclknclock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Aclknclock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Aclknclock {
        #[inline(always)]
        fn from(val: u8) -> Aclknclock {
            Aclknclock::from_bits(val)
        }
    }
    impl From<Aclknclock> for u8 {
        #[inline(always)]
        fn from(val: Aclknclock) -> u8 {
            Aclknclock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Aclkncpub {
        #[doc = "ACLKNC configuration bits are accessible by non-public software only (default after reset)."]
        B_0X0 = 0x0,
        #[doc = "ACLKNC configuration bits are accessible by public software only."]
        B_0X1 = 0x01,
    }
    impl Aclkncpub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Aclkncpub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Aclkncpub {
        #[inline(always)]
        fn from(val: u8) -> Aclkncpub {
            Aclkncpub::from_bits(val)
        }
    }
    impl From<Aclkncpub> for u8 {
        #[inline(always)]
        fn from(val: Aclkncpub) -> u8 {
            Aclkncpub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Aclkncpv {
        #[doc = "ACLKNC configuration bits are accessible by non-privilege software only (default after reset)."]
        B_0X0 = 0x0,
        #[doc = "ACLKNC configuration bits are accessible by privilege software only."]
        B_0X1 = 0x01,
    }
    impl Aclkncpv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Aclkncpv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Aclkncpv {
        #[inline(always)]
        fn from(val: u8) -> Aclkncpv {
            Aclkncpv::from_bits(val)
        }
    }
    impl From<Aclkncpv> for u8 {
        #[inline(always)]
        fn from(val: Aclkncpv) -> u8 {
            Aclkncpv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Aclkncsec {
        #[doc = "ACLKNC configuration bits are accessible by non-secure software only (default after reset)."]
        B_0X0 = 0x0,
        #[doc = "ACLKNC configuration bits are accessible by secure software only."]
        B_0X1 = 0x01,
    }
    impl Aclkncsec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Aclkncsec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Aclkncsec {
        #[inline(always)]
        fn from(val: u8) -> Aclkncsec {
            Aclkncsec::from_bits(val)
        }
    }
    impl From<Aclkncsec> for u8 {
        #[inline(always)]
        fn from(val: Aclkncsec) -> u8 {
            Aclkncsec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Aclknlock {
        #[doc = "ACLKN configuration bits are accessible by non-lock software only (default after reset)."]
        B_0X0 = 0x0,
        #[doc = "ACLKN configuration bits are accessible by lock software only."]
        B_0X1 = 0x01,
    }
    impl Aclknlock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Aclknlock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Aclknlock {
        #[inline(always)]
        fn from(val: u8) -> Aclknlock {
            Aclknlock::from_bits(val)
        }
    }
    impl From<Aclknlock> for u8 {
        #[inline(always)]
        fn from(val: Aclknlock) -> u8 {
            Aclknlock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Aclknpub {
        #[doc = "ACLKN configuration bits are accessible by non-public software only (default after reset)."]
        B_0X0 = 0x0,
        #[doc = "ACLKN configuration bits are accessible by public software only."]
        B_0X1 = 0x01,
    }
    impl Aclknpub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Aclknpub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Aclknpub {
        #[inline(always)]
        fn from(val: u8) -> Aclknpub {
            Aclknpub::from_bits(val)
        }
    }
    impl From<Aclknpub> for u8 {
        #[inline(always)]
        fn from(val: Aclknpub) -> u8 {
            Aclknpub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Aclknpv {
        #[doc = "ACLKN configuration bits are accessible by non-privilege software only (default after reset)."]
        B_0X0 = 0x0,
        #[doc = "ACLKN configuration bits are accessible by privilege software only."]
        B_0X1 = 0x01,
    }
    impl Aclknpv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Aclknpv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Aclknpv {
        #[inline(always)]
        fn from(val: u8) -> Aclknpv {
            Aclknpv::from_bits(val)
        }
    }
    impl From<Aclknpv> for u8 {
        #[inline(always)]
        fn from(val: Aclknpv) -> u8 {
            Aclknpv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Aclknsec {
        #[doc = "ACLKN configuration bits are accessible by non-secure software only (default after reset)."]
        B_0X0 = 0x0,
        #[doc = "ACLKN configuration bits are accessible by secure software only."]
        B_0X1 = 0x01,
    }
    impl Aclknsec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Aclknsec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Aclknsec {
        #[inline(always)]
        fn from(val: u8) -> Aclknsec {
            Aclknsec::from_bits(val)
        }
    }
    impl From<Aclknsec> for u8 {
        #[inline(always)]
        fn from(val: Aclknsec) -> u8 {
            Aclknsec::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Adcpre(u8);
    impl Adcpre {
        #[doc = "ck_icn_p_adf1 is divided by 1."]
        pub const B_0X0: Self = Self(0x0);
        #[doc = "ck_icn_p_adf1 is divided by 2."]
        pub const B_0X1: Self = Self(0x01);
        #[doc = "ck_icn_p_adf1 is divided by 3."]
        pub const B_0X2: Self = Self(0x02);
        #[doc = "ck_icn_p_adf1 is divided by 4."]
        pub const B_0X3: Self = Self(0x03);
    }
    impl Adcpre {
        pub const fn from_bits(val: u8) -> Adcpre {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Adcpre {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("B_0X0"),
                0x01 => f.write_str("B_0X1"),
                0x02 => f.write_str("B_0X2"),
                0x03 => f.write_str("B_0X3"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Adcpre {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "B_0X0"),
                0x01 => defmt::write!(f, "B_0X1"),
                0x02 => defmt::write!(f, "B_0X2"),
                0x03 => defmt::write!(f, "B_0X3"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Adcpre {
        #[inline(always)]
        fn from(val: u8) -> Adcpre {
            Adcpre::from_bits(val)
        }
    }
    impl From<Adcpre> for u8 {
        #[inline(always)]
        fn from(val: Adcpre) -> u8 {
            Adcpre::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Adcsel {
        #[doc = "hclk1 selected as reference clock."]
        HCLK1 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic7_ck selected as reference clock."]
        IC7 = 0x02,
        #[doc = "ic8_ck selected as reference clock."]
        IC8 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        #[doc = "I2S_CKIN selected as reference clock."]
        I2S_CKIN = 0x06,
        #[doc = "timg_ck selected as reference clock."]
        TIMG = 0x07,
    }
    impl Adcsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Adcsel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Adcsel {
        #[inline(always)]
        fn from(val: u8) -> Adcsel {
            Adcsel::from_bits(val)
        }
    }
    impl From<Adcsel> for u8 {
        #[inline(always)]
        fn from(val: Adcsel) -> u8 {
            Adcsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Adfsel {
        #[doc = "hclk2 selected as reference clock."]
        HCLK2 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic7_ck selected as reference clock."]
        IC7 = 0x02,
        #[doc = "ic8_ck selected as reference clock."]
        IC8 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        #[doc = "I2S_CKIN selected as reference clock."]
        I2S_CKIN = 0x06,
        #[doc = "timg_ck selected as reference clock."]
        TIMG = 0x07,
    }
    impl Adfsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Adfsel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Adfsel {
        #[inline(always)]
        fn from(val: u8) -> Adfsel {
            Adfsel::from_bits(val)
        }
    }
    impl From<Adfsel> for u8 {
        #[inline(always)]
        fn from(val: Adfsel) -> u8 {
            Adfsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ahblock {
        #[doc = "AHB1 configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "AHB1 configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Ahblock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ahblock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ahblock {
        #[inline(always)]
        fn from(val: u8) -> Ahblock {
            Ahblock::from_bits(val)
        }
    }
    impl From<Ahblock> for u8 {
        #[inline(always)]
        fn from(val: Ahblock) -> u8 {
            Ahblock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ahbmlock {
        #[doc = "AHBM configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "AHBM configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Ahbmlock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ahbmlock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ahbmlock {
        #[inline(always)]
        fn from(val: u8) -> Ahbmlock {
            Ahbmlock::from_bits(val)
        }
    }
    impl From<Ahbmlock> for u8 {
        #[inline(always)]
        fn from(val: Ahbmlock) -> u8 {
            Ahbmlock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ahbmpub {
        #[doc = "AHBM configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "AHBM configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Ahbmpub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ahbmpub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ahbmpub {
        #[inline(always)]
        fn from(val: u8) -> Ahbmpub {
            Ahbmpub::from_bits(val)
        }
    }
    impl From<Ahbmpub> for u8 {
        #[inline(always)]
        fn from(val: Ahbmpub) -> u8 {
            Ahbmpub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ahbmpv {
        #[doc = "AHBM configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIV = 0x0,
        #[doc = "AHBM configuration bits are accessible by privilege software only."]
        PRIV = 0x01,
    }
    impl Ahbmpv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ahbmpv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ahbmpv {
        #[inline(always)]
        fn from(val: u8) -> Ahbmpv {
            Ahbmpv::from_bits(val)
        }
    }
    impl From<Ahbmpv> for u8 {
        #[inline(always)]
        fn from(val: Ahbmpv) -> u8 {
            Ahbmpv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ahbmsec {
        #[doc = "AHBM configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "AHBM configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Ahbmsec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ahbmsec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ahbmsec {
        #[inline(always)]
        fn from(val: u8) -> Ahbmsec {
            Ahbmsec::from_bits(val)
        }
    }
    impl From<Ahbmsec> for u8 {
        #[inline(always)]
        fn from(val: Ahbmsec) -> u8 {
            Ahbmsec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ahbpub {
        #[doc = "AHB1 configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "AHB1 configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Ahbpub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ahbpub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ahbpub {
        #[inline(always)]
        fn from(val: u8) -> Ahbpub {
            Ahbpub::from_bits(val)
        }
    }
    impl From<Ahbpub> for u8 {
        #[inline(always)]
        fn from(val: Ahbpub) -> u8 {
            Ahbpub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ahbpv {
        #[doc = "AHB1 configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIV = 0x0,
        #[doc = "AHB1 configuration bits are accessible by privilege software only."]
        PRIV = 0x01,
    }
    impl Ahbpv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ahbpv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ahbpv {
        #[inline(always)]
        fn from(val: u8) -> Ahbpv {
            Ahbpv::from_bits(val)
        }
    }
    impl From<Ahbpv> for u8 {
        #[inline(always)]
        fn from(val: Ahbpv) -> u8 {
            Ahbpv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ahbsec {
        #[doc = "AHB1 configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "AHB1 configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Ahbsec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ahbsec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ahbsec {
        #[inline(always)]
        fn from(val: u8) -> Ahbsec {
            Ahbsec::from_bits(val)
        }
    }
    impl From<Ahbsec> for u8 {
        #[inline(always)]
        fn from(val: Ahbsec) -> u8 {
            Ahbsec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ahbsrampub {
        #[doc = "AHBSRAM1 configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "AHBSRAM1 configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Ahbsrampub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ahbsrampub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ahbsrampub {
        #[inline(always)]
        fn from(val: u8) -> Ahbsrampub {
            Ahbsrampub::from_bits(val)
        }
    }
    impl From<Ahbsrampub> for u8 {
        #[inline(always)]
        fn from(val: Ahbsrampub) -> u8 {
            Ahbsrampub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Apblock {
        #[doc = "APB1 configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "APB1 configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Apblock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Apblock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Apblock {
        #[inline(always)]
        fn from(val: u8) -> Apblock {
            Apblock::from_bits(val)
        }
    }
    impl From<Apblock> for u8 {
        #[inline(always)]
        fn from(val: Apblock) -> u8 {
            Apblock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Apbpub {
        #[doc = "APB1 configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "APB1 configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Apbpub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Apbpub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Apbpub {
        #[inline(always)]
        fn from(val: u8) -> Apbpub {
            Apbpub::from_bits(val)
        }
    }
    impl From<Apbpub> for u8 {
        #[inline(always)]
        fn from(val: Apbpub) -> u8 {
            Apbpub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Apbpv {
        #[doc = "APB1 configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIV = 0x0,
        #[doc = "APB1 configuration bits are accessible by privilege software only."]
        PRIV = 0x01,
    }
    impl Apbpv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Apbpv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Apbpv {
        #[inline(always)]
        fn from(val: u8) -> Apbpv {
            Apbpv::from_bits(val)
        }
    }
    impl From<Apbpv> for u8 {
        #[inline(always)]
        fn from(val: Apbpv) -> u8 {
            Apbpv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Apbsec {
        #[doc = "APB1 configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "APB1 configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Apbsec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Apbsec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Apbsec {
        #[inline(always)]
        fn from(val: u8) -> Apbsec {
            Apbsec::from_bits(val)
        }
    }
    impl From<Apbsec> for u8 {
        #[inline(always)]
        fn from(val: Apbsec) -> u8 {
            Apbsec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Axisrampub {
        #[doc = "AXISRAM1 configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "AXISRAM1 configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Axisrampub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Axisrampub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Axisrampub {
        #[inline(always)]
        fn from(val: u8) -> Axisrampub {
            Axisrampub::from_bits(val)
        }
    }
    impl From<Axisrampub> for u8 {
        #[inline(always)]
        fn from(val: Axisrampub) -> u8 {
            Axisrampub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Bkpsrampub {
        #[doc = "BKPSRAM configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "BKPSRAM configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Bkpsrampub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Bkpsrampub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Bkpsrampub {
        #[inline(always)]
        fn from(val: u8) -> Bkpsrampub {
            Bkpsrampub::from_bits(val)
        }
    }
    impl From<Bkpsrampub> for u8 {
        #[inline(always)]
        fn from(val: Bkpsrampub) -> u8 {
            Bkpsrampub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Buslock {
        #[doc = "BUS configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "BUS configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Buslock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Buslock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Buslock {
        #[inline(always)]
        fn from(val: u8) -> Buslock {
            Buslock::from_bits(val)
        }
    }
    impl From<Buslock> for u8 {
        #[inline(always)]
        fn from(val: Buslock) -> u8 {
            Buslock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Buspub {
        #[doc = "BUS configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "BUS configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Buspub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Buspub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Buspub {
        #[inline(always)]
        fn from(val: u8) -> Buspub {
            Buspub::from_bits(val)
        }
    }
    impl From<Buspub> for u8 {
        #[inline(always)]
        fn from(val: Buspub) -> u8 {
            Buspub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Buspv {
        #[doc = "BUS configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIV = 0x0,
        #[doc = "BUS configuration bits are accessible by privilege software only."]
        PRIV = 0x01,
    }
    impl Buspv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Buspv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Buspv {
        #[inline(always)]
        fn from(val: u8) -> Buspv {
            Buspv::from_bits(val)
        }
    }
    impl From<Buspv> for u8 {
        #[inline(always)]
        fn from(val: Buspv) -> u8 {
            Buspv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Bussec {
        #[doc = "BUS configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "BUS configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Bussec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Bussec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Bussec {
        #[inline(always)]
        fn from(val: u8) -> Bussec {
            Bussec::from_bits(val)
        }
    }
    impl From<Bussec> for u8 {
        #[inline(always)]
        fn from(val: Bussec) -> u8 {
            Bussec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Cpusw {
        #[doc = "hsi_ck selected as system clock (default after reset)."]
        HSI = 0x0,
        #[doc = "msi_ck selected as system clock."]
        MSI = 0x01,
        #[doc = "hse_ck selected as system clock."]
        HSE = 0x02,
        #[doc = "ic1_ck selected as system clock."]
        IC1 = 0x03,
    }
    impl Cpusw {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Cpusw {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Cpusw {
        #[inline(always)]
        fn from(val: u8) -> Cpusw {
            Cpusw::from_bits(val)
        }
    }
    impl From<Cpusw> for u8 {
        #[inline(always)]
        fn from(val: Cpusw) -> u8 {
            Cpusw::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Cpusws {
        #[doc = "hsi_ck selected as system clock (default after reset)."]
        HSI = 0x0,
        #[doc = "msi_ck selected as system clock."]
        MSI = 0x01,
        #[doc = "hse_ck selected as system clock."]
        HSE = 0x02,
        #[doc = "ic1_ck selected as system clock."]
        IC1 = 0x03,
    }
    impl Cpusws {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Cpusws {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Cpusws {
        #[inline(always)]
        fn from(val: u8) -> Cpusws {
            Cpusws::from_bits(val)
        }
    }
    impl From<Cpusws> for u8 {
        #[inline(always)]
        fn from(val: Cpusws) -> u8 {
            Cpusws::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Dcmippsel {
        #[doc = "pclk5 selected as reference clock."]
        PCLK5 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic17_ck selected as reference clock."]
        IC17 = 0x02,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x03,
    }
    impl Dcmippsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Dcmippsel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Dcmippsel {
        #[inline(always)]
        fn from(val: u8) -> Dcmippsel {
            Dcmippsel::from_bits(val)
        }
    }
    impl From<Dcmippsel> for u8 {
        #[inline(always)]
        fn from(val: Dcmippsel) -> u8 {
            Dcmippsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Dftlock {
        #[doc = "DFT configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "DFT configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Dftlock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Dftlock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Dftlock {
        #[inline(always)]
        fn from(val: u8) -> Dftlock {
            Dftlock::from_bits(val)
        }
    }
    impl From<Dftlock> for u8 {
        #[inline(always)]
        fn from(val: Dftlock) -> u8 {
            Dftlock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Dftpub {
        #[doc = "DFT configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "DFT configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Dftpub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Dftpub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Dftpub {
        #[inline(always)]
        fn from(val: u8) -> Dftpub {
            Dftpub::from_bits(val)
        }
    }
    impl From<Dftpub> for u8 {
        #[inline(always)]
        fn from(val: Dftpub) -> u8 {
            Dftpub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Dftpv {
        #[doc = "DFT configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIV = 0x0,
        #[doc = "DFT configuration bits are accessible by privilege software only."]
        PRIV = 0x01,
    }
    impl Dftpv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Dftpv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Dftpv {
        #[inline(always)]
        fn from(val: u8) -> Dftpv {
            Dftpv::from_bits(val)
        }
    }
    impl From<Dftpv> for u8 {
        #[inline(always)]
        fn from(val: Dftpv) -> u8 {
            Dftpv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Dftsec {
        #[doc = "DFT configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "DFT configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Dftsec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Dftsec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Dftsec {
        #[inline(always)]
        fn from(val: u8) -> Dftsec {
            Dftsec::from_bits(val)
        }
    }
    impl From<Dftsec> for u8 {
        #[inline(always)]
        fn from(val: Dftsec) -> u8 {
            Dftsec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Dftsel {
        #[doc = "jtag_tck selected as reference clock (default after reset)."]
        JTAG_TCK = 0x0,
        #[doc = "pclk3 selected as reference clock."]
        PCLK3 = 0x01,
    }
    impl Dftsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Dftsel {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Dftsel {
        #[inline(always)]
        fn from(val: u8) -> Dftsel {
            Dftsel::from_bits(val)
        }
    }
    impl From<Dftsel> for u8 {
        #[inline(always)]
        fn from(val: Dftsel) -> u8 {
            Dftsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Eadly {
        #[doc = "sysrstn low pulse duration is guaranteed by the pulse stretcher of the PAD. The RPCTL is bypassed (default after reset)."]
        BYPASS = 0x0,
        #[doc = "The guaranteed sysrstn low pulse duration is about 1 ms (1 x 32 lsi_ck cycles)."]
        _1MS = 0x01,
        #[doc = "The guaranteed sysrstn low pulse duration is about 2 ms (2 x 32 lsi_ck cycles)."]
        _2MS = 0x02,
        _RESERVED_3 = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
        _RESERVED_8 = 0x08,
        _RESERVED_9 = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        _RESERVED_f = 0x0f,
    }
    impl Eadly {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Eadly {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Eadly {
        #[inline(always)]
        fn from(val: u8) -> Eadly {
            Eadly::from_bits(val)
        }
    }
    impl From<Eadly> for u8 {
        #[inline(always)]
        fn from(val: Eadly) -> u8 {
            Eadly::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ethclksel {
        #[doc = "hclke selected as reference clock."]
        HCLKE = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic12_ck selected as reference clock."]
        IC12 = 0x02,
        #[doc = "hse_ck selected as reference clock."]
        HSE = 0x03,
    }
    impl Ethclksel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ethclksel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ethclksel {
        #[inline(always)]
        fn from(val: u8) -> Ethclksel {
            Ethclksel::from_bits(val)
        }
    }
    impl From<Ethclksel> for u8 {
        #[inline(always)]
        fn from(val: Ethclksel) -> u8 {
            Ethclksel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ethgtxclksel {
        #[doc = "MII."]
        MII = 0x0,
        #[doc = "RGMII."]
        RGMII = 0x01,
    }
    impl Ethgtxclksel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ethgtxclksel {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ethgtxclksel {
        #[inline(always)]
        fn from(val: u8) -> Ethgtxclksel {
            Ethgtxclksel::from_bits(val)
        }
    }
    impl From<Ethgtxclksel> for u8 {
        #[inline(always)]
        fn from(val: Ethgtxclksel) -> u8 {
            Ethgtxclksel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ethptpdiv {
        #[doc = "ck_ker_eth1ptp is divided by 1."]
        DIV1 = 0x0,
        #[doc = "ck_ker_eth1ptp is divided by 2."]
        DIV2 = 0x01,
        #[doc = "ck_ker_eth1ptp is divided by 3."]
        DIV3 = 0x02,
        #[doc = "ck_ker_eth1ptp is divided by 4."]
        DIV4 = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
        _RESERVED_8 = 0x08,
        _RESERVED_9 = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        #[doc = "ck_ker_eth1ptp is divided by 16."]
        DIV16 = 0x0f,
    }
    impl Ethptpdiv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ethptpdiv {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ethptpdiv {
        #[inline(always)]
        fn from(val: u8) -> Ethptpdiv {
            Ethptpdiv::from_bits(val)
        }
    }
    impl From<Ethptpdiv> for u8 {
        #[inline(always)]
        fn from(val: Ethptpdiv) -> u8 {
            Ethptpdiv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ethptpsel {
        #[doc = "hclke selected as reference clock."]
        HCLKE = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic13_ck selected as reference clock."]
        IC13 = 0x02,
        #[doc = "hse_ck selected as reference clock."]
        HSE = 0x03,
    }
    impl Ethptpsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ethptpsel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ethptpsel {
        #[inline(always)]
        fn from(val: u8) -> Ethptpsel {
            Ethptpsel::from_bits(val)
        }
    }
    impl From<Ethptpsel> for u8 {
        #[inline(always)]
        fn from(val: Ethptpsel) -> u8 {
            Ethptpsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ethpwrdownack {
        #[doc = "Power-down sequence start not yet acknowledged."]
        NOT_ACK = 0x0,
        #[doc = "Power-down sequence start acknowledged."]
        ACK = 0x01,
    }
    impl Ethpwrdownack {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ethpwrdownack {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ethpwrdownack {
        #[inline(always)]
        fn from(val: u8) -> Ethpwrdownack {
            Ethpwrdownack::from_bits(val)
        }
    }
    impl From<Ethpwrdownack> for u8 {
        #[inline(always)]
        fn from(val: Ethpwrdownack) -> u8 {
            Ethpwrdownack::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Fdcansel {
        #[doc = "pclk1 selected as reference clock."]
        PCLK1 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic19_ck selected as reference clock."]
        IC19 = 0x02,
        #[doc = "hse_ck selected as reference clock."]
        HSE = 0x03,
    }
    impl Fdcansel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Fdcansel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Fdcansel {
        #[inline(always)]
        fn from(val: u8) -> Fdcansel {
            Fdcansel::from_bits(val)
        }
    }
    impl From<Fdcansel> for u8 {
        #[inline(always)]
        fn from(val: Fdcansel) -> u8 {
            Fdcansel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Flexrampub {
        #[doc = "FLEXRAM configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "FLEXRAM configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Flexrampub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Flexrampub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Flexrampub {
        #[inline(always)]
        fn from(val: u8) -> Flexrampub {
            Flexrampub::from_bits(val)
        }
    }
    impl From<Flexrampub> for u8 {
        #[inline(always)]
        fn from(val: Flexrampub) -> u8 {
            Flexrampub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Fmcsel {
        #[doc = "hclk5 selected as reference clock."]
        HCLK5 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic3_ck selected as reference clock."]
        IC3 = 0x02,
        #[doc = "ic4_ck selected as reference clock."]
        IC4 = 0x03,
    }
    impl Fmcsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Fmcsel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Fmcsel {
        #[inline(always)]
        fn from(val: u8) -> Fmcsel {
            Fmcsel::from_bits(val)
        }
    }
    impl From<Fmcsel> for u8 {
        #[inline(always)]
        fn from(val: Fmcsel) -> u8 {
            Fmcsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Fmcsels {
        #[doc = "hclk5 selected as FMC clock (default after reset)."]
        HCLK5 = 0x0,
        #[doc = "per_ck selected as FMC clock."]
        PER = 0x01,
        #[doc = "ic3_ck selected as FMC clock."]
        IC3 = 0x02,
        #[doc = "ic4_ck selected as FMC clock."]
        IC4 = 0x03,
    }
    impl Fmcsels {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Fmcsels {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Fmcsels {
        #[inline(always)]
        fn from(val: u8) -> Fmcsels {
            Fmcsels::from_bits(val)
        }
    }
    impl From<Fmcsels> for u8 {
        #[inline(always)]
        fn from(val: Fmcsels) -> u8 {
            Fmcsels::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hpre {
        #[doc = "sys_bus2_ck= sys_bus_ck."]
        DIV1 = 0x0,
        #[doc = "sys_bus2_ck = sys_bus_ck / 2 (default after reset)."]
        DIV2 = 0x01,
        #[doc = "sys_bus2_ck= sys_bus_ck / 4."]
        DIV4 = 0x02,
        #[doc = "sys_bus2_ck = sys_bus_ck / 8."]
        DIV8 = 0x03,
        #[doc = "sys_bus2_ck = sys_bus_ck / 16."]
        DIV16 = 0x04,
        #[doc = "sys_bus2_ck = sys_bus_ck / 32."]
        DIV32 = 0x05,
        #[doc = "sys_bus2_ck = sys_bus_ck / 64."]
        DIV64 = 0x06,
        #[doc = "sys_bus2_ck = sys_bus_ck / 128."]
        DIV128 = 0x07,
    }
    impl Hpre {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hpre {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hpre {
        #[inline(always)]
        fn from(val: u8) -> Hpre {
            Hpre::from_bits(val)
        }
    }
    impl From<Hpre> for u8 {
        #[inline(always)]
        fn from(val: Hpre) -> u8 {
            Hpre::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsebyp {
        #[doc = "HSE oscillator not bypassed (default after reset)."]
        NO_BYPASS = 0x0,
        #[doc = "HSE oscillator bypassed with an external clock."]
        BYPASS = 0x01,
    }
    impl Hsebyp {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsebyp {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsebyp {
        #[inline(always)]
        fn from(val: u8) -> Hsebyp {
            Hsebyp::from_bits(val)
        }
    }
    impl From<Hsebyp> for u8 {
        #[inline(always)]
        fn from(val: Hsebyp) -> u8 {
            Hsebyp::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsecssbpre {
        #[doc = "HSI clock is divided by 1."]
        DIV1 = 0x0,
        #[doc = "HSI clock is divided by 2 (default after reset)."]
        DIV2 = 0x01,
        #[doc = "HSI clock is divided by 3."]
        DIV3 = 0x02,
        #[doc = "HSI clock is divided by 4."]
        DIV4 = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
        _RESERVED_8 = 0x08,
        _RESERVED_9 = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        #[doc = "HSI clock is divided by 15."]
        DIV15 = 0x0f,
    }
    impl Hsecssbpre {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsecssbpre {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsecssbpre {
        #[inline(always)]
        fn from(val: u8) -> Hsecssbpre {
            Hsecssbpre::from_bits(val)
        }
    }
    impl From<Hsecssbpre> for u8 {
        #[inline(always)]
        fn from(val: Hsecssbpre) -> u8 {
            Hsecssbpre::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsecssbyp {
        #[doc = "clock Security System Bypass of the HSE oscillator is OFF (default after reset)."]
        NO_BYPASS = 0x0,
        #[doc = "clock Security System Bypass on the HSE oscillator is ON."]
        BYPASS = 0x01,
    }
    impl Hsecssbyp {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsecssbyp {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsecssbyp {
        #[inline(always)]
        fn from(val: u8) -> Hsecssbyp {
            Hsecssbyp::from_bits(val)
        }
    }
    impl From<Hsecssbyp> for u8 {
        #[inline(always)]
        fn from(val: Hsecssbyp) -> u8 {
            Hsecssbyp::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsecssc {
        #[doc = "HSECSSF not modified (default after reset)."]
        NOT_MODIFIED = 0x0,
        #[doc = "HSECSSF cleared."]
        CLEARED = 0x01,
    }
    impl Hsecssc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsecssc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsecssc {
        #[inline(always)]
        fn from(val: u8) -> Hsecssc {
            Hsecssc::from_bits(val)
        }
    }
    impl From<Hsecssc> for u8 {
        #[inline(always)]
        fn from(val: Hsecssc) -> u8 {
            Hsecssc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsecssd {
        #[doc = "No failure detected on the oscillator (default after reset)."]
        NO_FAILURE = 0x0,
        #[doc = "Failure detected on the oscillator."]
        FAILURE = 0x01,
    }
    impl Hsecssd {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsecssd {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsecssd {
        #[inline(always)]
        fn from(val: u8) -> Hsecssd {
            Hsecssd::from_bits(val)
        }
    }
    impl From<Hsecssd> for u8 {
        #[inline(always)]
        fn from(val: Hsecssd) -> u8 {
            Hsecssd::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsecssf {
        #[doc = "no clock ready interrupt caused by the HSE (default after reset)."]
        NO_CLOCK_READY = 0x0,
        #[doc = "clock ready interrupt caused by the HSE."]
        CLOCK_READY = 0x01,
    }
    impl Hsecssf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsecssf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsecssf {
        #[inline(always)]
        fn from(val: u8) -> Hsecssf {
            Hsecssf::from_bits(val)
        }
    }
    impl From<Hsecssf> for u8 {
        #[inline(always)]
        fn from(val: Hsecssf) -> u8 {
            Hsecssf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsecssie {
        #[doc = "HSE CSS interrupt disabled."]
        DISABLED = 0x0,
        #[doc = "HSE CSS interrupt enabled (default after reset)."]
        ENABLED = 0x01,
    }
    impl Hsecssie {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsecssie {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsecssie {
        #[inline(always)]
        fn from(val: u8) -> Hsecssie {
            Hsecssie::from_bits(val)
        }
    }
    impl From<Hsecssie> for u8 {
        #[inline(always)]
        fn from(val: Hsecssie) -> u8 {
            Hsecssie::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsecssra {
        #[doc = "Writing 0 has no effect (default after reset)."]
        NO_RE_ARM = 0x0,
        #[doc = "Writing 1 generates a re-arm pulse for the HSECSS function."]
        RE_ARM = 0x01,
    }
    impl Hsecssra {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsecssra {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsecssra {
        #[inline(always)]
        fn from(val: u8) -> Hsecssra {
            Hsecssra::from_bits(val)
        }
    }
    impl From<Hsecssra> for u8 {
        #[inline(always)]
        fn from(val: Hsecssra) -> u8 {
            Hsecssra::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsedivbyp {
        #[doc = "HSE: hse_div2_osc_ck = hse_osc_ck/2 (default after reset)."]
        DIV2 = 0x0,
        #[doc = "HSE: hse_div2_osc_ck = hse_osc_ck."]
        DIV1 = 0x01,
    }
    impl Hsedivbyp {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsedivbyp {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsedivbyp {
        #[inline(always)]
        fn from(val: u8) -> Hsedivbyp {
            Hsedivbyp::from_bits(val)
        }
    }
    impl From<Hsedivbyp> for u8 {
        #[inline(always)]
        fn from(val: Hsedivbyp) -> u8 {
            Hsedivbyp::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsedrv {
        #[doc = "Lowest drive (default after reset)."]
        LOWEST = 0x0,
        #[doc = "Medium low drive."]
        LOW = 0x01,
        #[doc = "Medium high drive."]
        HIGH = 0x02,
        #[doc = "Highest drive."]
        HIGHEST = 0x03,
    }
    impl Hsedrv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsedrv {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsedrv {
        #[inline(always)]
        fn from(val: u8) -> Hsedrv {
            Hsedrv::from_bits(val)
        }
    }
    impl From<Hsedrv> for u8 {
        #[inline(always)]
        fn from(val: Hsedrv) -> u8 {
            Hsedrv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hseext {
        #[doc = "HSE in analog mode (default after reset)."]
        ANALOG = 0x0,
        #[doc = "HSE in digital mode."]
        DIGITAL = 0x01,
    }
    impl Hseext {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hseext {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hseext {
        #[inline(always)]
        fn from(val: u8) -> Hseext {
            Hseext::from_bits(val)
        }
    }
    impl From<Hseext> for u8 {
        #[inline(always)]
        fn from(val: Hseext) -> u8 {
            Hseext::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hselock {
        #[doc = "HSE configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "HSE configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Hselock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hselock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hselock {
        #[inline(always)]
        fn from(val: u8) -> Hselock {
            Hselock::from_bits(val)
        }
    }
    impl From<Hselock> for u8 {
        #[inline(always)]
        fn from(val: Hselock) -> u8 {
            Hselock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsepub {
        #[doc = "HSE configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "HSE configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Hsepub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsepub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsepub {
        #[inline(always)]
        fn from(val: u8) -> Hsepub {
            Hsepub::from_bits(val)
        }
    }
    impl From<Hsepub> for u8 {
        #[inline(always)]
        fn from(val: Hsepub) -> u8 {
            Hsepub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsepv {
        #[doc = "HSE configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIV = 0x0,
        #[doc = "HSE configuration bits are accessible by privilege software only."]
        PRIV = 0x01,
    }
    impl Hsepv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsepv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsepv {
        #[inline(always)]
        fn from(val: u8) -> Hsepv {
            Hsepv::from_bits(val)
        }
    }
    impl From<Hsepv> for u8 {
        #[inline(always)]
        fn from(val: Hsepv) -> u8 {
            Hsepv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hserdy {
        #[doc = "HSE is not ready (default after reset)."]
        NO_RDY = 0x0,
        #[doc = "HSE is ready."]
        RDY = 0x01,
    }
    impl Hserdy {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hserdy {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hserdy {
        #[inline(always)]
        fn from(val: u8) -> Hserdy {
            Hserdy::from_bits(val)
        }
    }
    impl From<Hserdy> for u8 {
        #[inline(always)]
        fn from(val: Hserdy) -> u8 {
            Hserdy::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hserdyc {
        #[doc = "HSERDYF not modified (default after reset)."]
        NOT_MODIFIED = 0x0,
        #[doc = "HSERDYF cleared."]
        CLEARED = 0x01,
    }
    impl Hserdyc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hserdyc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hserdyc {
        #[inline(always)]
        fn from(val: u8) -> Hserdyc {
            Hserdyc::from_bits(val)
        }
    }
    impl From<Hserdyc> for u8 {
        #[inline(always)]
        fn from(val: Hserdyc) -> u8 {
            Hserdyc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hserdyf {
        #[doc = "no clock ready interrupt caused by the HSE (default after reset)."]
        NO_CLOCK_READY = 0x0,
        #[doc = "clock ready interrupt caused by the HSE."]
        CLOCK_READY = 0x01,
    }
    impl Hserdyf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hserdyf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hserdyf {
        #[inline(always)]
        fn from(val: u8) -> Hserdyf {
            Hserdyf::from_bits(val)
        }
    }
    impl From<Hserdyf> for u8 {
        #[inline(always)]
        fn from(val: Hserdyf) -> u8 {
            Hserdyf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hserdyie {
        #[doc = "HSE ready interrupt disabled (default after reset)."]
        DISABLED = 0x0,
        #[doc = "HSE ready interrupt enabled."]
        ENABLED = 0x01,
    }
    impl Hserdyie {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hserdyie {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hserdyie {
        #[inline(always)]
        fn from(val: u8) -> Hserdyie {
            Hserdyie::from_bits(val)
        }
    }
    impl From<Hserdyie> for u8 {
        #[inline(always)]
        fn from(val: Hserdyie) -> u8 {
            Hserdyie::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsesec {
        #[doc = "HSE configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "HSE configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Hsesec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsesec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsesec {
        #[inline(always)]
        fn from(val: u8) -> Hsesec {
            Hsesec::from_bits(val)
        }
    }
    impl From<Hsesec> for u8 {
        #[inline(always)]
        fn from(val: Hsesec) -> u8 {
            Hsesec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsidiv {
        #[doc = "hsi_ck = hsi_osc_ck (default after reset)."]
        DIV1 = 0x0,
        #[doc = "hsi_ck = hsi_osc_ck / 2."]
        DIV2 = 0x01,
        _RESERVED_2 = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Hsidiv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsidiv {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsidiv {
        #[inline(always)]
        fn from(val: u8) -> Hsidiv {
            Hsidiv::from_bits(val)
        }
    }
    impl From<Hsidiv> for u8 {
        #[inline(always)]
        fn from(val: Hsidiv) -> u8 {
            Hsidiv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsilock {
        #[doc = "HSI configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "HSI configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Hsilock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsilock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsilock {
        #[inline(always)]
        fn from(val: u8) -> Hsilock {
            Hsilock::from_bits(val)
        }
    }
    impl From<Hsilock> for u8 {
        #[inline(always)]
        fn from(val: Hsilock) -> u8 {
            Hsilock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsipub {
        #[doc = "HSI configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "HSI configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Hsipub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsipub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsipub {
        #[inline(always)]
        fn from(val: u8) -> Hsipub {
            Hsipub::from_bits(val)
        }
    }
    impl From<Hsipub> for u8 {
        #[inline(always)]
        fn from(val: Hsipub) -> u8 {
            Hsipub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsipv {
        #[doc = "HSI configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIV = 0x0,
        #[doc = "HSI configuration bits are accessible by privilege software only."]
        PRIV = 0x01,
    }
    impl Hsipv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsipv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsipv {
        #[inline(always)]
        fn from(val: u8) -> Hsipv {
            Hsipv::from_bits(val)
        }
    }
    impl From<Hsipv> for u8 {
        #[inline(always)]
        fn from(val: Hsipv) -> u8 {
            Hsipv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsirdy {
        #[doc = "HSI is not ready."]
        NO_RDY = 0x0,
        #[doc = "HSI is ready (default after reset)."]
        RDY = 0x01,
    }
    impl Hsirdy {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsirdy {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsirdy {
        #[inline(always)]
        fn from(val: u8) -> Hsirdy {
            Hsirdy::from_bits(val)
        }
    }
    impl From<Hsirdy> for u8 {
        #[inline(always)]
        fn from(val: Hsirdy) -> u8 {
            Hsirdy::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsirdyc {
        #[doc = "HSIRDYF not modified (default after reset)."]
        NOT_MODIFIED = 0x0,
        #[doc = "HSIRDYF cleared."]
        CLEARED = 0x01,
    }
    impl Hsirdyc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsirdyc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsirdyc {
        #[inline(always)]
        fn from(val: u8) -> Hsirdyc {
            Hsirdyc::from_bits(val)
        }
    }
    impl From<Hsirdyc> for u8 {
        #[inline(always)]
        fn from(val: Hsirdyc) -> u8 {
            Hsirdyc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsirdyf {
        #[doc = "no clock ready interrupt caused by the HSI (default after reset)."]
        NO_CLOCK_READY = 0x0,
        #[doc = "clock ready interrupt caused by the HSI."]
        CLOCK_READY = 0x01,
    }
    impl Hsirdyf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsirdyf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsirdyf {
        #[inline(always)]
        fn from(val: u8) -> Hsirdyf {
            Hsirdyf::from_bits(val)
        }
    }
    impl From<Hsirdyf> for u8 {
        #[inline(always)]
        fn from(val: Hsirdyf) -> u8 {
            Hsirdyf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsirdyie {
        #[doc = "HSI ready interrupt disabled (default after reset)."]
        DISABLED = 0x0,
        #[doc = "HSI ready interrupt enabled."]
        ENABLED = 0x01,
    }
    impl Hsirdyie {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsirdyie {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsirdyie {
        #[inline(always)]
        fn from(val: u8) -> Hsirdyie {
            Hsirdyie::from_bits(val)
        }
    }
    impl From<Hsirdyie> for u8 {
        #[inline(always)]
        fn from(val: Hsirdyie) -> u8 {
            Hsirdyie::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Hsisec {
        #[doc = "HSI configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "HSI configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Hsisec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsisec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsisec {
        #[inline(always)]
        fn from(val: u8) -> Hsisec {
            Hsisec::from_bits(val)
        }
    }
    impl From<Hsisec> for u8 {
        #[inline(always)]
        fn from(val: Hsisec) -> u8 {
            Hsisec::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Hsitrim(u8);
    impl Hsitrim {
        #[doc = "bsec_hsi_cal\\[8:0\\]
(default after reset)."]
        pub const ZERO: Self = Self(0x0);
        #[doc = "bsec_hsi_cal\\[8:0\\]
+ 62."]
        pub const PLUS_62: Self = Self(0x3e);
        #[doc = "bsec_hsi_cal\\[8:0\\]
+ 63."]
        pub const PLUS_63: Self = Self(0x3f);
        #[doc = "bsec_hsi_cal\\[8:0\\]
- 64."]
        pub const MINUS_64: Self = Self(0x40);
        #[doc = "bsec_hsi_cal\\[8:0\\]
- 63."]
        pub const MINUS_63: Self = Self(0x41);
    }
    impl Hsitrim {
        pub const fn from_bits(val: u8) -> Hsitrim {
            Self(val & 0x7f)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Hsitrim {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("ZERO"),
                0x3e => f.write_str("PLUS_62"),
                0x3f => f.write_str("PLUS_63"),
                0x40 => f.write_str("MINUS_64"),
                0x41 => f.write_str("MINUS_63"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Hsitrim {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "ZERO"),
                0x3e => defmt::write!(f, "PLUS_62"),
                0x3f => defmt::write!(f, "PLUS_63"),
                0x40 => defmt::write!(f, "MINUS_64"),
                0x41 => defmt::write!(f, "MINUS_63"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Hsitrim {
        #[inline(always)]
        fn from(val: u8) -> Hsitrim {
            Hsitrim::from_bits(val)
        }
    }
    impl From<Hsitrim> for u8 {
        #[inline(always)]
        fn from(val: Hsitrim) -> u8 {
            Hsitrim::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum HwrsrBorrstf {
        #[doc = "no BOR occurred."]
        NOT_OCCURRED = 0x0,
        #[doc = "BOR occurred (default after power-on reset)."]
        OCCURRED = 0x01,
    }
    impl HwrsrBorrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> HwrsrBorrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for HwrsrBorrstf {
        #[inline(always)]
        fn from(val: u8) -> HwrsrBorrstf {
            HwrsrBorrstf::from_bits(val)
        }
    }
    impl From<HwrsrBorrstf> for u8 {
        #[inline(always)]
        fn from(val: HwrsrBorrstf) -> u8 {
            HwrsrBorrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum HwrsrIwdgrstf {
        #[doc = "no Independent Watchdog Reset occurred (default after power-on reset)."]
        NOT_OCCURRED = 0x0,
        #[doc = "Independent Watchdog Reset occurred."]
        OCCURRED = 0x01,
    }
    impl HwrsrIwdgrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> HwrsrIwdgrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for HwrsrIwdgrstf {
        #[inline(always)]
        fn from(val: u8) -> HwrsrIwdgrstf {
            HwrsrIwdgrstf::from_bits(val)
        }
    }
    impl From<HwrsrIwdgrstf> for u8 {
        #[inline(always)]
        fn from(val: HwrsrIwdgrstf) -> u8 {
            HwrsrIwdgrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum HwrsrLckrstf {
        #[doc = "No reset from CPU lockup occurred."]
        NOT_OCCURRED = 0x0,
        #[doc = "Reset from CPU lockup occurred."]
        OCCURRED = 0x01,
    }
    impl HwrsrLckrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> HwrsrLckrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for HwrsrLckrstf {
        #[inline(always)]
        fn from(val: u8) -> HwrsrLckrstf {
            HwrsrLckrstf::from_bits(val)
        }
    }
    impl From<HwrsrLckrstf> for u8 {
        #[inline(always)]
        fn from(val: HwrsrLckrstf) -> u8 {
            HwrsrLckrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum HwrsrLpwrrstf {
        #[doc = "no illegal reset occurred (default after power-on reset)."]
        NOT_OCCURRED = 0x0,
        #[doc = "illegal Stop or Standby reset occurred."]
        OCCURRED = 0x01,
    }
    impl HwrsrLpwrrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> HwrsrLpwrrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for HwrsrLpwrrstf {
        #[inline(always)]
        fn from(val: u8) -> HwrsrLpwrrstf {
            HwrsrLpwrrstf::from_bits(val)
        }
    }
    impl From<HwrsrLpwrrstf> for u8 {
        #[inline(always)]
        fn from(val: HwrsrLpwrrstf) -> u8 {
            HwrsrLpwrrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum HwrsrPinrstf {
        #[doc = "no reset from pin occurred."]
        NOT_OCCURRED = 0x0,
        #[doc = "Reset from Pin occurred (default after power-on reset)."]
        OCCURRED = 0x01,
    }
    impl HwrsrPinrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> HwrsrPinrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for HwrsrPinrstf {
        #[inline(always)]
        fn from(val: u8) -> HwrsrPinrstf {
            HwrsrPinrstf::from_bits(val)
        }
    }
    impl From<HwrsrPinrstf> for u8 {
        #[inline(always)]
        fn from(val: HwrsrPinrstf) -> u8 {
            HwrsrPinrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum HwrsrPorrstf {
        #[doc = "no POR/PDR reset occurred."]
        NOT_OCCURRED = 0x0,
        #[doc = "POR/PDR reset occurred (default after power-on reset)."]
        OCCURRED = 0x01,
    }
    impl HwrsrPorrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> HwrsrPorrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for HwrsrPorrstf {
        #[inline(always)]
        fn from(val: u8) -> HwrsrPorrstf {
            HwrsrPorrstf::from_bits(val)
        }
    }
    impl From<HwrsrPorrstf> for u8 {
        #[inline(always)]
        fn from(val: HwrsrPorrstf) -> u8 {
            HwrsrPorrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum HwrsrRmvf {
        #[doc = "clear of the reset flags not activated (default after power-on reset)."]
        NO_CLEAR = 0x0,
        #[doc = "clear the value of the reset flags."]
        CLEAR = 0x01,
    }
    impl HwrsrRmvf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> HwrsrRmvf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for HwrsrRmvf {
        #[inline(always)]
        fn from(val: u8) -> HwrsrRmvf {
            HwrsrRmvf::from_bits(val)
        }
    }
    impl From<HwrsrRmvf> for u8 {
        #[inline(always)]
        fn from(val: HwrsrRmvf) -> u8 {
            HwrsrRmvf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum HwrsrSftrstf {
        #[doc = "no Software System reset occurred (default after power-on reset)."]
        NOT_OCCURRED = 0x0,
        #[doc = "a Software System reset has been generated by the CPU."]
        OCCURRED = 0x01,
    }
    impl HwrsrSftrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> HwrsrSftrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for HwrsrSftrstf {
        #[inline(always)]
        fn from(val: u8) -> HwrsrSftrstf {
            HwrsrSftrstf::from_bits(val)
        }
    }
    impl From<HwrsrSftrstf> for u8 {
        #[inline(always)]
        fn from(val: HwrsrSftrstf) -> u8 {
            HwrsrSftrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum HwrsrWwdgrstf {
        #[doc = "no Window Watchdog Reset occurred from WWDG (default after power-on reset)."]
        B_0X0 = 0x0,
        #[doc = "Window Watchdog Reset occurred from WWDG."]
        B_0X1 = 0x01,
    }
    impl HwrsrWwdgrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> HwrsrWwdgrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for HwrsrWwdgrstf {
        #[inline(always)]
        fn from(val: u8) -> HwrsrWwdgrstf {
            HwrsrWwdgrstf::from_bits(val)
        }
    }
    impl From<HwrsrWwdgrstf> for u8 {
        #[inline(always)]
        fn from(val: HwrsrWwdgrstf) -> u8 {
            HwrsrWwdgrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum I2c1sel {
        #[doc = "pclk1 selected as reference clock."]
        PCLK1 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic10_ck selected as reference clock."]
        IC10 = 0x02,
        #[doc = "ic15_ck selected as reference clock."]
        IC15 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl I2c1sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> I2c1sel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for I2c1sel {
        #[inline(always)]
        fn from(val: u8) -> I2c1sel {
            I2c1sel::from_bits(val)
        }
    }
    impl From<I2c1sel> for u8 {
        #[inline(always)]
        fn from(val: I2c1sel) -> u8 {
            I2c1sel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum I2c2sel {
        #[doc = "pclk1 selected as reference clock."]
        PCLK1 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic10_ck selected as reference clock."]
        IC10 = 0x02,
        #[doc = "ic15_ck selected as reference clock."]
        IC15 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl I2c2sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> I2c2sel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for I2c2sel {
        #[inline(always)]
        fn from(val: u8) -> I2c2sel {
            I2c2sel::from_bits(val)
        }
    }
    impl From<I2c2sel> for u8 {
        #[inline(always)]
        fn from(val: I2c2sel) -> u8 {
            I2c2sel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum I2c3sel {
        #[doc = "pclk1 selected as reference clock."]
        PCLK1 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic10_ck selected as reference clock."]
        IC10 = 0x02,
        #[doc = "ic15_ck selected as reference clock."]
        IC15 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl I2c3sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> I2c3sel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for I2c3sel {
        #[inline(always)]
        fn from(val: u8) -> I2c3sel {
            I2c3sel::from_bits(val)
        }
    }
    impl From<I2c3sel> for u8 {
        #[inline(always)]
        fn from(val: I2c3sel) -> u8 {
            I2c3sel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum I2c4sel {
        #[doc = "pclk1 selected as reference clock."]
        PCLK1 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic10_ck selected as reference clock."]
        IC10 = 0x02,
        #[doc = "ic15_ck selected as reference clock."]
        IC15 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl I2c4sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> I2c4sel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for I2c4sel {
        #[inline(always)]
        fn from(val: u8) -> I2c4sel {
            I2c4sel::from_bits(val)
        }
    }
    impl From<I2c4sel> for u8 {
        #[inline(always)]
        fn from(val: I2c4sel) -> u8 {
            I2c4sel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum I3c1sel {
        #[doc = "pclk1 selected as reference clock."]
        PCLK1 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic10_ck selected as reference clock."]
        IC10 = 0x02,
        #[doc = "ic15_ck selected as reference clock."]
        IC15 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl I3c1sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> I3c1sel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for I3c1sel {
        #[inline(always)]
        fn from(val: u8) -> I3c1sel {
            I3c1sel::from_bits(val)
        }
    }
    impl From<I3c1sel> for u8 {
        #[inline(always)]
        fn from(val: I3c1sel) -> u8 {
            I3c1sel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum I3c2sel {
        #[doc = "pclk1 selected as reference clock."]
        PCLK1 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic10_ck selected as reference clock."]
        IC10 = 0x02,
        #[doc = "ic15_ck selected as reference clock."]
        IC15 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl I3c2sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> I3c2sel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for I3c2sel {
        #[inline(always)]
        fn from(val: u8) -> I3c2sel {
            I3c2sel::from_bits(val)
        }
    }
    impl From<I3c2sel> for u8 {
        #[inline(always)]
        fn from(val: I3c2sel) -> u8 {
            I3c2sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic10int(u8);
    impl Ic10int {
        #[doc = "IC10 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC10 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC10 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC10 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC10 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic10int {
        pub const fn from_bits(val: u8) -> Ic10int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic10int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic10int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic10int {
        #[inline(always)]
        fn from(val: u8) -> Ic10int {
            Ic10int::from_bits(val)
        }
    }
    impl From<Ic10int> for u8 {
        #[inline(always)]
        fn from(val: Ic10int) -> u8 {
            Ic10int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic10sel {
        #[doc = "pll1_ck is selected."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected (default after reset)."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic10sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic10sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic10sel {
        #[inline(always)]
        fn from(val: u8) -> Ic10sel {
            Ic10sel::from_bits(val)
        }
    }
    impl From<Ic10sel> for u8 {
        #[inline(always)]
        fn from(val: Ic10sel) -> u8 {
            Ic10sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic11int(u8);
    impl Ic11int {
        #[doc = "IC11 = pllx_ck."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC11 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC11 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC11 = pllx_ck / 4 (default after reset)."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC11 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic11int {
        pub const fn from_bits(val: u8) -> Ic11int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic11int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic11int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic11int {
        #[inline(always)]
        fn from(val: u8) -> Ic11int {
            Ic11int::from_bits(val)
        }
    }
    impl From<Ic11int> for u8 {
        #[inline(always)]
        fn from(val: Ic11int) -> u8 {
            Ic11int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic11sel {
        #[doc = "pll1_ck is selected (default after reset)."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic11sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic11sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic11sel {
        #[inline(always)]
        fn from(val: u8) -> Ic11sel {
            Ic11sel::from_bits(val)
        }
    }
    impl From<Ic11sel> for u8 {
        #[inline(always)]
        fn from(val: Ic11sel) -> u8 {
            Ic11sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic12int(u8);
    impl Ic12int {
        #[doc = "IC12 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC12 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC12 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC12 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC12 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic12int {
        pub const fn from_bits(val: u8) -> Ic12int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic12int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic12int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic12int {
        #[inline(always)]
        fn from(val: u8) -> Ic12int {
            Ic12int::from_bits(val)
        }
    }
    impl From<Ic12int> for u8 {
        #[inline(always)]
        fn from(val: Ic12int) -> u8 {
            Ic12int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic12sel {
        #[doc = "pll1_ck is selected."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic12sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic12sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic12sel {
        #[inline(always)]
        fn from(val: u8) -> Ic12sel {
            Ic12sel::from_bits(val)
        }
    }
    impl From<Ic12sel> for u8 {
        #[inline(always)]
        fn from(val: Ic12sel) -> u8 {
            Ic12sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic13int(u8);
    impl Ic13int {
        #[doc = "IC13 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC13 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC13 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC13 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC13 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic13int {
        pub const fn from_bits(val: u8) -> Ic13int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic13int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic13int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic13int {
        #[inline(always)]
        fn from(val: u8) -> Ic13int {
            Ic13int::from_bits(val)
        }
    }
    impl From<Ic13int> for u8 {
        #[inline(always)]
        fn from(val: Ic13int) -> u8 {
            Ic13int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic13sel {
        #[doc = "pll1_ck is selected."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic13sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic13sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic13sel {
        #[inline(always)]
        fn from(val: u8) -> Ic13sel {
            Ic13sel::from_bits(val)
        }
    }
    impl From<Ic13sel> for u8 {
        #[inline(always)]
        fn from(val: Ic13sel) -> u8 {
            Ic13sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic14int(u8);
    impl Ic14int {
        #[doc = "IC14 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC14 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC14 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC14 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC14 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic14int {
        pub const fn from_bits(val: u8) -> Ic14int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic14int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic14int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic14int {
        #[inline(always)]
        fn from(val: u8) -> Ic14int {
            Ic14int::from_bits(val)
        }
    }
    impl From<Ic14int> for u8 {
        #[inline(always)]
        fn from(val: Ic14int) -> u8 {
            Ic14int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic14sel {
        #[doc = "pll1_ck is selected."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic14sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic14sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic14sel {
        #[inline(always)]
        fn from(val: u8) -> Ic14sel {
            Ic14sel::from_bits(val)
        }
    }
    impl From<Ic14sel> for u8 {
        #[inline(always)]
        fn from(val: Ic14sel) -> u8 {
            Ic14sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic15int(u8);
    impl Ic15int {
        #[doc = "IC15 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC15 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC15 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC15 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC15 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic15int {
        pub const fn from_bits(val: u8) -> Ic15int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic15int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic15int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic15int {
        #[inline(always)]
        fn from(val: u8) -> Ic15int {
            Ic15int::from_bits(val)
        }
    }
    impl From<Ic15int> for u8 {
        #[inline(always)]
        fn from(val: Ic15int) -> u8 {
            Ic15int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic15sel {
        #[doc = "pll1_ck is selected."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic15sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic15sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic15sel {
        #[inline(always)]
        fn from(val: u8) -> Ic15sel {
            Ic15sel::from_bits(val)
        }
    }
    impl From<Ic15sel> for u8 {
        #[inline(always)]
        fn from(val: Ic15sel) -> u8 {
            Ic15sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic16int(u8);
    impl Ic16int {
        #[doc = "IC16 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC16 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC16 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC16 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic16int {
        pub const fn from_bits(val: u8) -> Ic16int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic16int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic16int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic16int {
        #[inline(always)]
        fn from(val: u8) -> Ic16int {
            Ic16int::from_bits(val)
        }
    }
    impl From<Ic16int> for u8 {
        #[inline(always)]
        fn from(val: Ic16int) -> u8 {
            Ic16int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic16sel {
        #[doc = "pll1_ck is selected."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic16sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic16sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic16sel {
        #[inline(always)]
        fn from(val: u8) -> Ic16sel {
            Ic16sel::from_bits(val)
        }
    }
    impl From<Ic16sel> for u8 {
        #[inline(always)]
        fn from(val: Ic16sel) -> u8 {
            Ic16sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic17int(u8);
    impl Ic17int {
        #[doc = "IC17 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC17 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC17 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC17 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC17 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic17int {
        pub const fn from_bits(val: u8) -> Ic17int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic17int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic17int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic17int {
        #[inline(always)]
        fn from(val: u8) -> Ic17int {
            Ic17int::from_bits(val)
        }
    }
    impl From<Ic17int> for u8 {
        #[inline(always)]
        fn from(val: Ic17int) -> u8 {
            Ic17int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic17sel {
        #[doc = "pll1_ck is selected."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic17sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic17sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic17sel {
        #[inline(always)]
        fn from(val: u8) -> Ic17sel {
            Ic17sel::from_bits(val)
        }
    }
    impl From<Ic17sel> for u8 {
        #[inline(always)]
        fn from(val: Ic17sel) -> u8 {
            Ic17sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic18int(u8);
    impl Ic18int {
        #[doc = "IC18 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC18 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC18 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC18 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC18 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic18int {
        pub const fn from_bits(val: u8) -> Ic18int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic18int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic18int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic18int {
        #[inline(always)]
        fn from(val: u8) -> Ic18int {
            Ic18int::from_bits(val)
        }
    }
    impl From<Ic18int> for u8 {
        #[inline(always)]
        fn from(val: Ic18int) -> u8 {
            Ic18int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic18sel {
        #[doc = "pll1_ck is selected."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic18sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic18sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic18sel {
        #[inline(always)]
        fn from(val: u8) -> Ic18sel {
            Ic18sel::from_bits(val)
        }
    }
    impl From<Ic18sel> for u8 {
        #[inline(always)]
        fn from(val: Ic18sel) -> u8 {
            Ic18sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic19int(u8);
    impl Ic19int {
        #[doc = "IC19 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC19 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC19 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC19 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC19 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic19int {
        pub const fn from_bits(val: u8) -> Ic19int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic19int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic19int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic19int {
        #[inline(always)]
        fn from(val: u8) -> Ic19int {
            Ic19int::from_bits(val)
        }
    }
    impl From<Ic19int> for u8 {
        #[inline(always)]
        fn from(val: Ic19int) -> u8 {
            Ic19int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic19sel {
        #[doc = "pll1_ck is selected."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic19sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic19sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic19sel {
        #[inline(always)]
        fn from(val: u8) -> Ic19sel {
            Ic19sel::from_bits(val)
        }
    }
    impl From<Ic19sel> for u8 {
        #[inline(always)]
        fn from(val: Ic19sel) -> u8 {
            Ic19sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic1int(u8);
    impl Ic1int {
        #[doc = "IC1 = pllx_ck."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC1 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC1 = pllx_ck / 3 (default after reset)."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC1 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC1 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic1int {
        pub const fn from_bits(val: u8) -> Ic1int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic1int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic1int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic1int {
        #[inline(always)]
        fn from(val: u8) -> Ic1int {
            Ic1int::from_bits(val)
        }
    }
    impl From<Ic1int> for u8 {
        #[inline(always)]
        fn from(val: Ic1int) -> u8 {
            Ic1int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic1sel {
        #[doc = "pll1_ck is selected (default after reset)."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic1sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic1sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic1sel {
        #[inline(always)]
        fn from(val: u8) -> Ic1sel {
            Ic1sel::from_bits(val)
        }
    }
    impl From<Ic1sel> for u8 {
        #[inline(always)]
        fn from(val: Ic1sel) -> u8 {
            Ic1sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic20int(u8);
    impl Ic20int {
        #[doc = "IC20 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC20 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC20 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC20 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC20 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic20int {
        pub const fn from_bits(val: u8) -> Ic20int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic20int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic20int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic20int {
        #[inline(always)]
        fn from(val: u8) -> Ic20int {
            Ic20int::from_bits(val)
        }
    }
    impl From<Ic20int> for u8 {
        #[inline(always)]
        fn from(val: Ic20int) -> u8 {
            Ic20int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic20sel {
        #[doc = "pll1_ck is selected."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic20sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic20sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic20sel {
        #[inline(always)]
        fn from(val: u8) -> Ic20sel {
            Ic20sel::from_bits(val)
        }
    }
    impl From<Ic20sel> for u8 {
        #[inline(always)]
        fn from(val: Ic20sel) -> u8 {
            Ic20sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic2int(u8);
    impl Ic2int {
        #[doc = "IC2 = pllx_ck."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC2 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC2 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC2 = pllx_ck / 4 (default after reset)."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC2 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic2int {
        pub const fn from_bits(val: u8) -> Ic2int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic2int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic2int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic2int {
        #[inline(always)]
        fn from(val: u8) -> Ic2int {
            Ic2int::from_bits(val)
        }
    }
    impl From<Ic2int> for u8 {
        #[inline(always)]
        fn from(val: Ic2int) -> u8 {
            Ic2int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic2sel {
        #[doc = "pll1_ck is selected (default after reset)."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic2sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic2sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic2sel {
        #[inline(always)]
        fn from(val: u8) -> Ic2sel {
            Ic2sel::from_bits(val)
        }
    }
    impl From<Ic2sel> for u8 {
        #[inline(always)]
        fn from(val: Ic2sel) -> u8 {
            Ic2sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic3int(u8);
    impl Ic3int {
        #[doc = "IC3 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC3 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC3 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC3 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC3 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic3int {
        pub const fn from_bits(val: u8) -> Ic3int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic3int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic3int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic3int {
        #[inline(always)]
        fn from(val: u8) -> Ic3int {
            Ic3int::from_bits(val)
        }
    }
    impl From<Ic3int> for u8 {
        #[inline(always)]
        fn from(val: Ic3int) -> u8 {
            Ic3int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic3sel {
        #[doc = "pll1_ck is selected (default after reset)."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic3sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic3sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic3sel {
        #[inline(always)]
        fn from(val: u8) -> Ic3sel {
            Ic3sel::from_bits(val)
        }
    }
    impl From<Ic3sel> for u8 {
        #[inline(always)]
        fn from(val: Ic3sel) -> u8 {
            Ic3sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic4int(u8);
    impl Ic4int {
        #[doc = "IC4 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC4 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC4 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC4 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC4 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic4int {
        pub const fn from_bits(val: u8) -> Ic4int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic4int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic4int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic4int {
        #[inline(always)]
        fn from(val: u8) -> Ic4int {
            Ic4int::from_bits(val)
        }
    }
    impl From<Ic4int> for u8 {
        #[inline(always)]
        fn from(val: Ic4int) -> u8 {
            Ic4int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic4sel {
        #[doc = "pll1_ck is selected (default after reset)."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic4sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic4sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic4sel {
        #[inline(always)]
        fn from(val: u8) -> Ic4sel {
            Ic4sel::from_bits(val)
        }
    }
    impl From<Ic4sel> for u8 {
        #[inline(always)]
        fn from(val: Ic4sel) -> u8 {
            Ic4sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic5int(u8);
    impl Ic5int {
        #[doc = "IC5 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC5 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC5 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC5 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC5 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic5int {
        pub const fn from_bits(val: u8) -> Ic5int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic5int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic5int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic5int {
        #[inline(always)]
        fn from(val: u8) -> Ic5int {
            Ic5int::from_bits(val)
        }
    }
    impl From<Ic5int> for u8 {
        #[inline(always)]
        fn from(val: Ic5int) -> u8 {
            Ic5int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic5sel {
        #[doc = "pll1_ck is selected (default after reset)."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic5sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic5sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic5sel {
        #[inline(always)]
        fn from(val: u8) -> Ic5sel {
            Ic5sel::from_bits(val)
        }
    }
    impl From<Ic5sel> for u8 {
        #[inline(always)]
        fn from(val: Ic5sel) -> u8 {
            Ic5sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic6int(u8);
    impl Ic6int {
        #[doc = "IC6 = pllx_ck."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC6 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC6 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC6 = pllx_ck / 4 (default after reset)."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC6 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic6int {
        pub const fn from_bits(val: u8) -> Ic6int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic6int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic6int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic6int {
        #[inline(always)]
        fn from(val: u8) -> Ic6int {
            Ic6int::from_bits(val)
        }
    }
    impl From<Ic6int> for u8 {
        #[inline(always)]
        fn from(val: Ic6int) -> u8 {
            Ic6int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic6sel {
        #[doc = "pll1_ck is selected (default after reset)."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic6sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic6sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic6sel {
        #[inline(always)]
        fn from(val: u8) -> Ic6sel {
            Ic6sel::from_bits(val)
        }
    }
    impl From<Ic6sel> for u8 {
        #[inline(always)]
        fn from(val: Ic6sel) -> u8 {
            Ic6sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic7int(u8);
    impl Ic7int {
        #[doc = "IC7 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC7 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC7 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC7 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC7 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic7int {
        pub const fn from_bits(val: u8) -> Ic7int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic7int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic7int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic7int {
        #[inline(always)]
        fn from(val: u8) -> Ic7int {
            Ic7int::from_bits(val)
        }
    }
    impl From<Ic7int> for u8 {
        #[inline(always)]
        fn from(val: Ic7int) -> u8 {
            Ic7int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic7sel {
        #[doc = "pll1_ck is selected."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected (default after reset)."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic7sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic7sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic7sel {
        #[inline(always)]
        fn from(val: u8) -> Ic7sel {
            Ic7sel::from_bits(val)
        }
    }
    impl From<Ic7sel> for u8 {
        #[inline(always)]
        fn from(val: Ic7sel) -> u8 {
            Ic7sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic8int(u8);
    impl Ic8int {
        #[doc = "IC8 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC8 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC8 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC8 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC8 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic8int {
        pub const fn from_bits(val: u8) -> Ic8int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic8int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic8int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic8int {
        #[inline(always)]
        fn from(val: u8) -> Ic8int {
            Ic8int::from_bits(val)
        }
    }
    impl From<Ic8int> for u8 {
        #[inline(always)]
        fn from(val: Ic8int) -> u8 {
            Ic8int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic8sel {
        #[doc = "pll1_ck is selected."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected (default after reset)."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic8sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic8sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic8sel {
        #[inline(always)]
        fn from(val: u8) -> Ic8sel {
            Ic8sel::from_bits(val)
        }
    }
    impl From<Ic8sel> for u8 {
        #[inline(always)]
        fn from(val: Ic8sel) -> u8 {
            Ic8sel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ic9int(u8);
    impl Ic9int {
        #[doc = "IC9 = pllx_ck (default after reset)."]
        pub const DIV1: Self = Self(0x0);
        #[doc = "IC9 = pllx_ck / 2."]
        pub const DIV2: Self = Self(0x01);
        #[doc = "IC9 = pllx_ck / 3."]
        pub const DIV3: Self = Self(0x02);
        #[doc = "IC9 = pllx_ck / 4."]
        pub const DIV4: Self = Self(0x03);
        #[doc = "IC9 = pllx_ck / 256."]
        pub const DIV256: Self = Self(0xff);
    }
    impl Ic9int {
        pub const fn from_bits(val: u8) -> Ic9int {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl core::fmt::Debug for Ic9int {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self.0 {
                0x0 => f.write_str("DIV1"),
                0x01 => f.write_str("DIV2"),
                0x02 => f.write_str("DIV3"),
                0x03 => f.write_str("DIV4"),
                0xff => f.write_str("DIV256"),
                other => core::write!(f, "0x{:02X}", other),
            }
        }
    }
    #[cfg(feature = "defmt")]
    impl defmt::Format for Ic9int {
        fn format(&self, f: defmt::Formatter) {
            match self.0 {
                0x0 => defmt::write!(f, "DIV1"),
                0x01 => defmt::write!(f, "DIV2"),
                0x02 => defmt::write!(f, "DIV3"),
                0x03 => defmt::write!(f, "DIV4"),
                0xff => defmt::write!(f, "DIV256"),
                other => defmt::write!(f, "0x{:02X}", other),
            }
        }
    }
    impl From<u8> for Ic9int {
        #[inline(always)]
        fn from(val: u8) -> Ic9int {
            Ic9int::from_bits(val)
        }
    }
    impl From<Ic9int> for u8 {
        #[inline(always)]
        fn from(val: Ic9int) -> u8 {
            Ic9int::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ic9sel {
        #[doc = "pll1_ck is selected."]
        PLL1 = 0x0,
        #[doc = "pll2_ck is selected (default after reset)."]
        PLL2 = 0x01,
        #[doc = "hsi_ck = hsi_osc_ck / 4."]
        HSI_OSC_DIV4 = 0x02,
        #[doc = "hsi_ck = hsi_osc_ck / 8."]
        HSI_OSC_DIV8 = 0x03,
    }
    impl Ic9sel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ic9sel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ic9sel {
        #[inline(always)]
        fn from(val: u8) -> Ic9sel {
            Ic9sel::from_bits(val)
        }
    }
    impl From<Ic9sel> for u8 {
        #[inline(always)]
        fn from(val: Ic9sel) -> u8 {
            Ic9sel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Iclock {
        #[doc = "IC10 configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "IC10 configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Iclock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Iclock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Iclock {
        #[inline(always)]
        fn from(val: u8) -> Iclock {
            Iclock::from_bits(val)
        }
    }
    impl From<Iclock> for u8 {
        #[inline(always)]
        fn from(val: Iclock) -> u8 {
            Iclock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Icpub {
        #[doc = "IC10 configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "IC10 configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Icpub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Icpub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Icpub {
        #[inline(always)]
        fn from(val: u8) -> Icpub {
            Icpub::from_bits(val)
        }
    }
    impl From<Icpub> for u8 {
        #[inline(always)]
        fn from(val: Icpub) -> u8 {
            Icpub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Icpv {
        #[doc = "IC10 configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIVILEGE = 0x0,
        #[doc = "IC10 configuration bits are accessible by privilege software only."]
        PRIVILEGE = 0x01,
    }
    impl Icpv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Icpv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Icpv {
        #[inline(always)]
        fn from(val: u8) -> Icpv {
            Icpv::from_bits(val)
        }
    }
    impl From<Icpv> for u8 {
        #[inline(always)]
        fn from(val: Icpv) -> u8 {
            Icpv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Icsec {
        #[doc = "IC10 configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "IC10 configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Icsec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Icsec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Icsec {
        #[inline(always)]
        fn from(val: u8) -> Icsec {
            Icsec::from_bits(val)
        }
    }
    impl From<Icsec> for u8 {
        #[inline(always)]
        fn from(val: Icsec) -> u8 {
            Icsec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Intlock {
        #[doc = "INT configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "INT configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Intlock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Intlock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Intlock {
        #[inline(always)]
        fn from(val: u8) -> Intlock {
            Intlock::from_bits(val)
        }
    }
    impl From<Intlock> for u8 {
        #[inline(always)]
        fn from(val: Intlock) -> u8 {
            Intlock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Intpub {
        #[doc = "INT configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "INT configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Intpub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Intpub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Intpub {
        #[inline(always)]
        fn from(val: u8) -> Intpub {
            Intpub::from_bits(val)
        }
    }
    impl From<Intpub> for u8 {
        #[inline(always)]
        fn from(val: Intpub) -> u8 {
            Intpub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Intpv {
        #[doc = "INT configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIVILEGE = 0x0,
        #[doc = "INT configuration bits are accessible by privilege software only."]
        PRIVILEGE = 0x01,
    }
    impl Intpv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Intpv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Intpv {
        #[inline(always)]
        fn from(val: u8) -> Intpv {
            Intpv::from_bits(val)
        }
    }
    impl From<Intpv> for u8 {
        #[inline(always)]
        fn from(val: Intpv) -> u8 {
            Intpv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Intsec {
        #[doc = "INT configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "INT configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Intsec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Intsec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Intsec {
        #[inline(always)]
        fn from(val: u8) -> Intsec {
            Intsec::from_bits(val)
        }
    }
    impl From<Intsec> for u8 {
        #[inline(always)]
        fn from(val: Intsec) -> u8 {
            Intsec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lptimsel {
        #[doc = "pclk1 selected as reference clock."]
        PCLK1 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic15_ck selected as reference clock."]
        IC15 = 0x02,
        #[doc = "lse_ck selected as reference clock."]
        LSE = 0x03,
        #[doc = "lsi_ck selected as reference clock."]
        LSI = 0x04,
        #[doc = "timg_ck selected as reference clock."]
        TIMG = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Lptimsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lptimsel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lptimsel {
        #[inline(always)]
        fn from(val: u8) -> Lptimsel {
            Lptimsel::from_bits(val)
        }
    }
    impl From<Lptimsel> for u8 {
        #[inline(always)]
        fn from(val: Lptimsel) -> u8 {
            Lptimsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lpuartsel {
        #[doc = "pclk4 selected as reference clock."]
        PCLK4 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic9_ck selected as reference clock."]
        IC9 = 0x02,
        #[doc = "ic14_ck selected as reference clock."]
        IC14 = 0x03,
        #[doc = "lse_ck selected as reference clock."]
        LSE = 0x04,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x05,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Lpuartsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lpuartsel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lpuartsel {
        #[inline(always)]
        fn from(val: u8) -> Lpuartsel {
            Lpuartsel::from_bits(val)
        }
    }
    impl From<Lpuartsel> for u8 {
        #[inline(always)]
        fn from(val: Lpuartsel) -> u8 {
            Lpuartsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsebyp {
        #[doc = "LSE oscillator not bypassed (default after reset)."]
        NO_BYPASS = 0x0,
        #[doc = "LSE oscillator bypassed with an external clock."]
        BYPASS = 0x01,
    }
    impl Lsebyp {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsebyp {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsebyp {
        #[inline(always)]
        fn from(val: u8) -> Lsebyp {
            Lsebyp::from_bits(val)
        }
    }
    impl From<Lsebyp> for u8 {
        #[inline(always)]
        fn from(val: Lsebyp) -> u8 {
            Lsebyp::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsecssc {
        #[doc = "LSECSSF not modified (default after reset)."]
        NOT_MODIFIED = 0x0,
        #[doc = "LSECSSF cleared."]
        CLEARED = 0x01,
    }
    impl Lsecssc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsecssc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsecssc {
        #[inline(always)]
        fn from(val: u8) -> Lsecssc {
            Lsecssc::from_bits(val)
        }
    }
    impl From<Lsecssc> for u8 {
        #[inline(always)]
        fn from(val: Lsecssc) -> u8 {
            Lsecssc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsecssd {
        #[doc = "No failure detected on the oscillator (default after reset)."]
        NOT_DETECTED = 0x0,
        #[doc = "Failure detected on the oscillator."]
        DETECTED = 0x01,
    }
    impl Lsecssd {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsecssd {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsecssd {
        #[inline(always)]
        fn from(val: u8) -> Lsecssd {
            Lsecssd::from_bits(val)
        }
    }
    impl From<Lsecssd> for u8 {
        #[inline(always)]
        fn from(val: Lsecssd) -> u8 {
            Lsecssd::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsecssf {
        #[doc = "no clock ready interrupt caused by the LSE (default after reset)."]
        NO_READY = 0x0,
        #[doc = "clock ready interrupt caused by the LSE."]
        READY = 0x01,
    }
    impl Lsecssf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsecssf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsecssf {
        #[inline(always)]
        fn from(val: u8) -> Lsecssf {
            Lsecssf::from_bits(val)
        }
    }
    impl From<Lsecssf> for u8 {
        #[inline(always)]
        fn from(val: Lsecssf) -> u8 {
            Lsecssf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsecssie {
        #[doc = "LSE CSS interrupt disabled (default after reset)."]
        DISABLED = 0x0,
        #[doc = "LSE CSS interrupt enabled."]
        ENABLED = 0x01,
    }
    impl Lsecssie {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsecssie {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsecssie {
        #[inline(always)]
        fn from(val: u8) -> Lsecssie {
            Lsecssie::from_bits(val)
        }
    }
    impl From<Lsecssie> for u8 {
        #[inline(always)]
        fn from(val: Lsecssie) -> u8 {
            Lsecssie::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsecssra {
        #[doc = "Writing 0 has no effect (default after reset)."]
        NO_EFFECT = 0x0,
        #[doc = "Writing 1 generates a re-arm pulse for the LSECSS function."]
        RE_ARM = 0x01,
    }
    impl Lsecssra {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsecssra {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsecssra {
        #[inline(always)]
        fn from(val: u8) -> Lsecssra {
            Lsecssra::from_bits(val)
        }
    }
    impl From<Lsecssra> for u8 {
        #[inline(always)]
        fn from(val: Lsecssra) -> u8 {
            Lsecssra::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsedrv {
        #[doc = "Lowest drive (default after reset)."]
        LOWEST = 0x0,
        #[doc = "Medium low drive."]
        MEDIUM_LOW = 0x01,
        #[doc = "Medium high drive."]
        MEDIUM_HIGH = 0x02,
        #[doc = "Highest drive."]
        HIGHEST = 0x03,
    }
    impl Lsedrv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsedrv {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsedrv {
        #[inline(always)]
        fn from(val: u8) -> Lsedrv {
            Lsedrv::from_bits(val)
        }
    }
    impl From<Lsedrv> for u8 {
        #[inline(always)]
        fn from(val: Lsedrv) -> u8 {
            Lsedrv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lseext {
        #[doc = "LSE in analog mode (default after reset)."]
        ANALOG = 0x0,
        #[doc = "LSE in digital mode."]
        DIGITAL = 0x01,
    }
    impl Lseext {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lseext {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lseext {
        #[inline(always)]
        fn from(val: u8) -> Lseext {
            Lseext::from_bits(val)
        }
    }
    impl From<Lseext> for u8 {
        #[inline(always)]
        fn from(val: Lseext) -> u8 {
            Lseext::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lselock {
        #[doc = "LSE configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "LSE configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Lselock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lselock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lselock {
        #[inline(always)]
        fn from(val: u8) -> Lselock {
            Lselock::from_bits(val)
        }
    }
    impl From<Lselock> for u8 {
        #[inline(always)]
        fn from(val: Lselock) -> u8 {
            Lselock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsepub {
        #[doc = "LSE configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "LSE configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Lsepub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsepub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsepub {
        #[inline(always)]
        fn from(val: u8) -> Lsepub {
            Lsepub::from_bits(val)
        }
    }
    impl From<Lsepub> for u8 {
        #[inline(always)]
        fn from(val: Lsepub) -> u8 {
            Lsepub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsepv {
        #[doc = "LSE configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIVILEGE = 0x0,
        #[doc = "LSE configuration bits are accessible by privilege software only."]
        PRIVILAGE = 0x01,
    }
    impl Lsepv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsepv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsepv {
        #[inline(always)]
        fn from(val: u8) -> Lsepv {
            Lsepv::from_bits(val)
        }
    }
    impl From<Lsepv> for u8 {
        #[inline(always)]
        fn from(val: Lsepv) -> u8 {
            Lsepv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lserdy {
        #[doc = "LSE is not ready (default after reset)."]
        NOT_READY = 0x0,
        #[doc = "LSE is ready."]
        READY = 0x01,
    }
    impl Lserdy {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lserdy {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lserdy {
        #[inline(always)]
        fn from(val: u8) -> Lserdy {
            Lserdy::from_bits(val)
        }
    }
    impl From<Lserdy> for u8 {
        #[inline(always)]
        fn from(val: Lserdy) -> u8 {
            Lserdy::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lserdyc {
        #[doc = "LSERDYF not modified (default after reset)."]
        NOT_MODIFIED = 0x0,
        #[doc = "LSERDYF cleared."]
        CLEARED = 0x01,
    }
    impl Lserdyc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lserdyc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lserdyc {
        #[inline(always)]
        fn from(val: u8) -> Lserdyc {
            Lserdyc::from_bits(val)
        }
    }
    impl From<Lserdyc> for u8 {
        #[inline(always)]
        fn from(val: Lserdyc) -> u8 {
            Lserdyc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lserdyf {
        #[doc = "no clock ready interrupt caused by the LSE (default after reset)."]
        NO_READY = 0x0,
        #[doc = "clock ready interrupt caused by the LSE."]
        READY = 0x01,
    }
    impl Lserdyf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lserdyf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lserdyf {
        #[inline(always)]
        fn from(val: u8) -> Lserdyf {
            Lserdyf::from_bits(val)
        }
    }
    impl From<Lserdyf> for u8 {
        #[inline(always)]
        fn from(val: Lserdyf) -> u8 {
            Lserdyf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lserdyie {
        #[doc = "LSE ready interrupt disabled (default after reset)."]
        DISABLED = 0x0,
        #[doc = "LSE ready interrupt enabled."]
        ENABLED = 0x01,
    }
    impl Lserdyie {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lserdyie {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lserdyie {
        #[inline(always)]
        fn from(val: u8) -> Lserdyie {
            Lserdyie::from_bits(val)
        }
    }
    impl From<Lserdyie> for u8 {
        #[inline(always)]
        fn from(val: Lserdyie) -> u8 {
            Lserdyie::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsesec {
        #[doc = "LSE configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "LSE configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Lsesec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsesec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsesec {
        #[inline(always)]
        fn from(val: u8) -> Lsesec {
            Lsesec::from_bits(val)
        }
    }
    impl From<Lsesec> for u8 {
        #[inline(always)]
        fn from(val: Lsesec) -> u8 {
            Lsesec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsilock {
        #[doc = "LSI configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "LSI configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Lsilock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsilock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsilock {
        #[inline(always)]
        fn from(val: u8) -> Lsilock {
            Lsilock::from_bits(val)
        }
    }
    impl From<Lsilock> for u8 {
        #[inline(always)]
        fn from(val: Lsilock) -> u8 {
            Lsilock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsipub {
        #[doc = "LSI configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "LSI configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Lsipub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsipub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsipub {
        #[inline(always)]
        fn from(val: u8) -> Lsipub {
            Lsipub::from_bits(val)
        }
    }
    impl From<Lsipub> for u8 {
        #[inline(always)]
        fn from(val: Lsipub) -> u8 {
            Lsipub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsipv {
        #[doc = "LSI configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIVILEGE = 0x0,
        #[doc = "LSI configuration bits are accessible by privilege software only."]
        PRIVILEGE = 0x01,
    }
    impl Lsipv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsipv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsipv {
        #[inline(always)]
        fn from(val: u8) -> Lsipv {
            Lsipv::from_bits(val)
        }
    }
    impl From<Lsipv> for u8 {
        #[inline(always)]
        fn from(val: Lsipv) -> u8 {
            Lsipv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsirdy {
        #[doc = "LSI is not ready (default after reset)."]
        NOT_READY = 0x0,
        #[doc = "LSI is ready."]
        READY = 0x01,
    }
    impl Lsirdy {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsirdy {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsirdy {
        #[inline(always)]
        fn from(val: u8) -> Lsirdy {
            Lsirdy::from_bits(val)
        }
    }
    impl From<Lsirdy> for u8 {
        #[inline(always)]
        fn from(val: Lsirdy) -> u8 {
            Lsirdy::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsirdyc {
        #[doc = "LSIRDYF not modified (default after reset)."]
        NOT_MODIFIED = 0x0,
        #[doc = "LSIRDYF cleared."]
        CLEARED = 0x01,
    }
    impl Lsirdyc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsirdyc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsirdyc {
        #[inline(always)]
        fn from(val: u8) -> Lsirdyc {
            Lsirdyc::from_bits(val)
        }
    }
    impl From<Lsirdyc> for u8 {
        #[inline(always)]
        fn from(val: Lsirdyc) -> u8 {
            Lsirdyc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsirdyf {
        #[doc = "no clock ready interrupt caused by the LSI (default after reset)."]
        NO_INTERRUPT = 0x0,
        #[doc = "clock ready interrupt caused by the LSI."]
        INTERRUPT = 0x01,
    }
    impl Lsirdyf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsirdyf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsirdyf {
        #[inline(always)]
        fn from(val: u8) -> Lsirdyf {
            Lsirdyf::from_bits(val)
        }
    }
    impl From<Lsirdyf> for u8 {
        #[inline(always)]
        fn from(val: Lsirdyf) -> u8 {
            Lsirdyf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsirdyie {
        #[doc = "LSI ready interrupt disabled (default after reset)."]
        DISABLED = 0x0,
        #[doc = "LSI ready interrupt enabled."]
        ENABLED = 0x01,
    }
    impl Lsirdyie {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsirdyie {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsirdyie {
        #[inline(always)]
        fn from(val: u8) -> Lsirdyie {
            Lsirdyie::from_bits(val)
        }
    }
    impl From<Lsirdyie> for u8 {
        #[inline(always)]
        fn from(val: Lsirdyie) -> u8 {
            Lsirdyie::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Lsisec {
        #[doc = "LSI configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "LSI configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Lsisec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lsisec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lsisec {
        #[inline(always)]
        fn from(val: u8) -> Lsisec {
            Lsisec::from_bits(val)
        }
    }
    impl From<Lsisec> for u8 {
        #[inline(always)]
        fn from(val: Lsisec) -> u8 {
            Lsisec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ltdcsel {
        #[doc = "pclk5 selected as reference clock."]
        PCLK5 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic16_ck selected as reference clock."]
        IC16 = 0x02,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x03,
    }
    impl Ltdcsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ltdcsel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ltdcsel {
        #[inline(always)]
        fn from(val: u8) -> Ltdcsel {
            Ltdcsel::from_bits(val)
        }
    }
    impl From<Ltdcsel> for u8 {
        #[inline(always)]
        fn from(val: Ltdcsel) -> u8 {
            Ltdcsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Mcopre {
        #[doc = "ck_icn_p_mce3 is divided by 1."]
        DIV1 = 0x0,
        #[doc = "ck_icn_p_mce3 is divided by 2."]
        DIV2 = 0x01,
        #[doc = "ck_icn_p_mce3 is divided by 3."]
        DIV3 = 0x02,
        #[doc = "ck_icn_p_mce3 is divided by 4."]
        DIV4 = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
        _RESERVED_8 = 0x08,
        _RESERVED_9 = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        #[doc = "ck_icn_p_mce3 is divided by 16."]
        DIV16 = 0x0f,
    }
    impl Mcopre {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Mcopre {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Mcopre {
        #[inline(always)]
        fn from(val: u8) -> Mcopre {
            Mcopre::from_bits(val)
        }
    }
    impl From<Mcopre> for u8 {
        #[inline(always)]
        fn from(val: Mcopre) -> u8 {
            Mcopre::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Mcosel {
        #[doc = "hsi_div_ck selected as reference clock (default after reset)."]
        HSI_DIV = 0x0,
        #[doc = "lse_ck selected as reference clock."]
        LSE = 0x01,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x02,
        #[doc = "lsi_ck selected as reference clock."]
        LSI = 0x03,
        #[doc = "hse_ck selected as reference clock."]
        HSE = 0x04,
        #[doc = "ic5_ck selected as reference clock."]
        IC5 = 0x05,
        #[doc = "ic10_ck selected as reference clock."]
        IC10 = 0x06,
        #[doc = "sysa_ck selected as reference clock."]
        SYSA = 0x07,
    }
    impl Mcosel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Mcosel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Mcosel {
        #[inline(always)]
        fn from(val: u8) -> Mcosel {
            Mcosel::from_bits(val)
        }
    }
    impl From<Mcosel> for u8 {
        #[inline(always)]
        fn from(val: Mcosel) -> u8 {
            Mcosel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Mdfsel {
        #[doc = "hclk2 selected as reference clock."]
        HCLK2 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic7_ck selected as reference clock."]
        IC7 = 0x02,
        #[doc = "ic8_ck selected as reference clock."]
        IC8 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        #[doc = "I2S_CKIN selected as reference clock."]
        I2S_CKIN = 0x06,
        #[doc = "timg_ck selected as reference clock."]
        TIMG = 0x07,
    }
    impl Mdfsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Mdfsel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Mdfsel {
        #[inline(always)]
        fn from(val: u8) -> Mdfsel {
            Mdfsel::from_bits(val)
        }
    }
    impl From<Mdfsel> for u8 {
        #[inline(always)]
        fn from(val: Mdfsel) -> u8 {
            Mdfsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Modlock {
        #[doc = "MOD configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "MOD configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Modlock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Modlock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Modlock {
        #[inline(always)]
        fn from(val: u8) -> Modlock {
            Modlock::from_bits(val)
        }
    }
    impl From<Modlock> for u8 {
        #[inline(always)]
        fn from(val: Modlock) -> u8 {
            Modlock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Modpub {
        #[doc = "MOD configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "MOD configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Modpub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Modpub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Modpub {
        #[inline(always)]
        fn from(val: u8) -> Modpub {
            Modpub::from_bits(val)
        }
    }
    impl From<Modpub> for u8 {
        #[inline(always)]
        fn from(val: Modpub) -> u8 {
            Modpub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Modpv {
        #[doc = "MOD configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIVILEGE = 0x0,
        #[doc = "MOD configuration bits are accessible by privilege software only."]
        PRIVILEGE = 0x01,
    }
    impl Modpv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Modpv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Modpv {
        #[inline(always)]
        fn from(val: u8) -> Modpv {
            Modpv::from_bits(val)
        }
    }
    impl From<Modpv> for u8 {
        #[inline(always)]
        fn from(val: Modpv) -> u8 {
            Modpv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Modsec {
        #[doc = "MOD configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "MOD configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Modsec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Modsec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Modsec {
        #[inline(always)]
        fn from(val: u8) -> Modsec {
            Modsec::from_bits(val)
        }
    }
    impl From<Modsec> for u8 {
        #[inline(always)]
        fn from(val: Modsec) -> u8 {
            Modsec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Mrd {
        #[doc = "No extra delay added by the BOOTROM."]
        NO_DELAY = 0x0,
        #[doc = "100 us."]
        _100US = 0x01,
        #[doc = "200 us."]
        _200US = 0x02,
        #[doc = "500 us."]
        _500US = 0x03,
        #[doc = "1 ms."]
        _1MS = 0x04,
        #[doc = "2 ms."]
        _2MS = 0x05,
        #[doc = "5 ms (default after reset)."]
        _5MS = 0x06,
        #[doc = "10 ms."]
        _10MS = 0x07,
        #[doc = "20 ms."]
        _20MS = 0x08,
        #[doc = "50 ms."]
        _50MS = 0x09,
        #[doc = "100 ms."]
        _100MS = 0x0a,
        #[doc = "200 ms."]
        _200MS = 0x0b,
        #[doc = "500 ms."]
        _500MS = 0x0c,
        #[doc = "1 s."]
        _1S = 0x0d,
        #[doc = "2 s."]
        _2S = 0x0e,
        #[doc = "5 s."]
        _3S = 0x0f,
        _RESERVED_10 = 0x10,
        _RESERVED_11 = 0x11,
        _RESERVED_12 = 0x12,
        _RESERVED_13 = 0x13,
        _RESERVED_14 = 0x14,
        _RESERVED_15 = 0x15,
        _RESERVED_16 = 0x16,
        _RESERVED_17 = 0x17,
        _RESERVED_18 = 0x18,
        _RESERVED_19 = 0x19,
        _RESERVED_1a = 0x1a,
        _RESERVED_1b = 0x1b,
        _RESERVED_1c = 0x1c,
        _RESERVED_1d = 0x1d,
        _RESERVED_1e = 0x1e,
        _RESERVED_1f = 0x1f,
    }
    impl Mrd {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Mrd {
            unsafe { core::mem::transmute(val & 0x1f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Mrd {
        #[inline(always)]
        fn from(val: u8) -> Mrd {
            Mrd::from_bits(val)
        }
    }
    impl From<Mrd> for u8 {
        #[inline(always)]
        fn from(val: Mrd) -> u8 {
            Mrd::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Msifreqsel {
        #[doc = "MSI oscillator frequency is 4 MHz (default after backup domain reset)."]
        _4MHZ = 0x0,
        #[doc = "MSI oscillator frequency is 16 MHz."]
        _16MHZ = 0x01,
    }
    impl Msifreqsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Msifreqsel {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Msifreqsel {
        #[inline(always)]
        fn from(val: u8) -> Msifreqsel {
            Msifreqsel::from_bits(val)
        }
    }
    impl From<Msifreqsel> for u8 {
        #[inline(always)]
        fn from(val: Msifreqsel) -> u8 {
            Msifreqsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Msilock {
        #[doc = "MSI configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "MSI configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Msilock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Msilock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Msilock {
        #[inline(always)]
        fn from(val: u8) -> Msilock {
            Msilock::from_bits(val)
        }
    }
    impl From<Msilock> for u8 {
        #[inline(always)]
        fn from(val: Msilock) -> u8 {
            Msilock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Msipub {
        #[doc = "MSI configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUB = 0x0,
        #[doc = "MSI configuration bits are accessible by public software only."]
        PUB = 0x01,
    }
    impl Msipub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Msipub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Msipub {
        #[inline(always)]
        fn from(val: u8) -> Msipub {
            Msipub::from_bits(val)
        }
    }
    impl From<Msipub> for u8 {
        #[inline(always)]
        fn from(val: Msipub) -> u8 {
            Msipub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Msipv {
        #[doc = "MSI configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIVILEGE = 0x0,
        #[doc = "MSI configuration bits are accessible by privilege software only."]
        PRIVILEGE = 0x01,
    }
    impl Msipv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Msipv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Msipv {
        #[inline(always)]
        fn from(val: u8) -> Msipv {
            Msipv::from_bits(val)
        }
    }
    impl From<Msipv> for u8 {
        #[inline(always)]
        fn from(val: Msipv) -> u8 {
            Msipv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Msirdy {
        #[doc = "MSI is not ready (default after reset)."]
        NOT_READY = 0x0,
        #[doc = "MSI is ready."]
        READY = 0x01,
    }
    impl Msirdy {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Msirdy {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Msirdy {
        #[inline(always)]
        fn from(val: u8) -> Msirdy {
            Msirdy::from_bits(val)
        }
    }
    impl From<Msirdy> for u8 {
        #[inline(always)]
        fn from(val: Msirdy) -> u8 {
            Msirdy::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Msirdyc {
        #[doc = "MSIRDYF not modified (default after reset)."]
        NOT_MODIFIED = 0x0,
        #[doc = "MSIRDYF cleared."]
        CLEARED = 0x01,
    }
    impl Msirdyc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Msirdyc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Msirdyc {
        #[inline(always)]
        fn from(val: u8) -> Msirdyc {
            Msirdyc::from_bits(val)
        }
    }
    impl From<Msirdyc> for u8 {
        #[inline(always)]
        fn from(val: Msirdyc) -> u8 {
            Msirdyc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Msirdyf {
        #[doc = "no clock ready interrupt caused by the MSI (default after reset)."]
        NO_INTERRUPT = 0x0,
        #[doc = "clock ready interrupt caused by the MSI."]
        INTERRUPT = 0x01,
    }
    impl Msirdyf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Msirdyf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Msirdyf {
        #[inline(always)]
        fn from(val: u8) -> Msirdyf {
            Msirdyf::from_bits(val)
        }
    }
    impl From<Msirdyf> for u8 {
        #[inline(always)]
        fn from(val: Msirdyf) -> u8 {
            Msirdyf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Msirdyie {
        #[doc = "MSI ready interrupt disabled (default after reset)."]
        DISABLED = 0x0,
        #[doc = "MSI ready interrupt enabled."]
        ENABLED = 0x01,
    }
    impl Msirdyie {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Msirdyie {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Msirdyie {
        #[inline(always)]
        fn from(val: u8) -> Msirdyie {
            Msirdyie::from_bits(val)
        }
    }
    impl From<Msirdyie> for u8 {
        #[inline(always)]
        fn from(val: Msirdyie) -> u8 {
            Msirdyie::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Msisec {
        #[doc = "MSI configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "MSI configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Msisec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Msisec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Msisec {
        #[inline(always)]
        fn from(val: u8) -> Msisec {
            Msisec::from_bits(val)
        }
    }
    impl From<Msisec> for u8 {
        #[inline(always)]
        fn from(val: Msisec) -> u8 {
            Msisec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Noclock {
        #[doc = "NOC configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "NOC configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Noclock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Noclock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Noclock {
        #[inline(always)]
        fn from(val: u8) -> Noclock {
            Noclock::from_bits(val)
        }
    }
    impl From<Noclock> for u8 {
        #[inline(always)]
        fn from(val: Noclock) -> u8 {
            Noclock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Nocpub {
        #[doc = "NOC configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "NOC configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Nocpub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Nocpub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Nocpub {
        #[inline(always)]
        fn from(val: u8) -> Nocpub {
            Nocpub::from_bits(val)
        }
    }
    impl From<Nocpub> for u8 {
        #[inline(always)]
        fn from(val: Nocpub) -> u8 {
            Nocpub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Nocpv {
        #[doc = "NOC configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIVILEGE = 0x0,
        #[doc = "NOC configuration bits are accessible by privilege software only."]
        PRIVILEGE = 0x01,
    }
    impl Nocpv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Nocpv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Nocpv {
        #[inline(always)]
        fn from(val: u8) -> Nocpv {
            Nocpv::from_bits(val)
        }
    }
    impl From<Nocpv> for u8 {
        #[inline(always)]
        fn from(val: Nocpv) -> u8 {
            Nocpv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Nocsec {
        #[doc = "NOC configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "NOC configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Nocsec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Nocsec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Nocsec {
        #[inline(always)]
        fn from(val: u8) -> Nocsec {
            Nocsec::from_bits(val)
        }
    }
    impl From<Nocsec> for u8 {
        #[inline(always)]
        fn from(val: Nocsec) -> u8 {
            Nocsec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Npucacherampub {
        #[doc = "NPUCACHERAM configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "NPUCACHERAM configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Npucacherampub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Npucacherampub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Npucacherampub {
        #[inline(always)]
        fn from(val: u8) -> Npucacherampub {
            Npucacherampub::from_bits(val)
        }
    }
    impl From<Npucacherampub> for u8 {
        #[inline(always)]
        fn from(val: Npucacherampub) -> u8 {
            Npucacherampub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Otgphysel {
        #[doc = "hse_ck selected as reference clock."]
        HSE = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic15_ck selected as reference clock."]
        IC15 = 0x02,
        #[doc = "hse_div2_osc_ck selected as reference clock."]
        HSE_DIV2_OSC = 0x03,
    }
    impl Otgphysel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Otgphysel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Otgphysel {
        #[inline(always)]
        fn from(val: u8) -> Otgphysel {
            Otgphysel::from_bits(val)
        }
    }
    impl From<Otgphysel> for u8 {
        #[inline(always)]
        fn from(val: Otgphysel) -> u8 {
            Otgphysel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Perlock {
        #[doc = "PER configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "PER configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Perlock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Perlock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Perlock {
        #[inline(always)]
        fn from(val: u8) -> Perlock {
            Perlock::from_bits(val)
        }
    }
    impl From<Perlock> for u8 {
        #[inline(always)]
        fn from(val: Perlock) -> u8 {
            Perlock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Perpub {
        #[doc = "PER configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "PER configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Perpub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Perpub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Perpub {
        #[inline(always)]
        fn from(val: u8) -> Perpub {
            Perpub::from_bits(val)
        }
    }
    impl From<Perpub> for u8 {
        #[inline(always)]
        fn from(val: Perpub) -> u8 {
            Perpub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Perpv {
        #[doc = "PER configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIVILEGE = 0x0,
        #[doc = "PER configuration bits are accessible by privilege software only."]
        PRIVILEGE = 0x01,
    }
    impl Perpv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Perpv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Perpv {
        #[inline(always)]
        fn from(val: u8) -> Perpv {
            Perpv::from_bits(val)
        }
    }
    impl From<Perpv> for u8 {
        #[inline(always)]
        fn from(val: Perpv) -> u8 {
            Perpv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Persec {
        #[doc = "PER configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "PER configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Persec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Persec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Persec {
        #[inline(always)]
        fn from(val: u8) -> Persec {
            Persec::from_bits(val)
        }
    }
    impl From<Persec> for u8 {
        #[inline(always)]
        fn from(val: Persec) -> u8 {
            Persec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Persel {
        #[doc = "hsi_ck selected as reference clock."]
        HSI = 0x0,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x01,
        #[doc = "hse_ck selected as reference clock."]
        HSE = 0x02,
        #[doc = "ic19_ck selected as reference clock."]
        IC19 = 0x03,
        #[doc = "ic5_ck selected as reference clock."]
        IC5 = 0x04,
        #[doc = "ic10_ck selected as reference clock."]
        IC10 = 0x05,
        #[doc = "ic15_ck selected as reference clock."]
        IC15 = 0x06,
        #[doc = "ic20_ck selected as reference clock."]
        IC20 = 0x07,
    }
    impl Persel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Persel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Persel {
        #[inline(always)]
        fn from(val: u8) -> Persel {
            Persel::from_bits(val)
        }
    }
    impl From<Persel> for u8 {
        #[inline(always)]
        fn from(val: Persel) -> u8 {
            Persel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Pllbyp {
        #[doc = "PLL output is driven by the VCO, via the optional POSTDIV division."]
        VCO_POSTDIV = 0x0,
        #[doc = "PLL output is bypassed and driven by the PLL reference clock (default after reset)."]
        BYPASS = 0x01,
    }
    impl Pllbyp {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Pllbyp {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Pllbyp {
        #[inline(always)]
        fn from(val: u8) -> Pllbyp {
            Pllbyp::from_bits(val)
        }
    }
    impl From<Pllbyp> for u8 {
        #[inline(always)]
        fn from(val: Pllbyp) -> u8 {
            Pllbyp::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Plldivm {
        #[doc = "Not applicable when PLL is enabled."]
        NOT_APPLICABLE = 0x0,
        #[doc = "reference clock is divided by 1 (min value)."]
        DIV1 = 0x01,
        #[doc = "reference clock is divided by 2."]
        DIV2 = 0x02,
        _RESERVED_3 = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
        _RESERVED_8 = 0x08,
        _RESERVED_9 = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        _RESERVED_f = 0x0f,
        _RESERVED_10 = 0x10,
        _RESERVED_11 = 0x11,
        _RESERVED_12 = 0x12,
        _RESERVED_13 = 0x13,
        _RESERVED_14 = 0x14,
        _RESERVED_15 = 0x15,
        _RESERVED_16 = 0x16,
        _RESERVED_17 = 0x17,
        _RESERVED_18 = 0x18,
        _RESERVED_19 = 0x19,
        _RESERVED_1a = 0x1a,
        _RESERVED_1b = 0x1b,
        _RESERVED_1c = 0x1c,
        _RESERVED_1d = 0x1d,
        _RESERVED_1e = 0x1e,
        _RESERVED_1f = 0x1f,
        _RESERVED_20 = 0x20,
        _RESERVED_21 = 0x21,
        _RESERVED_22 = 0x22,
        _RESERVED_23 = 0x23,
        _RESERVED_24 = 0x24,
        _RESERVED_25 = 0x25,
        _RESERVED_26 = 0x26,
        _RESERVED_27 = 0x27,
        _RESERVED_28 = 0x28,
        _RESERVED_29 = 0x29,
        _RESERVED_2a = 0x2a,
        _RESERVED_2b = 0x2b,
        _RESERVED_2c = 0x2c,
        _RESERVED_2d = 0x2d,
        _RESERVED_2e = 0x2e,
        _RESERVED_2f = 0x2f,
        _RESERVED_30 = 0x30,
        _RESERVED_31 = 0x31,
        _RESERVED_32 = 0x32,
        _RESERVED_33 = 0x33,
        _RESERVED_34 = 0x34,
        _RESERVED_35 = 0x35,
        _RESERVED_36 = 0x36,
        _RESERVED_37 = 0x37,
        _RESERVED_38 = 0x38,
        _RESERVED_39 = 0x39,
        _RESERVED_3a = 0x3a,
        _RESERVED_3b = 0x3b,
        _RESERVED_3c = 0x3c,
        _RESERVED_3d = 0x3d,
        _RESERVED_3e = 0x3e,
        #[doc = "reference clock is divided by 63."]
        DIV63 = 0x3f,
    }
    impl Plldivm {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Plldivm {
            unsafe { core::mem::transmute(val & 0x3f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Plldivm {
        #[inline(always)]
        fn from(val: u8) -> Plldivm {
            Plldivm::from_bits(val)
        }
    }
    impl From<Plldivm> for u8 {
        #[inline(always)]
        fn from(val: Plldivm) -> u8 {
            Plldivm::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Plllock {
        #[doc = "PLL1 configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "PLL1 configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Plllock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Plllock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Plllock {
        #[inline(always)]
        fn from(val: u8) -> Plllock {
            Plllock::from_bits(val)
        }
    }
    impl From<Plllock> for u8 {
        #[inline(always)]
        fn from(val: Plllock) -> u8 {
            Plllock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Pllmodsprdw {
        #[doc = "Center-spread modulation selected (default after reset)."]
        CENTER_SPREAD = 0x0,
        #[doc = "Down-spread modulation selected."]
        DOWN_SPREAD = 0x01,
    }
    impl Pllmodsprdw {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Pllmodsprdw {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Pllmodsprdw {
        #[inline(always)]
        fn from(val: u8) -> Pllmodsprdw {
            Pllmodsprdw::from_bits(val)
        }
    }
    impl From<Pllmodsprdw> for u8 {
        #[inline(always)]
        fn from(val: Pllmodsprdw) -> u8 {
            Pllmodsprdw::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Pllmodssdis {
        #[doc = "Modulation Spread-Spectrum is active (and Fractional Divide inactive)."]
        MODULATION_SPREAD_SPECTRUM = 0x0,
        #[doc = "Fractional Divide is active (and the Modulation Spread-Spectrum inactive) (default after reset)."]
        FRACTIONAL_DIVIDE = 0x01,
    }
    impl Pllmodssdis {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Pllmodssdis {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Pllmodssdis {
        #[inline(always)]
        fn from(val: u8) -> Pllmodssdis {
            Pllmodssdis::from_bits(val)
        }
    }
    impl From<Pllmodssdis> for u8 {
        #[inline(always)]
        fn from(val: Pllmodssdis) -> u8 {
            Pllmodssdis::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Pllpdiv {
        #[doc = "Not applicable."]
        NOT_APPLICABLE = 0x0,
        #[doc = "VCO output is divided by 1 (minimum value) (default after reset)."]
        DIV1 = 0x01,
        _RESERVED_2 = 0x02,
        _RESERVED_3 = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        #[doc = "VCO output is divided by 7."]
        DIV7 = 0x07,
    }
    impl Pllpdiv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Pllpdiv {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Pllpdiv {
        #[inline(always)]
        fn from(val: u8) -> Pllpdiv {
            Pllpdiv::from_bits(val)
        }
    }
    impl From<Pllpdiv> for u8 {
        #[inline(always)]
        fn from(val: Pllpdiv) -> u8 {
            Pllpdiv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Pllpub {
        #[doc = "PLL1 configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "PLL1 configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Pllpub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Pllpub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Pllpub {
        #[inline(always)]
        fn from(val: u8) -> Pllpub {
            Pllpub::from_bits(val)
        }
    }
    impl From<Pllpub> for u8 {
        #[inline(always)]
        fn from(val: Pllpub) -> u8 {
            Pllpub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Pllpv {
        #[doc = "PLL1 configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIVILEGE = 0x0,
        #[doc = "PLL1 configuration bits are accessible by privilege software only."]
        PRIVILEGE = 0x01,
    }
    impl Pllpv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Pllpv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Pllpv {
        #[inline(always)]
        fn from(val: u8) -> Pllpv {
            Pllpv::from_bits(val)
        }
    }
    impl From<Pllpv> for u8 {
        #[inline(always)]
        fn from(val: Pllpv) -> u8 {
            Pllpv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Pllrdy {
        #[doc = "PLL1 unlocked (default after reset)."]
        UNLOCKED = 0x0,
        #[doc = "PLL1 locked."]
        LOCKED = 0x01,
    }
    impl Pllrdy {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Pllrdy {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Pllrdy {
        #[inline(always)]
        fn from(val: u8) -> Pllrdy {
            Pllrdy::from_bits(val)
        }
    }
    impl From<Pllrdy> for u8 {
        #[inline(always)]
        fn from(val: Pllrdy) -> u8 {
            Pllrdy::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Pllrdyc {
        #[doc = "PLL1RDYF not modified (default after reset)."]
        NOT_MODIFIED = 0x0,
        #[doc = "PLL1RDYF cleared."]
        CLEARED = 0x01,
    }
    impl Pllrdyc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Pllrdyc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Pllrdyc {
        #[inline(always)]
        fn from(val: u8) -> Pllrdyc {
            Pllrdyc::from_bits(val)
        }
    }
    impl From<Pllrdyc> for u8 {
        #[inline(always)]
        fn from(val: Pllrdyc) -> u8 {
            Pllrdyc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Pllrdyf {
        #[doc = "no clock ready interrupt caused by the PLL1 (default after reset)."]
        NO_INTERRUPT = 0x0,
        #[doc = "clock ready interrupt caused by the PLL1."]
        INTERRUPT = 0x01,
    }
    impl Pllrdyf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Pllrdyf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Pllrdyf {
        #[inline(always)]
        fn from(val: u8) -> Pllrdyf {
            Pllrdyf::from_bits(val)
        }
    }
    impl From<Pllrdyf> for u8 {
        #[inline(always)]
        fn from(val: Pllrdyf) -> u8 {
            Pllrdyf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Pllrdyie {
        #[doc = "PLL1 lock interrupt disabled (default after reset)."]
        DISABLED = 0x0,
        #[doc = "PLL1 lock interrupt enabled."]
        ENABLED = 0x01,
    }
    impl Pllrdyie {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Pllrdyie {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Pllrdyie {
        #[inline(always)]
        fn from(val: u8) -> Pllrdyie {
            Pllrdyie::from_bits(val)
        }
    }
    impl From<Pllrdyie> for u8 {
        #[inline(always)]
        fn from(val: Pllrdyie) -> u8 {
            Pllrdyie::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Pllsec {
        #[doc = "PLL1 configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "PLL1 configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Pllsec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Pllsec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Pllsec {
        #[inline(always)]
        fn from(val: u8) -> Pllsec {
            Pllsec::from_bits(val)
        }
    }
    impl From<Pllsec> for u8 {
        #[inline(always)]
        fn from(val: Pllsec) -> u8 {
            Pllsec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Pllsel {
        #[doc = "hsi_ck selected as reference clock."]
        HSI = 0x0,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x01,
        #[doc = "hse_ck selected as reference clock."]
        HSE = 0x02,
        #[doc = "I2S_CKIN selected as reference clock."]
        I2S_CKIN = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Pllsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Pllsel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Pllsel {
        #[inline(always)]
        fn from(val: u8) -> Pllsel {
            Pllsel::from_bits(val)
        }
    }
    impl From<Pllsel> for u8 {
        #[inline(always)]
        fn from(val: Pllsel) -> u8 {
            Pllsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Ppre {
        #[doc = "rcc_pclk1 = sys_bus2_ck (default after reset)."]
        DIV1 = 0x0,
        #[doc = "rcc_pclk1 = sys_bus2_ck / 2."]
        DIV2 = 0x01,
        #[doc = "rcc_pclk1 = sys_bus2_ck / 4."]
        DIV4 = 0x02,
        #[doc = "rcc_pclk1 = sys_bus2_ck / 8."]
        DIV8 = 0x03,
        #[doc = "rcc_pclk1 = sys_bus2_ck / 16."]
        DIV16 = 0x04,
        #[doc = "rcc_pclk1 = sys_bus2_ck / 32."]
        DIV32 = 0x05,
        #[doc = "rcc_pclk1 = sys_bus2_ck / 64."]
        DIV64 = 0x06,
        #[doc = "rcc_pclk1 = sys_bus2_ck / 128."]
        DIV128 = 0x07,
    }
    impl Ppre {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ppre {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ppre {
        #[inline(always)]
        fn from(val: u8) -> Ppre {
            Ppre::from_bits(val)
        }
    }
    impl From<Ppre> for u8 {
        #[inline(always)]
        fn from(val: Ppre) -> u8 {
            Ppre::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Pssisel {
        #[doc = "hclk5 selected as reference clock."]
        HCLK5 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic20_ck selected as reference clock."]
        IC20 = 0x02,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x03,
    }
    impl Pssisel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Pssisel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Pssisel {
        #[inline(always)]
        fn from(val: u8) -> Pssisel {
            Pssisel::from_bits(val)
        }
    }
    impl From<Pssisel> for u8 {
        #[inline(always)]
        fn from(val: Pssisel) -> u8 {
            Pssisel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum RsrBorrstf {
        #[doc = "no BOR occurred."]
        ABSENCE = 0x0,
        #[doc = "BOR occurred (default after power-on reset)."]
        OCCURRED = 0x01,
    }
    impl RsrBorrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> RsrBorrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for RsrBorrstf {
        #[inline(always)]
        fn from(val: u8) -> RsrBorrstf {
            RsrBorrstf::from_bits(val)
        }
    }
    impl From<RsrBorrstf> for u8 {
        #[inline(always)]
        fn from(val: RsrBorrstf) -> u8 {
            RsrBorrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum RsrIwdgrstf {
        #[doc = "no Independent Watchdog reset occurred (default after power-on reset)."]
        ABSENCE = 0x0,
        #[doc = "Independent Watchdog reset occurred."]
        OCCURRED = 0x01,
    }
    impl RsrIwdgrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> RsrIwdgrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for RsrIwdgrstf {
        #[inline(always)]
        fn from(val: u8) -> RsrIwdgrstf {
            RsrIwdgrstf::from_bits(val)
        }
    }
    impl From<RsrIwdgrstf> for u8 {
        #[inline(always)]
        fn from(val: RsrIwdgrstf) -> u8 {
            RsrIwdgrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum RsrLckrstf {
        #[doc = "No reset from CPU lockup occurred."]
        ABSENCE = 0x0,
        #[doc = "Reset from CPU lockup occurred."]
        OCCURRED = 0x01,
    }
    impl RsrLckrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> RsrLckrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for RsrLckrstf {
        #[inline(always)]
        fn from(val: u8) -> RsrLckrstf {
            RsrLckrstf::from_bits(val)
        }
    }
    impl From<RsrLckrstf> for u8 {
        #[inline(always)]
        fn from(val: RsrLckrstf) -> u8 {
            RsrLckrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum RsrLpwrrstf {
        #[doc = "no illegal reset occurred (default after power-on reset)."]
        ABSENCE = 0x0,
        #[doc = "illegal Stop or Standby reset occurred."]
        OCCURRED = 0x01,
    }
    impl RsrLpwrrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> RsrLpwrrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for RsrLpwrrstf {
        #[inline(always)]
        fn from(val: u8) -> RsrLpwrrstf {
            RsrLpwrrstf::from_bits(val)
        }
    }
    impl From<RsrLpwrrstf> for u8 {
        #[inline(always)]
        fn from(val: RsrLpwrrstf) -> u8 {
            RsrLpwrrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum RsrPinrstf {
        #[doc = "no reset from Pin occurred."]
        ABSENCE = 0x0,
        #[doc = "Reset from Pin occurred (default after power-on reset)."]
        OCCURRED = 0x01,
    }
    impl RsrPinrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> RsrPinrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for RsrPinrstf {
        #[inline(always)]
        fn from(val: u8) -> RsrPinrstf {
            RsrPinrstf::from_bits(val)
        }
    }
    impl From<RsrPinrstf> for u8 {
        #[inline(always)]
        fn from(val: RsrPinrstf) -> u8 {
            RsrPinrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum RsrPorrstf {
        #[doc = "no POR/PDR reset occurred."]
        ABSENCE = 0x0,
        #[doc = "POR/PDR reset occurred (default after power-on reset)."]
        OCCURRED = 0x01,
    }
    impl RsrPorrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> RsrPorrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for RsrPorrstf {
        #[inline(always)]
        fn from(val: u8) -> RsrPorrstf {
            RsrPorrstf::from_bits(val)
        }
    }
    impl From<RsrPorrstf> for u8 {
        #[inline(always)]
        fn from(val: RsrPorrstf) -> u8 {
            RsrPorrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum RsrRmvf {
        #[doc = "clear of the reset flags not activated (default after power-on reset)."]
        NO_CLEAR = 0x0,
        #[doc = "clear the value of the reset flags."]
        CLEAR = 0x01,
    }
    impl RsrRmvf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> RsrRmvf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for RsrRmvf {
        #[inline(always)]
        fn from(val: u8) -> RsrRmvf {
            RsrRmvf::from_bits(val)
        }
    }
    impl From<RsrRmvf> for u8 {
        #[inline(always)]
        fn from(val: RsrRmvf) -> u8 {
            RsrRmvf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum RsrSftrstf {
        #[doc = "no Software System reset occurred (default after power-on reset)."]
        ABSENCE = 0x0,
        #[doc = "a Software System reset has been generated by the CPU."]
        OCCURRED = 0x01,
    }
    impl RsrSftrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> RsrSftrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for RsrSftrstf {
        #[inline(always)]
        fn from(val: u8) -> RsrSftrstf {
            RsrSftrstf::from_bits(val)
        }
    }
    impl From<RsrSftrstf> for u8 {
        #[inline(always)]
        fn from(val: RsrSftrstf) -> u8 {
            RsrSftrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum RsrWwdgrstf {
        #[doc = "no Window Watchdog reset occurred from WWDG (default after power-on reset)."]
        ABSENCE = 0x0,
        #[doc = "Window Watchdog reset occurred from WWDG."]
        OCCURRED = 0x01,
    }
    impl RsrWwdgrstf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> RsrWwdgrstf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for RsrWwdgrstf {
        #[inline(always)]
        fn from(val: u8) -> RsrWwdgrstf {
            RsrWwdgrstf::from_bits(val)
        }
    }
    impl From<RsrWwdgrstf> for u8 {
        #[inline(always)]
        fn from(val: RsrWwdgrstf) -> u8 {
            RsrWwdgrstf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Rstlock {
        #[doc = "RST configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "RST configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Rstlock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Rstlock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Rstlock {
        #[inline(always)]
        fn from(val: u8) -> Rstlock {
            Rstlock::from_bits(val)
        }
    }
    impl From<Rstlock> for u8 {
        #[inline(always)]
        fn from(val: Rstlock) -> u8 {
            Rstlock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Rstpub {
        #[doc = "RST configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "RST configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Rstpub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Rstpub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Rstpub {
        #[inline(always)]
        fn from(val: u8) -> Rstpub {
            Rstpub::from_bits(val)
        }
    }
    impl From<Rstpub> for u8 {
        #[inline(always)]
        fn from(val: Rstpub) -> u8 {
            Rstpub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Rstpv {
        #[doc = "RST configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIVILEGE = 0x0,
        #[doc = "RST configuration bits are accessible by privilege software only."]
        PRIVILEGE = 0x01,
    }
    impl Rstpv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Rstpv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Rstpv {
        #[inline(always)]
        fn from(val: u8) -> Rstpv {
            Rstpv::from_bits(val)
        }
    }
    impl From<Rstpv> for u8 {
        #[inline(always)]
        fn from(val: Rstpv) -> u8 {
            Rstpv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Rstsec {
        #[doc = "RST configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "RST configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Rstsec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Rstsec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Rstsec {
        #[inline(always)]
        fn from(val: u8) -> Rstsec {
            Rstsec::from_bits(val)
        }
    }
    impl From<Rstsec> for u8 {
        #[inline(always)]
        fn from(val: Rstsec) -> u8 {
            Rstsec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Rtcpre {
        #[doc = "ck_icn_p_risaf is divided by 1."]
        DIV1 = 0x0,
        #[doc = "ck_icn_p_risaf is divided by 2."]
        DIV2 = 0x01,
        #[doc = "ck_icn_p_risaf is divided by 3."]
        DIV3 = 0x02,
        #[doc = "ck_icn_p_risaf is divided by 4."]
        DIV4 = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
        _RESERVED_8 = 0x08,
        _RESERVED_9 = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        _RESERVED_f = 0x0f,
        _RESERVED_10 = 0x10,
        _RESERVED_11 = 0x11,
        _RESERVED_12 = 0x12,
        _RESERVED_13 = 0x13,
        _RESERVED_14 = 0x14,
        _RESERVED_15 = 0x15,
        _RESERVED_16 = 0x16,
        _RESERVED_17 = 0x17,
        _RESERVED_18 = 0x18,
        _RESERVED_19 = 0x19,
        _RESERVED_1a = 0x1a,
        _RESERVED_1b = 0x1b,
        _RESERVED_1c = 0x1c,
        _RESERVED_1d = 0x1d,
        _RESERVED_1e = 0x1e,
        _RESERVED_1f = 0x1f,
        _RESERVED_20 = 0x20,
        _RESERVED_21 = 0x21,
        _RESERVED_22 = 0x22,
        _RESERVED_23 = 0x23,
        _RESERVED_24 = 0x24,
        _RESERVED_25 = 0x25,
        _RESERVED_26 = 0x26,
        _RESERVED_27 = 0x27,
        _RESERVED_28 = 0x28,
        _RESERVED_29 = 0x29,
        _RESERVED_2a = 0x2a,
        _RESERVED_2b = 0x2b,
        _RESERVED_2c = 0x2c,
        _RESERVED_2d = 0x2d,
        _RESERVED_2e = 0x2e,
        _RESERVED_2f = 0x2f,
        _RESERVED_30 = 0x30,
        _RESERVED_31 = 0x31,
        _RESERVED_32 = 0x32,
        _RESERVED_33 = 0x33,
        _RESERVED_34 = 0x34,
        _RESERVED_35 = 0x35,
        _RESERVED_36 = 0x36,
        _RESERVED_37 = 0x37,
        _RESERVED_38 = 0x38,
        _RESERVED_39 = 0x39,
        _RESERVED_3a = 0x3a,
        _RESERVED_3b = 0x3b,
        _RESERVED_3c = 0x3c,
        _RESERVED_3d = 0x3d,
        _RESERVED_3e = 0x3e,
        #[doc = "ck_icn_p_risaf is divided by 64."]
        DIV64 = 0x3f,
    }
    impl Rtcpre {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Rtcpre {
            unsafe { core::mem::transmute(val & 0x3f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Rtcpre {
        #[inline(always)]
        fn from(val: u8) -> Rtcpre {
            Rtcpre::from_bits(val)
        }
    }
    impl From<Rtcpre> for u8 {
        #[inline(always)]
        fn from(val: Rtcpre) -> u8 {
            Rtcpre::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Rtcsel {
        _RESERVED_0 = 0x0,
        #[doc = "lse_ck selected as reference clock."]
        LSE = 0x01,
        #[doc = "lsi_ck selected as reference clock."]
        LSI = 0x02,
        #[doc = "hse_rtc_ck selected as reference clock."]
        HSE_RTC = 0x03,
    }
    impl Rtcsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Rtcsel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Rtcsel {
        #[inline(always)]
        fn from(val: u8) -> Rtcsel {
            Rtcsel::from_bits(val)
        }
    }
    impl From<Rtcsel> for u8 {
        #[inline(always)]
        fn from(val: Rtcsel) -> u8 {
            Rtcsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Saisel {
        #[doc = "pclk2 selected as reference clock."]
        PCLK2 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic7_ck selected as reference clock."]
        IC7 = 0x02,
        #[doc = "ic8_ck selected as reference clock."]
        IC8 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        #[doc = "I2S_CKIN selected as reference clock."]
        I2S_CKIN = 0x06,
        #[doc = "spdif_symb_ck selected as reference clock."]
        SPDIF_SYMB = 0x07,
    }
    impl Saisel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Saisel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Saisel {
        #[inline(always)]
        fn from(val: u8) -> Saisel {
            Saisel::from_bits(val)
        }
    }
    impl From<Saisel> for u8 {
        #[inline(always)]
        fn from(val: Saisel) -> u8 {
            Saisel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Sdmmcsel {
        #[doc = "hclku selected as reference clock."]
        HCLKU = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic4_ck selected as reference clock."]
        IC4 = 0x02,
        #[doc = "ic5_ck selected as reference clock."]
        IC5 = 0x03,
    }
    impl Sdmmcsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Sdmmcsel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Sdmmcsel {
        #[inline(always)]
        fn from(val: u8) -> Sdmmcsel {
            Sdmmcsel::from_bits(val)
        }
    }
    impl From<Sdmmcsel> for u8 {
        #[inline(always)]
        fn from(val: Sdmmcsel) -> u8 {
            Sdmmcsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Spdifrxsel {
        #[doc = "pclk1 selected as reference clock."]
        PCLK1 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic7_ck selected as reference clock."]
        IC7 = 0x02,
        #[doc = "ic8_ck selected as reference clock."]
        IC8 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        #[doc = "I2S_CKIN selected as reference clock."]
        I2S_CKIN = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Spdifrxsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Spdifrxsel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Spdifrxsel {
        #[inline(always)]
        fn from(val: u8) -> Spdifrxsel {
            Spdifrxsel::from_bits(val)
        }
    }
    impl From<Spdifrxsel> for u8 {
        #[inline(always)]
        fn from(val: Spdifrxsel) -> u8 {
            Spdifrxsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Spisel1 {
        #[doc = "pclk2 selected as reference clock."]
        PCLK2 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic8_ck selected as reference clock."]
        IC8 = 0x02,
        #[doc = "ic9_ck selected as reference clock."]
        IC9 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        #[doc = "I2S_CKIN selected as reference clock."]
        I2S_CKIN = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Spisel1 {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Spisel1 {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Spisel1 {
        #[inline(always)]
        fn from(val: u8) -> Spisel1 {
            Spisel1::from_bits(val)
        }
    }
    impl From<Spisel1> for u8 {
        #[inline(always)]
        fn from(val: Spisel1) -> u8 {
            Spisel1::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Spisel23 {
        #[doc = "pclk1 selected as reference clock."]
        PCLK1 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic8_ck selected as reference clock."]
        IC8 = 0x02,
        #[doc = "ic9_ck selected as reference clock."]
        IC9 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        #[doc = "I2S_CKIN selected as reference clock."]
        I2S_CKIN = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Spisel23 {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Spisel23 {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Spisel23 {
        #[inline(always)]
        fn from(val: u8) -> Spisel23 {
            Spisel23::from_bits(val)
        }
    }
    impl From<Spisel23> for u8 {
        #[inline(always)]
        fn from(val: Spisel23) -> u8 {
            Spisel23::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Spisel45 {
        #[doc = "pclk2 selected as reference clock."]
        PCLK2 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic9_ck selected as reference clock."]
        IC9 = 0x02,
        #[doc = "ic14_ck selected as reference clock."]
        IC14 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        #[doc = "I2S_CKIN selected as reference clock."]
        I2S_CKIN = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Spisel45 {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Spisel45 {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Spisel45 {
        #[inline(always)]
        fn from(val: u8) -> Spisel45 {
            Spisel45::from_bits(val)
        }
    }
    impl From<Spisel45> for u8 {
        #[inline(always)]
        fn from(val: Spisel45) -> u8 {
            Spisel45::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Spisel6 {
        #[doc = "pclk2 selected as reference clock."]
        PCLK4 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic8_ck selected as reference clock."]
        IC8 = 0x02,
        #[doc = "ic9_ck selected as reference clock."]
        IC9 = 0x03,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x04,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x05,
        #[doc = "I2S_CKIN selected as reference clock."]
        I2S_CKIN = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Spisel6 {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Spisel6 {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Spisel6 {
        #[inline(always)]
        fn from(val: u8) -> Spisel6 {
            Spisel6::from_bits(val)
        }
    }
    impl From<Spisel6> for u8 {
        #[inline(always)]
        fn from(val: Spisel6) -> u8 {
            Spisel6::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Stopwuck {
        #[doc = "HSI selected as wake up clock from system Stop (default after reset)."]
        HSI = 0x0,
        #[doc = "CSI selected as wake up clock from system Stop."]
        CSI = 0x01,
    }
    impl Stopwuck {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Stopwuck {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Stopwuck {
        #[inline(always)]
        fn from(val: u8) -> Stopwuck {
            Stopwuck::from_bits(val)
        }
    }
    impl From<Stopwuck> for u8 {
        #[inline(always)]
        fn from(val: Stopwuck) -> u8 {
            Stopwuck::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Syslock {
        #[doc = "SYS configuration bits are accessible by non-lock software only (default after reset)."]
        NON_LOCK = 0x0,
        #[doc = "SYS configuration bits are accessible by lock software only."]
        LOCK = 0x01,
    }
    impl Syslock {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Syslock {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Syslock {
        #[inline(always)]
        fn from(val: u8) -> Syslock {
            Syslock::from_bits(val)
        }
    }
    impl From<Syslock> for u8 {
        #[inline(always)]
        fn from(val: Syslock) -> u8 {
            Syslock::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Syspub {
        #[doc = "SYS configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "SYS configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Syspub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Syspub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Syspub {
        #[inline(always)]
        fn from(val: u8) -> Syspub {
            Syspub::from_bits(val)
        }
    }
    impl From<Syspub> for u8 {
        #[inline(always)]
        fn from(val: Syspub) -> u8 {
            Syspub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Syspv {
        #[doc = "SYS configuration bits are accessible by non-privilege software only (default after reset)."]
        NON_PRIVILEGE = 0x0,
        #[doc = "SYS configuration bits are accessible by privilege software only."]
        PRIVILEGE = 0x01,
    }
    impl Syspv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Syspv {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Syspv {
        #[inline(always)]
        fn from(val: u8) -> Syspv {
            Syspv::from_bits(val)
        }
    }
    impl From<Syspv> for u8 {
        #[inline(always)]
        fn from(val: Syspv) -> u8 {
            Syspv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Syssec {
        #[doc = "SYS configuration bits are accessible by non-secure software only (default after reset)."]
        NON_SECURE = 0x0,
        #[doc = "SYS configuration bits are accessible by secure software only."]
        SECURE = 0x01,
    }
    impl Syssec {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Syssec {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Syssec {
        #[inline(always)]
        fn from(val: u8) -> Syssec {
            Syssec::from_bits(val)
        }
    }
    impl From<Syssec> for u8 {
        #[inline(always)]
        fn from(val: Syssec) -> u8 {
            Syssec::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Syssw {
        #[doc = "hsi_ck selected as system clock (default after reset)."]
        HSI = 0x0,
        #[doc = "msi_ck selected as system clock."]
        MSI = 0x01,
        #[doc = "hse_ck selected as system clock."]
        HSE = 0x02,
        #[doc = "ic2_ck selected as system clock."]
        IC2 = 0x03,
    }
    impl Syssw {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Syssw {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Syssw {
        #[inline(always)]
        fn from(val: u8) -> Syssw {
            Syssw::from_bits(val)
        }
    }
    impl From<Syssw> for u8 {
        #[inline(always)]
        fn from(val: Syssw) -> u8 {
            Syssw::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Syssws {
        #[doc = "hsi_ck selected as system clock (default after reset)."]
        HSI = 0x0,
        #[doc = "msi_ck selected as system clock."]
        MSI = 0x01,
        #[doc = "hse_ck selected as system clock."]
        HSE = 0x02,
        #[doc = "ic2_ck selected as system clock."]
        IC2 = 0x03,
    }
    impl Syssws {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Syssws {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Syssws {
        #[inline(always)]
        fn from(val: u8) -> Syssws {
            Syssws::from_bits(val)
        }
    }
    impl From<Syssws> for u8 {
        #[inline(always)]
        fn from(val: Syssws) -> u8 {
            Syssws::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Timpre {
        #[doc = "timg_ck = sys_bus_ck (default after reset)."]
        DIV1 = 0x0,
        #[doc = "timg_ck = sys_bus_ck / 2."]
        DIV2 = 0x01,
        #[doc = "timg_ck = sys_bus_ck / 4."]
        DIV4 = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Timpre {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Timpre {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Timpre {
        #[inline(always)]
        fn from(val: u8) -> Timpre {
            Timpre::from_bits(val)
        }
    }
    impl From<Timpre> for u8 {
        #[inline(always)]
        fn from(val: Timpre) -> u8 {
            Timpre::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Uartsel {
        #[doc = "pclk1 selected as reference clock."]
        PCLK1 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic9_ck selected as reference clock."]
        IC9 = 0x02,
        #[doc = "ic14_ck selected as reference clock."]
        IC14 = 0x03,
        #[doc = "lse_ck selected as reference clock."]
        LSE = 0x04,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x05,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Uartsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Uartsel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Uartsel {
        #[inline(always)]
        fn from(val: u8) -> Uartsel {
            Uartsel::from_bits(val)
        }
    }
    impl From<Uartsel> for u8 {
        #[inline(always)]
        fn from(val: Uartsel) -> u8 {
            Uartsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Usartsel {
        #[doc = "pclk2 selected as reference clock."]
        PCLK2 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic9_ck selected as reference clock."]
        IC9 = 0x02,
        #[doc = "ic14_ck selected as reference clock."]
        IC14 = 0x03,
        #[doc = "lse_ck selected as reference clock."]
        LSE = 0x04,
        #[doc = "msi_ck selected as reference clock."]
        MSI = 0x05,
        #[doc = "hsi_div_ck selected as reference clock."]
        HSI_DIV = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Usartsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Usartsel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Usartsel {
        #[inline(always)]
        fn from(val: u8) -> Usartsel {
            Usartsel::from_bits(val)
        }
    }
    impl From<Usartsel> for u8 {
        #[inline(always)]
        fn from(val: Usartsel) -> u8 {
            Usartsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Vencrampub {
        #[doc = "VENCRAM configuration bits are accessible by non-public software only (default after reset)."]
        NON_PUBLIC = 0x0,
        #[doc = "VENCRAM configuration bits are accessible by public software only."]
        PUBLIC = 0x01,
    }
    impl Vencrampub {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Vencrampub {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Vencrampub {
        #[inline(always)]
        fn from(val: u8) -> Vencrampub {
            Vencrampub::from_bits(val)
        }
    }
    impl From<Vencrampub> for u8 {
        #[inline(always)]
        fn from(val: Vencrampub) -> u8 {
            Vencrampub::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Wkupf {
        #[doc = "no wakeup interrupt caused by the PWR (default after reset)."]
        NO_INTERRUPT = 0x0,
        #[doc = "wakeup interrupt caused by the PWR."]
        INTERRUPT = 0x01,
    }
    impl Wkupf {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Wkupf {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Wkupf {
        #[inline(always)]
        fn from(val: u8) -> Wkupf {
            Wkupf::from_bits(val)
        }
    }
    impl From<Wkupf> for u8 {
        #[inline(always)]
        fn from(val: Wkupf) -> u8 {
            Wkupf::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Wkupfc {
        #[doc = "WKUPF not modified (default after reset)."]
        NOT_MODIFIED = 0x0,
        #[doc = "WKUPF cleared."]
        CLEARED = 0x01,
    }
    impl Wkupfc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Wkupfc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Wkupfc {
        #[inline(always)]
        fn from(val: u8) -> Wkupfc {
            Wkupfc::from_bits(val)
        }
    }
    impl From<Wkupfc> for u8 {
        #[inline(always)]
        fn from(val: Wkupfc) -> u8 {
            Wkupfc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Wkupie {
        #[doc = "Wakeup interrupt disabled (default after reset)."]
        DISABLED = 0x0,
        #[doc = "Wakeup interrupt enabled."]
        ENABLED = 0x01,
    }
    impl Wkupie {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Wkupie {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Wkupie {
        #[inline(always)]
        fn from(val: u8) -> Wkupie {
            Wkupie::from_bits(val)
        }
    }
    impl From<Wkupie> for u8 {
        #[inline(always)]
        fn from(val: Wkupie) -> u8 {
            Wkupie::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Xspisel {
        #[doc = "hclk5 selected as reference clock."]
        HCLK5 = 0x0,
        #[doc = "per_ck selected as reference clock."]
        PER = 0x01,
        #[doc = "ic3_ck selected as reference clock."]
        IC3 = 0x02,
        #[doc = "ic4_ck selected as reference clock."]
        IC4 = 0x03,
    }
    impl Xspisel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Xspisel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Xspisel {
        #[inline(always)]
        fn from(val: u8) -> Xspisel {
            Xspisel::from_bits(val)
        }
    }
    impl From<Xspisel> for u8 {
        #[inline(always)]
        fn from(val: Xspisel) -> u8 {
            Xspisel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
    #[cfg_attr(feature = "defmt", derive(defmt::Format))]
    pub enum Xspisels {
        #[doc = "hclk5 selected as XSPI1 clock (default after reset)."]
        HCLK5 = 0x0,
        #[doc = "per_ck selected as XSPI1 clock."]
        PER = 0x01,
        #[doc = "ic3_ck selected as XSPI1 clock."]
        IC3 = 0x02,
        #[doc = "ic4_ck selected as XSPI1 clock."]
        IC4 = 0x03,
    }
    impl Xspisels {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Xspisels {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Xspisels {
        #[inline(always)]
        fn from(val: u8) -> Xspisels {
            Xspisels::from_bits(val)
        }
    }
    impl From<Xspisels> for u8 {
        #[inline(always)]
        fn from(val: Xspisels) -> u8 {
            Xspisels::to_bits(val)
        }
    }
}
