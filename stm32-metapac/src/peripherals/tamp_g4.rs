#![allow(clippy::missing_safety_doc)]
                #![allow(clippy::identity_op)]
                #![allow(clippy::unnecessary_cast)]
                #![allow(clippy::erasing_op)]

# [doc = "Tamper and backup registers"]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Tamp { ptr : * mut u8 } unsafe impl Send for Tamp { } unsafe impl Sync for Tamp { } impl Tamp { # [inline (always)]
pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)]
pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "control register 1"]
# [inline (always)]
pub const fn cr1 (self) -> crate :: common :: Reg < regs :: Cr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x0usize) as _) } } # [doc = "control register 2"]
# [inline (always)]
pub const fn cr2 (self) -> crate :: common :: Reg < regs :: Cr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x04usize) as _) } } # [doc = "TAMP filter control register"]
# [inline (always)]
pub const fn fltcr (self) -> crate :: common :: Reg < regs :: Fltcr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x0cusize) as _) } } # [doc = "TAMP interrupt enable register"]
# [inline (always)]
pub const fn ier (self) -> crate :: common :: Reg < regs :: Ier , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x2cusize) as _) } } # [doc = "TAMP status register"]
# [inline (always)]
pub const fn sr (self) -> crate :: common :: Reg < regs :: Sr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x30usize) as _) } } # [doc = "TAMP masked interrupt status register"]
# [inline (always)]
pub const fn misr (self) -> crate :: common :: Reg < regs :: Misr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x34usize) as _) } } # [doc = "TAMP status clear register"]
# [inline (always)]
pub const fn scr (self) -> crate :: common :: Reg < regs :: Scr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x3cusize) as _) } } # [doc = "TAMP backup register"]
# [inline (always)]
pub const fn bkpr (self , n : usize) -> crate :: common :: Reg < regs :: Bkpr , crate :: common :: RW > { assert ! (n < 32usize) ; unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x0100usize + n * 4usize) as _) } } } pub mod regs { # [doc = "TAMP backup register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Bkpr (pub u32) ; impl Bkpr { # [doc = "BKP"]
# [inline (always)]
pub const fn bkp (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "BKP"]
# [inline (always)]
pub fn set_bkp (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Bkpr { # [inline (always)]
fn default () -> Bkpr { Bkpr (0) } } # [doc = "control register 1"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Cr1 (pub u32) ; impl Cr1 { # [doc = "Tamper detection on IN X enable"]
# [inline (always)]
pub const fn tampe (& self , n : usize) -> bool { assert ! (n < 3usize) ; let offs = 0usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Tamper detection on IN X enable"]
# [inline (always)]
pub fn set_tampe (& mut self , n : usize , val : bool) { assert ! (n < 3usize) ; let offs = 0usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u32) & 0x01) << offs) ; } # [doc = "Internal tamper X enable"]
# [inline (always)]
pub const fn itampe (& self , n : usize) -> bool { assert ! (n < 6usize) ; let offs = 16usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Internal tamper X enable"]
# [inline (always)]
pub fn set_itampe (& mut self , n : usize , val : bool) { assert ! (n < 6usize) ; let offs = 16usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u32) & 0x01) << offs) ; } } impl Default for Cr1 { # [inline (always)]
fn default () -> Cr1 { Cr1 (0) } } # [doc = "control register 2"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Cr2 (pub u32) ; impl Cr2 { # [doc = "Tamper X no erase"]
# [inline (always)]
pub const fn tampnoer (& self , n : usize) -> bool { assert ! (n < 3usize) ; let offs = 0usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Tamper X no erase"]
# [inline (always)]
pub fn set_tampnoer (& mut self , n : usize , val : bool) { assert ! (n < 3usize) ; let offs = 0usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u32) & 0x01) << offs) ; } # [doc = "Tamper X mask."]
# [inline (always)]
pub const fn tampmsk (& self , n : usize) -> bool { assert ! (n < 3usize) ; let offs = 16usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Tamper X mask."]
# [inline (always)]
pub fn set_tampmsk (& mut self , n : usize , val : bool) { assert ! (n < 3usize) ; let offs = 16usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u32) & 0x01) << offs) ; } # [doc = "Active level for tamper X input."]
# [inline (always)]
pub const fn tamptrg (& self , n : usize) -> bool { assert ! (n < 3usize) ; let offs = 24usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Active level for tamper X input."]
# [inline (always)]
pub fn set_tamptrg (& mut self , n : usize , val : bool) { assert ! (n < 3usize) ; let offs = 24usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u32) & 0x01) << offs) ; } } impl Default for Cr2 { # [inline (always)]
fn default () -> Cr2 { Cr2 (0) } } # [doc = "TAMP filter control register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Fltcr (pub u32) ; impl Fltcr { # [doc = "Tamper sampling frequency. Determines the frequency at which each of the INx inputs are sampled."]
# [inline (always)]
pub const fn tampfreq (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x07 ; val as u8 } # [doc = "Tamper sampling frequency. Determines the frequency at which each of the INx inputs are sampled."]
# [inline (always)]
pub fn set_tampfreq (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize) ; } # [doc = "INx filter count. These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the INx inputs."]
# [inline (always)]
pub const fn tampflt (& self) -> u8 { let val = (self . 0 >> 3usize) & 0x03 ; val as u8 } # [doc = "INx filter count. These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the INx inputs."]
# [inline (always)]
pub fn set_tampflt (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 3usize)) | (((val as u32) & 0x03) << 3usize) ; } # [doc = "INx precharge duration. These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the INx inputs."]
# [inline (always)]
pub const fn tampprch (& self) -> u8 { let val = (self . 0 >> 5usize) & 0x03 ; val as u8 } # [doc = "INx precharge duration. These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the INx inputs."]
# [inline (always)]
pub fn set_tampprch (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 5usize)) | (((val as u32) & 0x03) << 5usize) ; } # [doc = "INx pull-up disable. This bit determines if each of the TAMPx pins are precharged before each sample."]
# [inline (always)]
pub const fn tamppudis (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "INx pull-up disable. This bit determines if each of the TAMPx pins are precharged before each sample."]
# [inline (always)]
pub fn set_tamppudis (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } } impl Default for Fltcr { # [inline (always)]
fn default () -> Fltcr { Fltcr (0) } } # [doc = "TAMP interrupt enable register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Ier (pub u32) ; impl Ier { # [doc = "Tamper X interrupt enable"]
# [inline (always)]
pub const fn tampie (& self , n : usize) -> bool { assert ! (n < 3usize) ; let offs = 0usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Tamper X interrupt enable"]
# [inline (always)]
pub fn set_tampie (& mut self , n : usize , val : bool) { assert ! (n < 3usize) ; let offs = 0usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u32) & 0x01) << offs) ; } # [doc = "Internal tamper X interrupt enable"]
# [inline (always)]
pub const fn itampie (& self , n : usize) -> bool { assert ! (n < 6usize) ; let offs = 16usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Internal tamper X interrupt enable"]
# [inline (always)]
pub fn set_itampie (& mut self , n : usize , val : bool) { assert ! (n < 6usize) ; let offs = 16usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u32) & 0x01) << offs) ; } } impl Default for Ier { # [inline (always)]
fn default () -> Ier { Ier (0) } } # [doc = "TAMP masked interrupt status register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Misr (pub u32) ; impl Misr { # [doc = "Tamper X interrupt masked flag"]
# [inline (always)]
pub const fn tampmf (& self , n : usize) -> bool { assert ! (n < 3usize) ; let offs = 0usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Tamper X interrupt masked flag"]
# [inline (always)]
pub fn set_tampmf (& mut self , n : usize , val : bool) { assert ! (n < 3usize) ; let offs = 0usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u32) & 0x01) << offs) ; } # [doc = "Internal tamper X interrupt masked flag"]
# [inline (always)]
pub const fn itampmf (& self , n : usize) -> bool { assert ! (n < 6usize) ; let offs = 16usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Internal tamper X interrupt masked flag"]
# [inline (always)]
pub fn set_itampmf (& mut self , n : usize , val : bool) { assert ! (n < 6usize) ; let offs = 16usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u32) & 0x01) << offs) ; } } impl Default for Misr { # [inline (always)]
fn default () -> Misr { Misr (0) } } # [doc = "TAMP status clear register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Scr (pub u32) ; impl Scr { # [doc = "Clear tamper X detection flag"]
# [inline (always)]
pub const fn ctampf (& self , n : usize) -> bool { assert ! (n < 3usize) ; let offs = 0usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Clear tamper X detection flag"]
# [inline (always)]
pub fn set_ctampf (& mut self , n : usize , val : bool) { assert ! (n < 3usize) ; let offs = 0usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u32) & 0x01) << offs) ; } # [doc = "Clear internal tamper X detection flag"]
# [inline (always)]
pub const fn citampf (& self , n : usize) -> bool { assert ! (n < 6usize) ; let offs = 16usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Clear internal tamper X detection flag"]
# [inline (always)]
pub fn set_citampf (& mut self , n : usize , val : bool) { assert ! (n < 6usize) ; let offs = 16usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u32) & 0x01) << offs) ; } } impl Default for Scr { # [inline (always)]
fn default () -> Scr { Scr (0) } } # [doc = "TAMP status register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Sr (pub u32) ; impl Sr { # [doc = "Tamper X detection flag"]
# [inline (always)]
pub const fn tampf (& self , n : usize) -> bool { assert ! (n < 3usize) ; let offs = 0usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Tamper X detection flag"]
# [inline (always)]
pub fn set_tampf (& mut self , n : usize , val : bool) { assert ! (n < 3usize) ; let offs = 0usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u32) & 0x01) << offs) ; } # [doc = "Internal tamper X detection flag"]
# [inline (always)]
pub const fn itampf (& self , n : usize) -> bool { assert ! (n < 6usize) ; let offs = 16usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Internal tamper X detection flag"]
# [inline (always)]
pub fn set_itampf (& mut self , n : usize , val : bool) { assert ! (n < 6usize) ; let offs = 16usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u32) & 0x01) << offs) ; } } impl Default for Sr { # [inline (always)]
fn default () -> Sr { Sr (0) } } }